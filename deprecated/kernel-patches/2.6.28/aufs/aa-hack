From: Jeff Mahoney <jeffm@suse.com>
Subject: aufs: AppArmor compatibility

 This patch adds NULL vfsmounts for AppArmor enabled kernels.

Signed-off-by: Jeff Mahoney <jeffm@suse.com>
---
 fs/aufs25/vfsub.c |   18 +++++++++---------
 1 file changed, 9 insertions(+), 9 deletions(-)

--- a/fs/aufs25/vfsub.c
+++ b/fs/aufs25/vfsub.c
@@ -127,9 +127,9 @@ int do_vfsub_create(struct inode *dir, s
 }
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
-#define VfsubSymlinkArgs	dir, dentry, symname
+#define VfsubSymlinkArgs	dir, dentry, NULL, symname
 #else
-#define VfsubSymlinkArgs	dir, dentry, symname, mode
+#define VfsubSymlinkArgs	dir, dentry, NULL, symname, mode
 #endif
 
 int do_vfsub_symlink(struct inode *dir, struct dentry *dentry,
@@ -158,7 +158,7 @@ int do_vfsub_mknod(struct inode *dir, st
 	LKTRTrace("i%lu, %.*s, 0x%x\n", dir->i_ino, AuDLNPair(dentry), mode);
 	IMustLock(dir);
 
-	err = vfs_mknod(dir, dentry, mode, dev);
+	err = vfs_mknod(dir, dentry, NULL, mode, dev);
 	if (!err) {
 		/* dir inode is locked */
 		au_update_fuse_h_inode(NULL, dentry->d_parent); /*ignore*/
@@ -177,7 +177,7 @@ int do_vfsub_link(struct dentry *src_den
 	IMustLock(dir);
 
 	lockdep_off();
-	err = vfs_link(src_dentry, dir, dentry);
+	err = vfs_link(src_dentry, NULL, dir, dentry, 0);
 	lockdep_on();
 	if (!err) {
 		LKTRTrace("src_i %p, dst_i %p\n",
@@ -203,7 +203,7 @@ int do_vfsub_rename(struct inode *src_di
 	IMustLock(src_dir);
 
 	lockdep_off();
-	err = vfs_rename(src_dir, src_dentry, dir, dentry);
+	err = vfs_rename(src_dir, src_dentry, NULL, dir, dentry, 0);
 	lockdep_on();
 	if (!err) {
 		/* dir inode is locked */
@@ -221,7 +221,7 @@ int do_vfsub_mkdir(struct inode *dir, st
 	LKTRTrace("i%lu, %.*s, 0x%x\n", dir->i_ino, AuDLNPair(dentry), mode);
 	IMustLock(dir);
 
-	err = vfs_mkdir(dir, dentry, mode);
+	err = vfs_mkdir(dir, dentry, NULL, mode);
 	if (!err) {
 		/* dir inode is locked */
 		au_update_fuse_h_inode(NULL, dentry->d_parent); /*ignore*/
@@ -238,7 +238,7 @@ int do_vfsub_rmdir(struct inode *dir, st
 	IMustLock(dir);
 
 	lockdep_off();
-	err = vfs_rmdir(dir, dentry);
+	err = vfs_rmdir(dir, dentry, 0);
 	lockdep_on();
 	/* dir inode is locked */
 	if (!err)
@@ -255,7 +255,7 @@ int do_vfsub_unlink(struct inode *dir, s
 
 	/* vfs_unlink() locks inode */
 	lockdep_off();
-	err = vfs_unlink(dir, dentry);
+	err = vfs_unlink(dir, dentry, 0);
 	lockdep_on();
 	/* dir inode is locked */
 	if (!err)
@@ -493,7 +493,7 @@ static void call_notify_change(void *arg
 	if (!IS_IMMUTABLE(h_inode) && !IS_APPEND(h_inode)) {
 		vfsub_ignore(a->vargs);
 		lockdep_off();
-		*a->errp = notify_change(a->h_dentry, a->ia);
+		*a->errp = notify_change(a->h_dentry, NULL, a->ia);
 		lockdep_on();
 		if (!*a->errp)
 			au_update_fuse_h_inode(NULL, a->h_dentry); /*ignore*/
