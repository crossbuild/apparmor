Index: linux-2.6-apparmor/security/apparmor/lsm.c
===================================================================
--- linux-2.6-apparmor.orig/security/apparmor/lsm.c
+++ linux-2.6-apparmor/security/apparmor/lsm.c
@@ -553,6 +553,9 @@ static int apparmor_task_alloc_security(
 	return aa_clone(task);
 }
 
+/*
+ * Called from IRQ context from RCU callback.
+ */
 static void apparmor_task_free_security(struct task_struct *task)
 {
 	aa_release(task);
Index: linux-2.6-apparmor/security/apparmor/inline.h
===================================================================
--- linux-2.6-apparmor.orig/security/apparmor/inline.h
+++ linux-2.6-apparmor/security/apparmor/inline.h
@@ -61,11 +61,11 @@ static inline struct aa_profile *aa_find
 	return profile;
 }
 
-static inline struct aa_task_context *aa_alloc_task_context(void)
+static inline struct aa_task_context *aa_alloc_task_context(gfp_t flags)
 {
 	struct aa_task_context *cxt;
 
-	cxt = kzalloc(sizeof(*cxt), GFP_KERNEL);
+	cxt = kzalloc(sizeof(*cxt), flags);
 	if (cxt) {
 		INIT_LIST_HEAD(&cxt->list);
 		INIT_RCU_HEAD(&cxt->rcu);
Index: linux-2.6-apparmor/security/apparmor/main.c
===================================================================
--- linux-2.6-apparmor.orig/security/apparmor/main.c
+++ linux-2.6-apparmor/security/apparmor/main.c
@@ -748,7 +748,7 @@ int aa_clone(struct task_struct *child)
 
 	if (!aa_task_context(current))
 		return 0;
-	child_cxt = aa_alloc_task_context();
+	child_cxt = aa_alloc_task_context(GFP_KERNEL);
 	if (!child_cxt)
 		return -ENOMEM;
 
@@ -1099,7 +1099,7 @@ int aa_change_hat(const char *hat_name, 
 			hat_magic, current->pid);
 	}
 
-	new_cxt = aa_alloc_task_context();
+	new_cxt = aa_alloc_task_context(GFP_KERNEL);
 	if (!new_cxt)
 		return -ENOMEM;
 
@@ -1195,7 +1195,7 @@ struct aa_profile *aa_replace_profile(st
 	struct aa_profile *old_profile = NULL;
 
 	if (profile) {
-		new_cxt = aa_alloc_task_context();
+		new_cxt = aa_alloc_task_context(GFP_KERNEL);
 		if (!new_cxt)
 			return ERR_PTR(-ENOMEM);
 	}
Index: linux-2.6-apparmor/security/apparmor/module_interface.c
===================================================================
--- linux-2.6-apparmor.orig/security/apparmor/module_interface.c
+++ linux-2.6-apparmor/security/apparmor/module_interface.c
@@ -465,13 +465,7 @@ ssize_t aa_file_prof_replace(void *udata
 	 * actually need it?
 	 */
 	do {
-		new_cxt = aa_alloc_task_context();
-		/*
-		 * FIXME: what do we do when allocation fails --
-		 * I guess allocate in a way that cannot fail.
-		 */
-		if (!new_cxt)
-			break;
+		new_cxt = aa_alloc_task_context(GFP_KERNEL | __GFP_NOFAIL);
 
 		/*
 		 * new_profile needs to be locked in the case that there
