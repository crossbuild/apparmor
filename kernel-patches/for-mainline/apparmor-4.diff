Some cleanups to apparmorfs.c:

 * Prepare by renaming aa_replace_profile to __aa_replace_profile.
 * Rename aa_file_prof_add to aa_add_profile.
 * Rename aa_file_prof_replace to aa_replace_profile.
 * Rename aa_file_prof_remove to aa_remove_profile.
 * Remove the SECFS_AA definition (not very useful),
   aa_fs_dentry (dead code), and AA_FS_DENTRY (not very useful,
   either).
 * Reorder functions to get rid of all the forward declarations.

Index: linux-2.6-apparmor/security/apparmor/apparmor.h
===================================================================
--- linux-2.6-apparmor.orig/security/apparmor/apparmor.h
+++ linux-2.6-apparmor/security/apparmor/apparmor.h
@@ -13,8 +13,8 @@
 #define __APPARMOR_H
 
 #include <linux/sched.h>
-#include <linux/fs.h>	/* Include for defn of iattr */
-#include <linux/binfmts.h>	/* defn of linux_binprm */
+#include <linux/fs.h>
+#include <linux/binfmts.h>
 #include <linux/rcupdate.h>
 
 /*
@@ -231,9 +231,9 @@ extern void aa_release(struct task_struc
 extern int aa_change_hat(const char *id, u64 hat_magic);
 extern struct aa_profile *__aa_find_profile(const char *name,
 					    struct list_head *list);
-extern struct aa_profile *aa_replace_profile(struct task_struct *task,
-					     struct aa_profile *profile,
-					     u32 hat_magic);
+extern struct aa_profile *__aa_replace_profile(struct task_struct *task,
+					       struct aa_profile *profile,
+					       u32 hat_magic);
 extern struct aa_task_context *lock_task_and_profiles(struct task_struct *task,
 						      struct aa_profile *profile);
 extern void aa_change_task_context(struct task_struct *task,
@@ -244,9 +244,9 @@ extern void aa_change_task_context(struc
 extern void aa_profilelist_release(void);
 
 /* module_interface.c */
-extern ssize_t aa_file_prof_add(void *, size_t);
-extern ssize_t aa_file_prof_replace(void *, size_t);
-extern ssize_t aa_file_prof_remove(const char *, size_t);
+extern ssize_t aa_add_profile(void *, size_t);
+extern ssize_t aa_replace_profile(void *, size_t);
+extern ssize_t aa_remove_profile(const char *, size_t);
 extern struct aa_profile *alloc_aa_profile(void);
 extern void free_aa_profile(struct aa_profile *profile);
 extern void free_aa_profile_kref(struct kref *kref);
Index: linux-2.6-apparmor/security/apparmor/apparmorfs.c
===================================================================
--- linux-2.6-apparmor.orig/security/apparmor/apparmorfs.c
+++ linux-2.6-apparmor/security/apparmor/apparmorfs.c
@@ -18,135 +18,6 @@
 #include "apparmor.h"
 #include "inline.h"
 
-#define SECFS_AA "apparmor"
-static struct dentry *aa_fs_dentry = NULL;
-
-/* profile */
-extern struct seq_operations apparmorfs_profiles_op;
-static int aa_prof_open(struct inode *inode, struct file *file);
-static int aa_prof_release(struct inode *inode, struct file *file);
-
-static struct file_operations apparmorfs_profiles_fops = {
-	.open =		aa_prof_open,
-	.read =		seq_read,
-	.llseek =	seq_lseek,
-	.release =	aa_prof_release,
-};
-
-/* matching */
-static ssize_t aa_matching_read(struct file *file, char __user *buf,
-			       size_t size, loff_t *ppos);
-
-static struct file_operations apparmorfs_matching_fops = {
-	.read = 	aa_matching_read,
-};
-
-
-/* interface */
-static ssize_t aa_profile_load(struct file *f, const char __user *buf,
-			       size_t size, loff_t *pos);
-static ssize_t aa_profile_replace(struct file *f, const char __user *buf,
-				  size_t size, loff_t *pos);
-static ssize_t aa_profile_remove(struct file *f, const char __user *buf,
-				 size_t size, loff_t *pos);
-
-static struct file_operations apparmorfs_profile_load = {
-	.write = aa_profile_load
-};
-
-static struct file_operations apparmorfs_profile_replace = {
-	.write = aa_profile_replace
-};
-
-static struct file_operations apparmorfs_profile_remove = {
-	.write = aa_profile_remove
-};
-
-
-/* control */
-static u64 aa_control_get(void *data);
-static void aa_control_set(void *data, u64 val);
-
-DEFINE_SIMPLE_ATTRIBUTE(apparmorfs_control_fops, aa_control_get,
-			aa_control_set, "%lld\n");
-
-
-
-/* table of static entries */
-
-static struct root_entry {
-	const char *name;
-	int mode;
-	int access;
-	struct file_operations *fops;
-	void *data;
-
-	/* internal fields */
-	struct dentry *dentry;
-	int parent_index;
-} root_entries[] = {
-	/* our root, normally /sys/kernel/security/apparmor */
-	{SECFS_AA, 	S_IFDIR, 0555},	/* DO NOT EDIT/MOVE */
-
-	/* interface for obtaining list of profiles currently loaded */
-	{"profiles", 	S_IFREG, 0440, &apparmorfs_profiles_fops,
-				       NULL},
-
-	/* interface for obtaining matching features supported */
-	{"matching",  	S_IFREG, 0444, &apparmorfs_matching_fops,
-				       NULL},
-
-	/* interface for loading/removing/replacing profiles */
-	{".load",    	S_IFREG, 0640, &apparmorfs_profile_load,
-				       NULL},
-	{".replace", 	S_IFREG, 0640, &apparmorfs_profile_replace,
-				       NULL},
-	{".remove",  	S_IFREG, 0640, &apparmorfs_profile_remove,
-				       NULL},
-
-	/* interface for setting binary config values */
-	{"control",  	S_IFDIR, 0550},
-	{"complain", 	S_IFREG, 0640, &apparmorfs_control_fops,
-				       &apparmor_complain},
-	{"audit",    	S_IFREG, 0640, &apparmorfs_control_fops,
-				       &apparmor_audit},
-	{"debug",    	S_IFREG, 0640, &apparmorfs_control_fops,
-				       &apparmor_debug},
-	{"logsyscall", 	S_IFREG, 0640, &apparmorfs_control_fops,
-				       &apparmor_logsyscall},
-	{NULL,       	S_IFDIR, 0},
-
-	/* root end */
-	{NULL,       	S_IFDIR, 0}
-};
-
-#define AA_FS_DENTRY root_entries[0].dentry
-
-static const unsigned int num_entries =
-	sizeof(root_entries) / sizeof(struct root_entry);
-
-
-
-static int aa_prof_open(struct inode *inode, struct file *file)
-{
-	return seq_open(file, &apparmorfs_profiles_op);
-}
-
-
-static int aa_prof_release(struct inode *inode, struct file *file)
-{
-	return seq_release(inode, file);
-}
-
-static ssize_t aa_matching_read(struct file *file, char __user *buf,
-			       size_t size, loff_t *ppos)
-{
-	const char *matching = "pattern=aadfa";
-
-	return simple_read_from_buffer(buf, size, ppos, matching,
-				       strlen(matching));
-}
-
 static char *aa_simple_write_to_buffer(const char __user *userbuf,
 				       size_t alloc_size, size_t copy_size,
 				       loff_t *pos, const char *msg)
@@ -192,6 +63,42 @@ out:
 	return data;
 }
 
+/* apparmor/profiles */
+extern struct seq_operations apparmorfs_profiles_op;
+
+static int aa_profiles_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &apparmorfs_profiles_op);
+}
+
+
+static int aa_profiles_release(struct inode *inode, struct file *file)
+{
+	return seq_release(inode, file);
+}
+
+static struct file_operations apparmorfs_profiles_fops = {
+	.open =		aa_profiles_open,
+	.read =		seq_read,
+	.llseek =	seq_lseek,
+	.release =	aa_profiles_release,
+};
+
+/* apparmor/matching */
+static ssize_t aa_matching_read(struct file *file, char __user *buf,
+			       size_t size, loff_t *ppos)
+{
+	const char *matching = "pattern=aadfa";
+
+	return simple_read_from_buffer(buf, size, ppos, matching,
+				       strlen(matching));
+}
+
+static struct file_operations apparmorfs_matching_fops = {
+	.read = 	aa_matching_read,
+};
+
+/* apparmor/.load */
 static ssize_t aa_profile_load(struct file *f, const char __user *buf,
 			       size_t size, loff_t *pos)
 {
@@ -200,16 +107,21 @@ static ssize_t aa_profile_load(struct fi
 
 	data = aa_simple_write_to_buffer(buf, size, size, pos, "load");
 
+	error = PTR_ERR(data);
 	if (!IS_ERR(data)) {
-		error = aa_file_prof_add(data, size);
+		error = aa_add_profile(data, size);
 		vfree(data);
-	} else {
-		error = PTR_ERR(data);
 	}
 
 	return error;
 }
 
+
+static struct file_operations apparmorfs_profile_load = {
+	.write = aa_profile_load
+};
+
+/* apparmor/.replace */
 static ssize_t aa_profile_replace(struct file *f, const char __user *buf,
 				  size_t size, loff_t *pos)
 {
@@ -218,16 +130,21 @@ static ssize_t aa_profile_replace(struct
 
 	data = aa_simple_write_to_buffer(buf, size, size, pos, "replacement");
 
+	error = PTR_ERR(data);
 	if (!IS_ERR(data)) {
-		error = aa_file_prof_replace(data, size);
+		error = aa_replace_profile(data, size);
 		vfree(data);
-	} else {
-		error = PTR_ERR(data);
 	}
 
 	return error;
 }
 
+
+static struct file_operations apparmorfs_profile_replace = {
+	.write = aa_profile_replace
+};
+
+/* apparmor/.remove */
 static ssize_t aa_profile_remove(struct file *f, const char __user *buf,
 				  size_t size, loff_t *pos)
 {
@@ -239,17 +156,21 @@ static ssize_t aa_profile_remove(struct 
 	 */
 	data = aa_simple_write_to_buffer(buf, size+1, size, pos, "removal");
 
+	error = PTR_ERR(data);
 	if (!IS_ERR(data)) {
 		data[size] = 0;
-		error = aa_file_prof_remove(data, size);
+		error = aa_remove_profile(data, size);
 		vfree(data);
-	} else {
-		error = PTR_ERR(data);
 	}
 
 	return error;
 }
 
+static struct file_operations apparmorfs_profile_remove = {
+	.write = aa_profile_remove
+};
+
+/* apparmor/control/ */
 static u64 aa_control_get(void *data)
 {
 	return *(int *)data;
@@ -263,11 +184,60 @@ static void aa_control_set(void *data, u
 	*(int*)data = (int)val;
 }
 
+DEFINE_SIMPLE_ATTRIBUTE(apparmorfs_control_fops, aa_control_get,
+			aa_control_set, "%lld\n");
+
+static struct root_entry {
+	const char *name;
+	int mode;
+	int access;
+	struct file_operations *fops;
+	void *data;
+
+	/* internal fields */
+	struct dentry *dentry;
+	int parent_index;
+} root_entries[] = {
+	/* our root, normally /sys/kernel/security/apparmor */
+	{"apparmor", 	S_IFDIR, 0555},	/* DO NOT EDIT/MOVE */
+
+	/* interface for obtaining list of profiles currently loaded */
+	{"profiles", 	S_IFREG, 0440, &apparmorfs_profiles_fops,
+				       NULL},
+
+	/* interface for obtaining matching features supported */
+	{"matching",  	S_IFREG, 0444, &apparmorfs_matching_fops,
+				       NULL},
+
+	/* interface for loading/removing/replacing profiles */
+	{".load",    	S_IFREG, 0640, &apparmorfs_profile_load,
+				       NULL},
+	{".replace", 	S_IFREG, 0640, &apparmorfs_profile_replace,
+				       NULL},
+	{".remove",  	S_IFREG, 0640, &apparmorfs_profile_remove,
+				       NULL},
+
+	/* interface for setting binary config values */
+	{"control",  	S_IFDIR, 0550},
+	{"complain", 	S_IFREG, 0640, &apparmorfs_control_fops,
+				       &apparmor_complain},
+	{"audit",    	S_IFREG, 0640, &apparmorfs_control_fops,
+				       &apparmor_audit},
+	{"debug",    	S_IFREG, 0640, &apparmorfs_control_fops,
+				       &apparmor_debug},
+	{"logsyscall", 	S_IFREG, 0640, &apparmorfs_control_fops,
+				       &apparmor_logsyscall},
+	{NULL,       	S_IFDIR, 0},
+
+	/* root end */
+	{NULL,       	S_IFDIR, 0}
+};
+
 static void clear_apparmorfs(void)
 {
 	unsigned int i;
 
-	for (i=0; i < num_entries;i++) {
+	for (i=0; i < ARRAY_SIZE(root_entries); i++) {
 		unsigned int index;
 
 		if (root_entries[i].mode == S_IFDIR) {
@@ -277,9 +247,8 @@ static void clear_apparmorfs(void)
 			else
 				/* cleanup parent */
 				index = root_entries[i].parent_index;
-		} else {
+		} else
 			index = i;
-		}
 
 		if (root_entries[index].dentry) {
 			securityfs_remove(root_entries[index].dentry);
@@ -296,21 +265,21 @@ static void clear_apparmorfs(void)
 	}
 }
 
-static int populate_apparmorfs(struct dentry *root)
+static int populate_apparmorfs(void)
 {
 	unsigned int i, parent_index, depth;
 
-	for (i = 0; i < num_entries; i++) {
+	for (i = 0; i < ARRAY_SIZE(root_entries); i++) {
 		root_entries[i].dentry = NULL;
 		root_entries[i].parent_index = 0;
 	}
 
 	/* 1. Verify entry 0 is valid [sanity check] */
-	if (num_entries == 0 ||
+	if (ARRAY_SIZE(root_entries) == 0 ||
 	    !root_entries[0].name ||
-	    strcmp(root_entries[0].name, SECFS_AA) != 0 ||
+	    strcmp(root_entries[0].name, "apparmor") != 0 ||
 	    root_entries[0].mode != S_IFDIR) {
-		AA_ERROR("%s: root entry 0 is not SECFS_AA/dir\n",
+		AA_ERROR("%s: root entry 0 is not apparmor/dir\n",
 			__FUNCTION__);
 		goto error;
 	}
@@ -319,7 +288,7 @@ static int populate_apparmorfs(struct de
 	parent_index = 0;
 	depth = 1;
 
-	for (i = 1; i < num_entries; i++) {
+	for (i = 1; i < ARRAY_SIZE(root_entries); i++) {
 		root_entries[i].parent_index = parent_index;
 
 		if (root_entries[i].name &&
@@ -361,7 +330,7 @@ static int populate_apparmorfs(struct de
 
 
 	/* 4. create remaining nodes */
-	for (i = 1; i < num_entries; i++) {
+	for (i = 1; i < ARRAY_SIZE(root_entries); i++) {
 		struct dentry *parent;
 		void *data = NULL;
 		struct file_operations *fops = NULL;
@@ -408,12 +377,12 @@ int create_apparmorfs(void)
 {
 	int error = 0;
 
-	if (AA_FS_DENTRY) {
+	if (root_entries[0].dentry) {
 		error = -EEXIST;
 		AA_ERROR("%s: AppArmor securityfs already exists\n",
 			__FUNCTION__);
 	} else {
-		error = populate_apparmorfs(aa_fs_dentry);
+		error = populate_apparmorfs();
 		if (error != 0) {
 			AA_ERROR("%s: Error populating AppArmor securityfs\n",
 				__FUNCTION__);
@@ -425,6 +394,6 @@ int create_apparmorfs(void)
 
 void destroy_apparmorfs(void)
 {
-	if (AA_FS_DENTRY)
+	if (root_entries[0].dentry)
 		clear_apparmorfs();
 }
Index: linux-2.6-apparmor/security/apparmor/main.c
===================================================================
--- linux-2.6-apparmor.orig/security/apparmor/main.c
+++ linux-2.6-apparmor/security/apparmor/main.c
@@ -930,7 +930,7 @@ repeat:
 	if (IS_ERR(new_profile))
 		goto cleanup;
 
-	old_profile = aa_replace_profile(current, new_profile, 0);
+	old_profile = __aa_replace_profile(current, new_profile, 0);
 	if (IS_ERR(old_profile)) {
 		aa_put_profile(new_profile);
 		aa_put_profile(profile);
@@ -1189,11 +1189,11 @@ out:
 }
 
 /**
- * aa_replace_profile - replace a task's profile
+ * __aa_replace_profile - replace a task's profile
  */
-struct aa_profile *aa_replace_profile(struct task_struct *task,
-				      struct aa_profile *profile,
-				      u32 hat_magic)
+struct aa_profile *__aa_replace_profile(struct task_struct *task,
+					struct aa_profile *profile,
+					u32 hat_magic)
 {
 	struct aa_task_context *cxt, *new_cxt = NULL;
 	struct aa_profile *old_profile = NULL;
Index: linux-2.6-apparmor/security/apparmor/module_interface.c
===================================================================
--- linux-2.6-apparmor.orig/security/apparmor/module_interface.c
+++ linux-2.6-apparmor/security/apparmor/module_interface.c
@@ -356,7 +356,7 @@ static int aa_verify_header(struct aa_ex
  * @data: serialized data stream
  * @size: size of the serialized data stream
  */
-ssize_t aa_file_prof_add(void *data, size_t size)
+ssize_t aa_add_profile(void *data, size_t size)
 {
 	struct aa_profile *profile = NULL;
 	struct aa_ext e = {
@@ -437,7 +437,7 @@ static inline void task_replace(struct t
  * by any aa_task_context.  If the profile does not exist on the profile list
  * it is added.  Return %0 or error.
  */
-ssize_t aa_file_prof_replace(void *udata, size_t size)
+ssize_t aa_replace_profile(void *udata, size_t size)
 {
 	struct aa_profile *old_profile, *new_profile;
 	struct aa_task_context *new_cxt;
@@ -509,7 +509,7 @@ out:
  * remove a profile from the profile list and all aa_task_context references
  * to said profile.
  */
-ssize_t aa_file_prof_remove(const char *name, size_t size)
+ssize_t aa_remove_profile(const char *name, size_t size)
 {
 	struct aa_profile *profile;
 
Index: linux-2.6-apparmor/security/apparmor/procattr.c
===================================================================
--- linux-2.6-apparmor.orig/security/apparmor/procattr.c
+++ linux-2.6-apparmor/security/apparmor/procattr.c
@@ -105,7 +105,7 @@ repeat:
 		}
 	}
 
-	old_profile = aa_replace_profile(task, new_profile, 0);
+	old_profile = __aa_replace_profile(task, new_profile, 0);
 	if (IS_ERR(old_profile)) {
 		int error;
 
