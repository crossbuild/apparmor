Index: linux-2.6/security/apparmor/apparmor.h
===================================================================
--- linux-2.6.orig/security/apparmor/apparmor.h
+++ linux-2.6/security/apparmor/apparmor.h
@@ -45,14 +45,14 @@ extern int apparmor_logsyscall;
  * which is not related to profile accesses.
  */
 
-#define AA_DEBUG(fmt, args...)						\
+#define AADEBUG(fmt, args...)						\
 	do {								\
 		if (apparmor_debug)					\
 			printk(KERN_DEBUG "AppArmor: " fmt, ##args);	\
 	} while (0)
-#define AA_INFO(fmt, args...)	printk(KERN_INFO "AppArmor: " fmt, ##args)
-#define AA_WARN(fmt, args...)	printk(KERN_WARNING "AppArmor: " fmt, ##args)
-#define AA_ERROR(fmt, args...)	printk(KERN_ERR "AppArmor: " fmt, ##args)
+#define AAINFO(fmt, args...)	printk(KERN_INFO "AppArmor: " fmt, ##args)
+#define AAWARN(fmt, args...)	printk(KERN_WARNING "AppArmor: " fmt, ##args)
+#define AAERROR(fmt, args...)	printk(KERN_ERR "AppArmor: " fmt, ##args)
 
 /* basic AppArmor data structures */
 
@@ -62,13 +62,13 @@ struct flagval {
 	int audit;
 };
 
-#define AA_MEDIATE_FS		(void*)0x00000001
-#define AA_SECURE_EXEC_NEEDED 	0x00000001
+#define AAMEDIATE_FS		(void*)0x00000001
+#define AASECURE_EXEC_NEEDED 	0x00000001
 
-#define AA_EXEC_MODIFIER_MASK(mask) ((mask) & AA_EXEC_MODIFIERS)
-#define AA_EXEC_MASK(mask) ((mask) & (AA_EXEC_MODIFIERS | AA_EXEC_UNSAFE))
+#define AAEXEC_MODIFIER_MASK(mask) ((mask) & AAEXEC_MODIFIERS)
+#define AAEXEC_MASK(mask) ((mask) & (AAEXEC_MODIFIERS | AAEXEC_UNSAFE))
 
-/* struct aa_profile - basic confinement data
+/* struct aaprofile - basic confinement data
  * @parent: non refcounted pointer to parent profile
  * @name: the profiles name
  * @file_rules: dfa containing the profiles file rules
@@ -85,16 +85,16 @@ struct flagval {
  * has a name and potentially a list of profile entries. The profiles are
  * connected in a list
  */
-struct aa_profile {
-	struct aa_profile *parent;
+struct aaprofile {
+	struct aaprofile *parent;
 	char *name;
 
-	struct aa_dfa *file_rules;
+	struct aadfa *file_rules;
 
 	struct list_head list;
 	struct list_head sub;
 	struct flagval flags;
-	struct aa_profile *null_profile;
+	struct aaprofile *null_profile;
 	int isstale;
 
 	kernel_cap_t capabilities;
@@ -118,28 +118,28 @@ struct aa_profile {
  * of this structure/concept (changehat reducing a task into a sub-domain).
  */
 struct subdomain {
-	struct aa_profile *active;	/* The current active profile */
+	struct aaprofile *active;	/* The current active profile */
 	u32 hat_magic;			/* used with change_hat */
 	struct list_head list;		/* list of subdomains */
 	struct task_struct *task;
 };
 
-typedef int (*aa_iter) (struct subdomain *, void *);
+typedef int (*aaiter) (struct subdomain *, void *);
 
-#define AA_SUBDOMAIN(sec)	((struct subdomain*)(sec))
-#define AA_PROFILE(sec)		((struct aaprofile*)(sec))
+#define AASUBDOMAIN(sec)	((struct subdomain*)(sec))
+#define AAPROFILE(sec)		((struct aaprofile*)(sec))
 
 /* Lock protecting access to 'struct subdomain' accesses */
 extern spinlock_t sd_lock;
 
-extern struct aa_profile *null_complain_profile;
+extern struct aaprofile *null_complain_profile;
 
-/* aa_audit - AppArmor auditing structure
- * Structure is populated by access control code and passed to aa_audit which
+/* aaaudit - AppArmor auditing structure
+ * Structure is populated by access control code and passed to aaaudit which
  * provides for a single point of logging.
  */
 
-struct aa_audit {
+struct aaaudit {
 	unsigned short type, flags;
 	unsigned int result;
 	gfp_t gfp_mask;
@@ -158,19 +158,19 @@ struct aa_audit {
 };
 
 /* audit types */
-#define AA_AUDITTYPE_FILE	1
-#define AA_AUDITTYPE_DIR	2
-#define AA_AUDITTYPE_ATTR	3
-#define AA_AUDITTYPE_XATTR	4
-#define AA_AUDITTYPE_LINK	5
-#define AA_AUDITTYPE_CAP	6
-#define AA_AUDITTYPE_MSG	7
-#define AA_AUDITTYPE_SYSCALL	8
-#define AA_AUDITTYPE__END	9
+#define AAAUDITTYPE_FILE	1
+#define AAAUDITTYPE_DIR	2
+#define AAAUDITTYPE_ATTR	3
+#define AAAUDITTYPE_XATTR	4
+#define AAAUDITTYPE_LINK	5
+#define AAAUDITTYPE_CAP	6
+#define AAAUDITTYPE_MSG	7
+#define AAAUDITTYPE_SYSCALL	8
+#define AAAUDITTYPE__END	9
 
 /* audit flags */
-#define AA_AUDITFLAG_AUDITSS_SYSCALL 1 /* log syscall context */
-#define AA_AUDITFLAG_LOGERR	     2 /* log operations that failed due to
+#define AAAUDITFLAG_AUDITSS_SYSCALL 1 /* log syscall context */
+#define AAAUDITFLAG_LOGERR	     2 /* log operations that failed due to
 					   non permission errors  */
 
 #define HINT_UNKNOWN_HAT "unknown_hat"
@@ -180,7 +180,7 @@ struct aa_audit {
 
 #define LOG_HINT(p, gfp, hint, fmt, args...) \
 	do {\
-		aa_audit_message(p, gfp, 0, \
+		aaaudit_message(p, gfp, 0, \
 			"LOGPROF-HINT " hint " " fmt, ##args);\
 	} while(0)
 
@@ -190,59 +190,59 @@ struct aa_audit {
 /* main.c */
 extern int alloc_null_complain_profile(void);
 extern void free_null_complain_profile(void);
-extern int attach_nullprofile(struct aa_profile *profile);
-extern int aa_audit_message(struct aa_profile *active, gfp_t gfp, int,
+extern int attach_nullprofile(struct aaprofile *profile);
+extern int aaaudit_message(struct aaprofile *active, gfp_t gfp, int,
 			    const char *, ...);
-extern int aa_audit_syscallreject(struct aa_profile *active, gfp_t gfp,
+extern int aaaudit_syscallreject(struct aaprofile *active, gfp_t gfp,
 				  const char *);
-extern int aa_audit(struct aa_profile *active, const struct aa_audit *);
-extern char *aa_get_name(struct dentry *dentry, struct vfsmount *mnt);
+extern int aaaudit(struct aaprofile *active, const struct aaaudit *);
+extern char *aaget_name(struct dentry *dentry, struct vfsmount *mnt);
 
-extern int aa_attr(struct aa_profile *active, struct dentry *dentry,
+extern int aaattr(struct aaprofile *active, struct dentry *dentry,
 		   struct vfsmount *mnt, struct iattr *iattr);
-extern int aa_perm_xattr(struct aa_profile *active, struct dentry *dentry,
+extern int aaperm_xattr(struct aaprofile *active, struct dentry *dentry,
 			 struct vfsmount *mnt, const char *operation,
 			 const char *xattr_xattr, int mask);
-extern int aa_capability(struct aa_profile *active, int cap);
-extern int aa_perm(struct aa_profile *active, struct dentry *dentry,
+extern int aacapability(struct aaprofile *active, int cap);
+extern int aaperm(struct aaprofile *active, struct dentry *dentry,
 		   struct vfsmount *mnt, int mask);
-extern int aa_perm_dir(struct aa_profile *active, struct dentry *dentry,
+extern int aaperm_dir(struct aaprofile *active, struct dentry *dentry,
 		       struct vfsmount *mnt, const char *operation, int mask);
-extern int aa_link(struct aa_profile *active,
+extern int aalink(struct aaprofile *active,
 		   struct dentry *link, struct vfsmount *link_mnt,
 		   struct dentry *target, struct vfsmount *target_mnt);
-extern int aa_fork(struct task_struct *p);
-extern int aa_register(struct linux_binprm *bprm);
-extern void aa_release(struct task_struct *p);
-extern int aa_change_hat(const char *id, u32 hat_magic);
-extern int aa_associate_filp(struct file *filp);
+extern int aafork(struct task_struct *p);
+extern int aaregister(struct linux_binprm *bprm);
+extern void aarelease(struct task_struct *p);
+extern int aachange_hat(const char *id, u32 hat_magic);
+extern int aaassociate_filp(struct file *filp);
 
 /* list.c */
-extern struct aa_profile *aa_profilelist_find(const char *name);
-extern int aa_profilelist_add(struct aa_profile *profile);
-extern struct aa_profile *aa_profilelist_remove(const char *name);
-extern void aa_profilelist_release(void);
-extern struct aa_profile *aa_profilelist_replace(struct aa_profile *profile);
-extern void aa_profile_dump(struct aa_profile *);
-extern void aa_profilelist_dump(void);
-extern void aa_subdomainlist_add(struct subdomain *);
-extern void aa_subdomainlist_remove(struct subdomain *);
-extern void aa_subdomainlist_iterate(aa_iter, void *);
-extern void aa_subdomainlist_iterateremove(aa_iter, void *);
-extern void aa_subdomainlist_release(void);
+extern struct aaprofile *aaprofilelist_find(const char *name);
+extern int aaprofilelist_add(struct aaprofile *profile);
+extern struct aaprofile *aaprofilelist_remove(const char *name);
+extern void aaprofilelist_release(void);
+extern struct aaprofile *aaprofilelist_replace(struct aaprofile *profile);
+extern void aaprofile_dump(struct aaprofile *);
+extern void aaprofilelist_dump(void);
+extern void aasubdomainlist_add(struct subdomain *);
+extern void aasubdomainlist_remove(struct subdomain *);
+extern void aasubdomainlist_iterate(aaiter, void *);
+extern void aasubdomainlist_iterateremove(aaiter, void *);
+extern void aasubdomainlist_release(void);
 
 /* module_interface.c */
-extern ssize_t aa_file_prof_add(void *, size_t);
-extern ssize_t aa_file_prof_repl(void *, size_t);
-extern ssize_t aa_file_prof_remove(const char *, size_t);
-extern void free_aa_profile(struct aa_profile *profile);
-extern void free_aa_profile_kref(struct kref *kref);
+extern ssize_t aafile_prof_add(void *, size_t);
+extern ssize_t aafile_prof_repl(void *, size_t);
+extern ssize_t aafile_prof_remove(const char *, size_t);
+extern void free_aaprofile(struct aaprofile *profile);
+extern void free_aaprofile_kref(struct kref *kref);
 
 /* procattr.c */
-extern size_t aa_getprocattr(struct aa_profile *active, char *str,
+extern size_t aagetprocattr(struct aaprofile *active, char *str,
 			     size_t size);
-extern int aa_setprocattr_changehat(char *hatinfo, size_t infosize);
-extern int aa_setprocattr_setprofile(struct task_struct *p, char *profilename,
+extern int aasetprocattr_changehat(char *hatinfo, size_t infosize);
+extern int aasetprocattr_setprofile(struct task_struct *p, char *profilename,
 				     size_t profilesize);
 
 /* apparmorfs.c */
@@ -253,11 +253,11 @@ extern void destroy_apparmorfs(void);
 extern const char *capability_to_name(unsigned int cap);
 
 /* match.c */
-struct aa_dfa *aa_match_alloc(void);
-void aa_match_free(struct aa_dfa *dfa);
-int unpack_dfa(struct aa_dfa *dfa, void *blob, size_t size);
-int verify_dfa(struct aa_dfa *dfa);
-const char *aa_match_features(void);
-unsigned int aa_match(struct aa_dfa *dfa, const char *pathname);
+struct aadfa *aamatch_alloc(void);
+void aamatch_free(struct aadfa *dfa);
+int unpack_dfa(struct aadfa *dfa, void *blob, size_t size);
+int verify_dfa(struct aadfa *dfa);
+const char *aamatch_features(void);
+unsigned int aamatch(struct aadfa *dfa, const char *pathname);
 
 #endif				/* __APPARMOR_H */
Index: linux-2.6/security/apparmor/apparmorfs.c
===================================================================
--- linux-2.6.orig/security/apparmor/apparmorfs.c
+++ linux-2.6/security/apparmor/apparmorfs.c
@@ -19,56 +19,56 @@
 #include "inline.h"
 
 #define SECFS_AA "apparmor"
-static struct dentry *aa_fs_dentry = NULL;
+static struct dentry *aafs_dentry = NULL;
 
 /* profile */
 extern struct seq_operations apparmorfs_profiles_op;
-static int aa_prof_open(struct inode *inode, struct file *file);
-static int aa_prof_release(struct inode *inode, struct file *file);
+static int aaprof_open(struct inode *inode, struct file *file);
+static int aaprof_release(struct inode *inode, struct file *file);
 
 static struct file_operations apparmorfs_profiles_fops = {
-	.open =		aa_prof_open,
+	.open =		aaprof_open,
 	.read =		seq_read,
 	.llseek =	seq_lseek,
-	.release =	aa_prof_release,
+	.release =	aaprof_release,
 };
 
 /* matching */
-static ssize_t aa_matching_read(struct file *file, char __user *buf,
+static ssize_t aamatching_read(struct file *file, char __user *buf,
 			       size_t size, loff_t *ppos);
 
 static struct file_operations apparmorfs_matching_fops = {
-	.read = 	aa_matching_read,
+	.read = 	aamatching_read,
 };
 
 
 /* interface */
-static ssize_t aa_profile_load(struct file *f, const char __user *buf,
+static ssize_t aaprofile_load(struct file *f, const char __user *buf,
 			       size_t size, loff_t *pos);
-static ssize_t aa_profile_replace(struct file *f, const char __user *buf,
+static ssize_t aaprofile_replace(struct file *f, const char __user *buf,
 				  size_t size, loff_t *pos);
-static ssize_t aa_profile_remove(struct file *f, const char __user *buf,
+static ssize_t aaprofile_remove(struct file *f, const char __user *buf,
 				 size_t size, loff_t *pos);
 
 static struct file_operations apparmorfs_profile_load = {
-	.write = aa_profile_load
+	.write = aaprofile_load
 };
 
 static struct file_operations apparmorfs_profile_replace = {
-	.write = aa_profile_replace
+	.write = aaprofile_replace
 };
 
 static struct file_operations apparmorfs_profile_remove = {
-	.write = aa_profile_remove
+	.write = aaprofile_remove
 };
 
 
 /* control */
-static u64 aa_control_get(void *data);
-static void aa_control_set(void *data, u64 val);
+static u64 aacontrol_get(void *data);
+static void aacontrol_set(void *data, u64 val);
 
-DEFINE_SIMPLE_ATTRIBUTE(apparmorfs_control_fops, aa_control_get,
-			aa_control_set, "%lld\n");
+DEFINE_SIMPLE_ATTRIBUTE(apparmorfs_control_fops, aacontrol_get,
+			aacontrol_set, "%lld\n");
 
 
 
@@ -120,38 +120,38 @@ static struct root_entry {
 	{NULL,       	S_IFDIR, 0}
 };
 
-#define AA_FS_DENTRY root_entries[0].dentry
+#define AAFS_DENTRY root_entries[0].dentry
 
 static const unsigned int num_entries =
 	sizeof(root_entries) / sizeof(struct root_entry);
 
 
 
-static int aa_prof_open(struct inode *inode, struct file *file)
+static int aaprof_open(struct inode *inode, struct file *file)
 {
 	return seq_open(file, &apparmorfs_profiles_op);
 }
 
 
-static int aa_prof_release(struct inode *inode, struct file *file)
+static int aaprof_release(struct inode *inode, struct file *file)
 {
 	return seq_release(inode, file);
 }
 
-static ssize_t aa_matching_read(struct file *file, char __user *buf,
+static ssize_t aamatching_read(struct file *file, char __user *buf,
 			       size_t size, loff_t *ppos)
 {
-	const char *matching = aa_match_features();
+	const char *matching = aamatch_features();
 
 	return simple_read_from_buffer(buf, size, ppos, matching,
 				       strlen(matching));
 }
 
-static char *aa_simple_write_to_buffer(const char __user *userbuf,
+static char *aasimple_write_to_buffer(const char __user *userbuf,
 				       size_t alloc_size, size_t copy_size,
 				       loff_t *pos, const char *msg)
 {
-	struct aa_profile *active;
+	struct aaprofile *active;
 	char *data;
 
 	if (*pos != 0) {
@@ -167,7 +167,7 @@ static char *aa_simple_write_to_buffer(c
 	rcu_read_lock();
 	active = get_activeptr_rcu();
 	if (active) {
-		AA_WARN("REJECTING access to profile %s (%s(%d) "
+		AAWARN("REJECTING access to profile %s (%s(%d) "
 			"profile %s active %s)\n",
 			msg, current->comm, current->pid,
 			BASE_PROFILE(active)->name, active->name);
@@ -193,16 +193,16 @@ out:
 	return data;
 }
 
-static ssize_t aa_profile_load(struct file *f, const char __user *buf,
+static ssize_t aaprofile_load(struct file *f, const char __user *buf,
 			       size_t size, loff_t *pos)
 {
 	char *data;
 	ssize_t error;
 
-	data = aa_simple_write_to_buffer(buf, size, size, pos, "load");
+	data = aasimple_write_to_buffer(buf, size, size, pos, "load");
 
 	if (!IS_ERR(data)) {
-		error = aa_file_prof_add(data, size);
+		error = aafile_prof_add(data, size);
 		vfree(data);
 	} else {
 		error = PTR_ERR(data);
@@ -211,16 +211,16 @@ static ssize_t aa_profile_load(struct fi
 	return error;
 }
 
-static ssize_t aa_profile_replace(struct file *f, const char __user *buf,
+static ssize_t aaprofile_replace(struct file *f, const char __user *buf,
 				  size_t size, loff_t *pos)
 {
 	char *data;
 	ssize_t error;
 
-	data = aa_simple_write_to_buffer(buf, size, size, pos, "replacement");
+	data = aasimple_write_to_buffer(buf, size, size, pos, "replacement");
 
 	if (!IS_ERR(data)) {
-		error = aa_file_prof_repl(data, size);
+		error = aafile_prof_repl(data, size);
 		vfree(data);
 	} else {
 		error = PTR_ERR(data);
@@ -229,20 +229,20 @@ static ssize_t aa_profile_replace(struct
 	return error;
 }
 
-static ssize_t aa_profile_remove(struct file *f, const char __user *buf,
+static ssize_t aaprofile_remove(struct file *f, const char __user *buf,
 				  size_t size, loff_t *pos)
 {
 	char *data;
 	ssize_t error;
 
-	/* aa_file_prof_remove needs a null terminated string so 1 extra
+	/* aafile_prof_remove needs a null terminated string so 1 extra
 	 * byte is allocated and null the copied data is then null terminated
 	 */
-	data = aa_simple_write_to_buffer(buf, size+1, size, pos, "removal");
+	data = aasimple_write_to_buffer(buf, size+1, size, pos, "removal");
 
 	if (!IS_ERR(data)) {
 		data[size] = 0;
-		error = aa_file_prof_remove(data, size);
+		error = aafile_prof_remove(data, size);
 		vfree(data);
 	} else {
 		error = PTR_ERR(data);
@@ -251,12 +251,12 @@ static ssize_t aa_profile_remove(struct 
 	return error;
 }
 
-static u64 aa_control_get(void *data)
+static u64 aacontrol_get(void *data)
 {
 	return *(int *)data;
 }
 
-static void aa_control_set(void *data, u64 val)
+static void aacontrol_set(void *data, u64 val)
 {
 	if (val > 1)
 		val = 1;
@@ -285,7 +285,7 @@ static void clear_apparmorfs(void)
 		if (root_entries[index].dentry) {
 			securityfs_remove(root_entries[index].dentry);
 
-			AA_DEBUG("%s: deleted apparmorfs entry name=%s "
+			AADEBUG("%s: deleted apparmorfs entry name=%s "
 				 "dentry=%p\n",
 				__FUNCTION__,
 				root_entries[index].name,
@@ -311,7 +311,7 @@ static int populate_apparmorfs(struct de
 	    !root_entries[0].name ||
 	    strcmp(root_entries[0].name, SECFS_AA) != 0 ||
 	    root_entries[0].mode != S_IFDIR) {
-		AA_ERROR("%s: root entry 0 is not SECFS_AA/dir\n",
+		AAERROR("%s: root entry 0 is not SECFS_AA/dir\n",
 			__FUNCTION__);
 		goto error;
 	}
@@ -329,7 +329,7 @@ static int populate_apparmorfs(struct de
 			parent_index = i;
 		} else if (!root_entries[i].name) {
 			if (root_entries[i].mode != S_IFDIR || depth == 0) {
-				AA_ERROR("%s: root_entry %d invalid (%u %d)",
+				AAERROR("%s: root_entry %d invalid (%u %d)",
 					 __FUNCTION__, i,
 					 root_entries[i].mode,
 					 root_entries[i].parent_index);
@@ -342,7 +342,7 @@ static int populate_apparmorfs(struct de
 	}
 
 	if (depth != 0) {
-		AA_ERROR("%s: root_entry table not correctly terminated\n",
+		AAERROR("%s: root_entry table not correctly terminated\n",
 			__FUNCTION__);
 		goto error;
 	}
@@ -357,7 +357,7 @@ static int populate_apparmorfs(struct de
 	if (IS_ERR(root_entries[0].dentry))
 		goto error;
 	else
-		AA_DEBUG("%s: created securityfs/apparmor [dentry=%p]\n",
+		AADEBUG("%s: created securityfs/apparmor [dentry=%p]\n",
 			__FUNCTION__, root_entries[0].dentry);
 
 
@@ -389,7 +389,7 @@ static int populate_apparmorfs(struct de
 		if (IS_ERR(root_entries[i].dentry))
 			goto cleanup_error;
 
-		AA_DEBUG("%s: added apparmorfs entry "
+		AADEBUG("%s: added apparmorfs entry "
 			 "name=%s mode=%x dentry=%p [parent %p]\n",
 			__FUNCTION__, root_entries[i].name,
 			root_entries[i].mode|root_entries[i].access,
@@ -409,14 +409,14 @@ int create_apparmorfs(void)
 {
 	int error = 0;
 
-	if (AA_FS_DENTRY) {
+	if (AAFS_DENTRY) {
 		error = -EEXIST;
-		AA_ERROR("%s: AppArmor securityfs already exists\n",
+		AAERROR("%s: AppArmor securityfs already exists\n",
 			__FUNCTION__);
 	} else {
-		error = populate_apparmorfs(aa_fs_dentry);
+		error = populate_apparmorfs(aafs_dentry);
 		if (error != 0) {
-			AA_ERROR("%s: Error populating AppArmor securityfs\n",
+			AAERROR("%s: Error populating AppArmor securityfs\n",
 				__FUNCTION__);
 		}
 	}
@@ -426,6 +426,6 @@ int create_apparmorfs(void)
 
 void destroy_apparmorfs(void)
 {
-	if (AA_FS_DENTRY)
+	if (AAFS_DENTRY)
 		clear_apparmorfs();
 }
Index: linux-2.6/security/apparmor/inline.h
===================================================================
--- linux-2.6.orig/security/apparmor/inline.h
+++ linux-2.6/security/apparmor/inline.h
@@ -12,42 +12,42 @@
 
 #include <linux/sched.h>
 
-static inline int __aa_is_confined(struct subdomain *sd)
+static inline int __aais_confined(struct subdomain *sd)
 {
 	return (sd && sd->active);
 }
 
 /**
- *  aa_is_confined
+ *  aais_confined
  *  Determine whether current task contains a valid profile (confined).
  *  Return %1 if confined, %0 otherwise.
  */
-static inline int aa_is_confined(void)
+static inline int aais_confined(void)
 {
-	struct subdomain *sd = AA_SUBDOMAIN(current->security);
-	return __aa_is_confined(sd);
+	struct subdomain *sd = AASUBDOMAIN(current->security);
+	return __aais_confined(sd);
 }
 
-static inline int __aa_sub_defined(struct subdomain *sd)
+static inline int __aasub_defined(struct subdomain *sd)
 {
-    return __aa_is_confined(sd) && !list_empty(&BASE_PROFILE(sd->active)->sub);
+    return __aais_confined(sd) && !list_empty(&BASE_PROFILE(sd->active)->sub);
 }
 
 /**
- * aa_sub_defined - check to see if current task has any subprofiles
+ * aasub_defined - check to see if current task has any subprofiles
  * Return 1 if true, 0 otherwise
  */
-static inline int aa_sub_defined(void)
+static inline int aasub_defined(void)
 {
-	struct subdomain *sd = AA_SUBDOMAIN(current->security);
-	return __aa_sub_defined(sd);
+	struct subdomain *sd = AASUBDOMAIN(current->security);
+	return __aasub_defined(sd);
 }
 
 /**
- * get_aa_profile - increment refcount on profile @p
+ * get_aaprofile - increment refcount on profile @p
  * @p: profile
  */
-static inline struct aa_profile *get_aa_profile(struct aa_profile *p)
+static inline struct aaprofile *get_aaprofile(struct aaprofile *p)
 {
 	if (p)
 		kref_get(&(BASE_PROFILE(p)->count));
@@ -56,13 +56,13 @@ static inline struct aa_profile *get_aa_
 }
 
 /**
- * put_aa_profile - decrement refcount on profile @p
+ * put_aaprofile - decrement refcount on profile @p
  * @p: profile
  */
-static inline void put_aa_profile(struct aa_profile *p)
+static inline void put_aaprofile(struct aaprofile *p)
 {
 	if (p)
-		kref_put(&BASE_PROFILE(p)->count, free_aa_profile_kref);
+		kref_put(&BASE_PROFILE(p)->count, free_aaprofile_kref);
 }
 
 /**
@@ -71,13 +71,13 @@ static inline void put_aa_profile(struct
  *
  * Requires rcu_read_lock is held
  */
-static inline struct aa_profile *get_task_activeptr_rcu(struct task_struct *tsk)
+static inline struct aaprofile *get_task_activeptr_rcu(struct task_struct *tsk)
 {
-	struct subdomain *sd = AA_SUBDOMAIN(tsk->security);
-	struct aa_profile *active = NULL;
+	struct subdomain *sd = AASUBDOMAIN(tsk->security);
+	struct aaprofile *active = NULL;
 
 	if (sd)
-		active = (struct aa_profile *) rcu_dereference(sd->active);
+		active = (struct aaprofile *) rcu_dereference(sd->active);
 
 	return active;
 }
@@ -86,66 +86,66 @@ static inline struct aa_profile *get_tas
  * get_activeptr_rcu - get pointer to current task's active profile
  * Requires rcu_read_lock is held
  */
-static inline struct aa_profile *get_activeptr_rcu(void)
+static inline struct aaprofile *get_activeptr_rcu(void)
 {
 	return get_task_activeptr_rcu(current);
 }
 
 /**
- * get_task_active_aa_profile - get a reference to tsk's active profile.
+ * get_task_active_aaprofile - get a reference to tsk's active profile.
  * @tsk: the task to get the active profile reference for
  */
-static inline struct aa_profile *get_task_active_aa_profile(struct task_struct *tsk)
+static inline struct aaprofile *get_task_active_aaprofile(struct task_struct *tsk)
 {
-	struct aa_profile *active;
+	struct aaprofile *active;
 
 	rcu_read_lock();
-	active = get_aa_profile(get_task_activeptr_rcu(tsk));
+	active = get_aaprofile(get_task_activeptr_rcu(tsk));
 	rcu_read_unlock();
 
 	return active;
 }
 
 /**
- * get_active_aa_profile - get a reference to the current tasks active profile
+ * get_active_aaprofile - get a reference to the current tasks active profile
  */
-static inline struct aa_profile *get_active_aa_profile(void)
+static inline struct aaprofile *get_active_aaprofile(void)
 {
-	return get_task_active_aa_profile(current);
+	return get_task_active_aaprofile(current);
 }
 
 /**
- * aa_switch - change subdomain to use a new profile
+ * aaswitch - change subdomain to use a new profile
  * @sd: subdomain to switch the active profile on
  * @newactive: new active profile
  *
- * aa_switch handles the changing of a subdomain's active profile.  The
+ * aaswitch handles the changing of a subdomain's active profile.  The
  * sd_lock must be held to ensure consistency against other writers.
- * Some write paths (ex. aa_register) require sd->active not to change
+ * Some write paths (ex. aaregister) require sd->active not to change
  * over several operations, so the calling function is responsible
  * for grabing the sd_lock to meet its consistency constraints before
- * calling aa_switch
+ * calling aaswitch
  */
-static inline void aa_switch(struct subdomain *sd, struct aa_profile *newactive)
+static inline void aaswitch(struct subdomain *sd, struct aaprofile *newactive)
 {
-	struct aa_profile *oldactive = sd->active;
+	struct aaprofile *oldactive = sd->active;
 
 	/* noop if NULL */
-	rcu_assign_pointer(sd->active, get_aa_profile(newactive));
-	put_aa_profile(oldactive);
+	rcu_assign_pointer(sd->active, get_aaprofile(newactive));
+	put_aaprofile(oldactive);
 }
 
 /**
- * aa_switch_unconfined - change subdomain to be unconfined (no profile)
+ * aaswitch_unconfined - change subdomain to be unconfined (no profile)
  * @sd: subdomain to switch
  *
- * aa_switch_unconfined handles the removal of a subdomain's active profile.
+ * aaswitch_unconfined handles the removal of a subdomain's active profile.
  * The sd_lock must be held to ensure consistency against other writers.
- * Like aa_switch the sd_lock is used to maintain consistency.
+ * Like aaswitch the sd_lock is used to maintain consistency.
  */
-static inline void aa_switch_unconfined(struct subdomain *sd)
+static inline void aaswitch_unconfined(struct subdomain *sd)
 {
-	aa_switch(sd, NULL);
+	aaswitch(sd, NULL);
 
 	/* reset magic in case we were in a subhat before */
 	sd->hat_magic = 0;
@@ -171,7 +171,7 @@ static inline struct subdomain *alloc_su
 	/* any readers of the list must make sure that they can handle
 	 * case where sd->active is not yet set (null)
 	 */
-	aa_subdomainlist_add(sd);
+	aasubdomainlist_add(sd);
 
 out:
 	return sd;
@@ -183,21 +183,21 @@ out:
  */
 static inline void free_subdomain(struct subdomain *sd)
 {
-	aa_subdomainlist_remove(sd);
+	aasubdomainlist_remove(sd);
 	kfree(sd);
 }
 
 /**
- * alloc_aa_profile - Allocate, initialize and return a new zeroed profile.
+ * alloc_aaprofile - Allocate, initialize and return a new zeroed profile.
  * Returns NULL on failure.
  */
-static inline struct aa_profile *alloc_aa_profile(void)
+static inline struct aaprofile *alloc_aaprofile(void)
 {
-	struct aa_profile *profile;
+	struct aaprofile *profile;
 
-	profile = (struct aa_profile *)kzalloc(sizeof(struct aa_profile),
+	profile = (struct aaprofile *)kzalloc(sizeof(struct aaprofile),
 					      GFP_KERNEL);
-	AA_DEBUG("%s(%p)\n", __FUNCTION__, profile);
+	AADEBUG("%s(%p)\n", __FUNCTION__, profile);
 	if (profile) {
 		INIT_LIST_HEAD(&profile->list);
 		INIT_LIST_HEAD(&profile->sub);
@@ -208,40 +208,40 @@ static inline struct aa_profile *alloc_a
 }
 
 /**
- * aa_put_name
+ * aaput_name
  * @name: name to release.
  *
  * Release space (free_page) allocated to hold pathname
  * name may be NULL (checked for by free_page)
  */
-static inline void aa_put_name(const char *name)
+static inline void aaput_name(const char *name)
 {
 	free_page((unsigned long)name);
 }
 
-/** __aa_find_profile
+/** __aafind_profile
  * @name: name of profile to find
  * @head: list to search
  *
  * Return reference counted copy of profile. NULL if not found
  * Caller must hold any necessary locks
  */
-static inline struct aa_profile *__aa_find_profile(const char *name,
+static inline struct aaprofile *__aafind_profile(const char *name,
 						   struct list_head *head)
 {
-	struct aa_profile *p;
+	struct aaprofile *p;
 
 	if (!name || !head)
 		return NULL;
 
-	AA_DEBUG("%s: finding profile %s\n", __FUNCTION__, name);
+	AADEBUG("%s: finding profile %s\n", __FUNCTION__, name);
 	list_for_each_entry(p, head, list) {
 		if (!strcmp(p->name, name)) {
 			/* return refcounted object */
-			p = get_aa_profile(p);
+			p = get_aaprofile(p);
 			return p;
 		} else {
-			AA_DEBUG("%s: skipping %s\n", __FUNCTION__, p->name);
+			AADEBUG("%s: skipping %s\n", __FUNCTION__, p->name);
 		}
 	}
 	return NULL;
Index: linux-2.6/security/apparmor/list.c
===================================================================
--- linux-2.6.orig/security/apparmor/list.c
+++ linux-2.6/security/apparmor/list.c
@@ -22,45 +22,45 @@ static LIST_HEAD(subdomain_list);
 static rwlock_t subdomain_lock = RW_LOCK_UNLOCKED;
 
 /**
- * aa_profilelist_find
+ * aaprofilelist_find
  * @name: profile name (program name)
  *
  * Search the profile list for profile @name.  Return refcounted profile on
  * success, NULL on failure.
  */
-struct aa_profile *aa_profilelist_find(const char *name)
+struct aaprofile *aaprofilelist_find(const char *name)
 {
-	struct aa_profile *p = NULL;
+	struct aaprofile *p = NULL;
 	if (name) {
 		read_lock(&profile_lock);
-		p = __aa_find_profile(name, &profile_list);
+		p = __aafind_profile(name, &profile_list);
 		read_unlock(&profile_lock);
 	}
 	return p;
 }
 
 /**
- * aa_profilelist_add - add new profile to list
+ * aaprofilelist_add - add new profile to list
  * @profile: new profile to add to list
  *
  * NOTE: Caller must allocate necessary reference count that will be used
- * by the profile_list.  This is because profile allocation alloc_aa_profile()
+ * by the profile_list.  This is because profile allocation alloc_aaprofile()
  * returns an unreferenced object with a initial count of %1.
  *
  * Return %1 on success, %0 on failure (already exists)
  */
-int aa_profilelist_add(struct aa_profile *profile)
+int aaprofilelist_add(struct aaprofile *profile)
 {
-	struct aa_profile *old_profile;
+	struct aaprofile *old_profile;
 	int ret = 0;
 
 	if (!profile)
 		goto out;
 
 	write_lock(&profile_lock);
-	old_profile = __aa_find_profile(profile->name, &profile_list);
+	old_profile = __aafind_profile(profile->name, &profile_list);
 	if (old_profile) {
-		put_aa_profile(old_profile);
+		put_aaprofile(old_profile);
 		goto out;
 	}
 
@@ -72,17 +72,17 @@ int aa_profilelist_add(struct aa_profile
 }
 
 /**
- * aa_profilelist_remove - remove a profile from the list by name
+ * aaprofilelist_remove - remove a profile from the list by name
  * @name: name of profile to be removed
  *
  * If the profile exists remove profile from list and return its reference.
  * The reference count on profile is not decremented and should be decremented
  * when the profile is no longer needed
  */
-struct aa_profile *aa_profilelist_remove(const char *name)
+struct aaprofile *aaprofilelist_remove(const char *name)
 {
-	struct aa_profile *profile = NULL;
-	struct aa_profile *p, *tmp;
+	struct aaprofile *profile = NULL;
+	struct aaprofile *p, *tmp;
 
 	if (!name)
 		goto out;
@@ -104,29 +104,29 @@ out:
 }
 
 /**
- * aa_profilelist_replace - replace a profile on the list
+ * aaprofilelist_replace - replace a profile on the list
  * @profile: new profile
  *
  * Replace a profile on the profile list.  Find the old profile by name in
  * the list, and replace it with the new profile.   NOTE: Caller must allocate
- * necessary initial reference count for new profile as aa_profilelist_add().
+ * necessary initial reference count for new profile as aaprofilelist_add().
  *
  * This is an atomic list operation.  Returns the old profile (which is still
  * refcounted) if there was one, or NULL.
  */
-struct aa_profile *aa_profilelist_replace(struct aa_profile *profile)
+struct aaprofile *aaprofilelist_replace(struct aaprofile *profile)
 {
-	struct aa_profile *oldprofile;
+	struct aaprofile *oldprofile;
 
 	write_lock(&profile_lock);
-	oldprofile = __aa_find_profile(profile->name, &profile_list);
+	oldprofile = __aafind_profile(profile->name, &profile_list);
 	if (oldprofile) {
 		list_del_init(&oldprofile->list);
 		/* mark old profile as stale */
 		oldprofile->isstale = 1;
 
-		/* __aa_find_profile incremented count, so adjust down */
-		put_aa_profile(oldprofile);
+		/* __aafind_profile incremented count, so adjust down */
+		put_aaprofile(oldprofile);
 	}
 
 	list_add(&profile->list, &profile_list);
@@ -136,30 +136,30 @@ struct aa_profile *aa_profilelist_replac
 }
 
 /**
- * aa_profilelist_release - Remove all profiles from profile_list
+ * aaprofilelist_release - Remove all profiles from profile_list
  */
-void aa_profilelist_release(void)
+void aaprofilelist_release(void)
 {
-	struct aa_profile *p, *tmp;
+	struct aaprofile *p, *tmp;
 
 	write_lock(&profile_lock);
 	list_for_each_entry_safe(p, tmp, &profile_list, list) {
 		list_del_init(&p->list);
-		put_aa_profile(p);
+		put_aaprofile(p);
 	}
 	write_unlock(&profile_lock);
 }
 
 /**
- * aa_subdomainlist_add - Add subdomain to subdomain_list
+ * aasubdomainlist_add - Add subdomain to subdomain_list
  * @sd: new subdomain
  */
-void aa_subdomainlist_add(struct subdomain *sd)
+void aasubdomainlist_add(struct subdomain *sd)
 {
 	unsigned long flags;
 
 	if (!sd) {
-		AA_INFO("%s: bad subdomain\n", __FUNCTION__);
+		AAINFO("%s: bad subdomain\n", __FUNCTION__);
 		return;
 	}
 
@@ -172,10 +172,10 @@ void aa_subdomainlist_add(struct subdoma
 }
 
 /**
- * aa_subdomainlist_remove - Remove subdomain from subdomain_list
+ * aasubdomainlist_remove - Remove subdomain from subdomain_list
  * @sd: subdomain to be removed
  */
-void aa_subdomainlist_remove(struct subdomain *sd)
+void aasubdomainlist_remove(struct subdomain *sd)
 {
 	unsigned long flags;
 
@@ -187,14 +187,14 @@ void aa_subdomainlist_remove(struct subd
 }
 
 /**
- * aa_subdomainlist_iterate - iterate over the subdomain list applying @func
+ * aasubdomainlist_iterate - iterate over the subdomain list applying @func
  * @func: method to be called for each element
  * @cookie: user passed data
  *
  * Iterate over subdomain list applying @func, stop when @func returns
  * non zero
  */
-void aa_subdomainlist_iterate(aa_iter func, void *cookie)
+void aasubdomainlist_iterate(aaiter func, void *cookie)
 {
 	struct subdomain *node;
 	int ret = 0;
@@ -210,9 +210,9 @@ void aa_subdomainlist_iterate(aa_iter fu
 }
 
 /**
- * aa_subdomainlist_release - Remove all subdomains from subdomain_list
+ * aasubdomainlist_release - Remove all subdomains from subdomain_list
  */
-void aa_subdomainlist_release(void)
+void aasubdomainlist_release(void)
 {
 	struct subdomain *node, *tmp;
 	unsigned long flags;
@@ -229,7 +229,7 @@ void aa_subdomainlist_release(void)
  */
 static void *p_start(struct seq_file *f, loff_t *pos)
 {
-	struct aa_profile *node;
+	struct aaprofile *node;
 	loff_t l = *pos;
 
 	read_lock(&profile_lock);
@@ -241,10 +241,10 @@ static void *p_start(struct seq_file *f,
 
 static void *p_next(struct seq_file *f, void *p, loff_t *pos)
 {
-	struct list_head *lh = ((struct aa_profile *)p)->list.next;
+	struct list_head *lh = ((struct aaprofile *)p)->list.next;
 	(*pos)++;
 	return lh == &profile_list ?
-			NULL : list_entry(lh, struct aa_profile, list);
+			NULL : list_entry(lh, struct aaprofile, list);
 }
 
 static void p_stop(struct seq_file *f, void *v)
@@ -254,7 +254,7 @@ static void p_stop(struct seq_file *f, v
 
 static int seq_show_profile(struct seq_file *f, void *v)
 {
-	struct aa_profile *profile = (struct aa_profile *)v;
+	struct aaprofile *profile = (struct aaprofile *)v;
 	seq_printf(f, "%s (%s)\n", profile->name,
 		   PROFILE_COMPLAIN(profile) ? "complain" : "enforce");
 	return 0;
Index: linux-2.6/security/apparmor/main.c
===================================================================
--- linux-2.6.orig/security/apparmor/main.c
+++ linux-2.6/security/apparmor/main.c
@@ -28,20 +28,20 @@
  * can be associated to files which keep their reference even if apparmor is
  * unloaded
  */
-struct aa_profile *null_complain_profile;
+struct aaprofile *null_complain_profile;
 
 /***************************
  * Private utility functions
  **************************/
 
 /**
- * aa_taskattr_access
+ * aataskattr_access
  * @procrelname: name of file to check permission
  *
  * Determine if request is for write access to /proc/self/attr/current
  * This file is the usermode iterface for changing it's hat.
  */
-static inline int aa_taskattr_access(const char *procrelname)
+static inline int aataskattr_access(const char *procrelname)
 {
 	char buf[sizeof("/attr/current") + 10];
 	const int maxbuflen = sizeof(buf);
@@ -54,33 +54,33 @@ static inline int aa_taskattr_access(con
 }
 
 /**
- * aa_file_mode - get full mode for file entry from profile
+ * aafile_mode - get full mode for file entry from profile
  * @profile: profile
  * @name: filename
  */
-static inline int aa_file_mode(struct aa_profile *profile, const char *name)
+static inline int aafile_mode(struct aaprofile *profile, const char *name)
 {
 	int perms = 0;
 
-	AA_DEBUG("%s: %s\n", __FUNCTION__, name);
+	AADEBUG("%s: %s\n", __FUNCTION__, name);
 	if (!name) {
-		AA_DEBUG("%s: no name\n", __FUNCTION__);
+		AADEBUG("%s: no name\n", __FUNCTION__);
 		goto out;
 	}
 
 	if (!profile) {
-		AA_DEBUG("%s: no profile\n", __FUNCTION__);
+		AADEBUG("%s: no profile\n", __FUNCTION__);
 		goto out;
 	}
 
-	perms = aa_match(profile->file_rules, name);
+	perms = aamatch(profile->file_rules, name);
 
 out:
 	return perms;
 }
 
 /**
- * aa_filter_mask
+ * aafilter_mask
  * @mask: requested mask
  * @inode: potential directory inode
  *
@@ -91,7 +91,7 @@ out:
  *
  * Returned value of %0 indicates no need to perform a perm check.
  */
-static inline int aa_filter_mask(int mask, struct inode *inode)
+static inline int aafilter_mask(int mask, struct inode *inode)
 {
 	if (mask) {
 		int elim = MAY_APPEND;
@@ -105,7 +105,7 @@ static inline int aa_filter_mask(int mas
 	return mask;
 }
 
-static inline void aa_permerror2result(int perm_result, struct aa_audit *sa)
+static inline void aapermerror2result(int perm_result, struct aaaudit *sa)
 {
 	if (perm_result == 0) {	/* success */
 		sa->result = 1;
@@ -121,19 +121,19 @@ static inline void aa_permerror2result(i
  ************************/
 
 /**
- * aa_file_perm - calculate access mode for file
+ * aafile_perm - calculate access mode for file
  * @active: profile to check against
  * @name: name of file to calculate mode for
  * @mask: permission mask requested for file
  *
- * Search the aa_entry list in @active.
+ * Search the aaentry list in @active.
  * Search looking to verify all permissions passed in mask.
  * Perform the search by looking at the partitioned list of entries, one
  * partition per permission bit.
  *
  * Return %0 on success, else mask of non-allowed permissions
  */
-static int aa_file_perm(struct aa_profile *active, const char *name, int mask)
+static int aafile_perm(struct aaprofile *active, const char *name, int mask)
 {
 	int error = 0;
 	int perms;
@@ -141,21 +141,21 @@ static int aa_file_perm(struct aa_profil
 #define PROCPFX "/proc/"
 #define PROCLEN sizeof(PROCPFX) - 1
 
-	AA_DEBUG("%s: %s 0x%x\n", __FUNCTION__, name, mask);
+	AADEBUG("%s: %s 0x%x\n", __FUNCTION__, name, mask);
 
 	/* should not enter with other than R/W/M/X/L */
 	WARN_ON(mask &
-	       ~(AA_MAY_READ | AA_MAY_WRITE | AA_MAY_EXEC | AA_EXEC_MMAP |
-		 AA_MAY_LINK));
+	       ~(AAMAY_READ | AAMAY_WRITE | AAMAY_EXEC | AAEXEC_MMAP |
+		 AAMAY_LINK));
 
 	/* Special case access to /proc/self/attr/current
 	 * Currently we only allow access if opened O_WRONLY
 	 */
 	if (mask == MAY_WRITE && strncmp(PROCPFX, name, PROCLEN) == 0 &&
-	    aa_taskattr_access(name + PROCLEN))
+	    aataskattr_access(name + PROCLEN))
 		goto done;
 
-	perms = aa_match(active->file_rules, name);
+	perms = aamatch(active->file_rules, name);
 
 	/* return permissions not satisfied */
 	error = mask & ~perms;
@@ -165,7 +165,7 @@ done:
 }
 
 /**
- * aa_link_perm - test permission to link to a file
+ * aalink_perm - test permission to link to a file
  * @active: profile to check against
  * @link: name of link being created
  * @target: name of target to be linked to
@@ -174,18 +174,18 @@ done:
  * permission mode as @target.  At least @link must have the link bit enabled.
  * Return %0 on success, else -EPERM
  */
-static int aa_link_perm(struct aa_profile *active,
+static int aalink_perm(struct aaprofile *active,
 			const char *link, const char *target)
 {
 	int l_mode, t_mode, ret = -EPERM;
 
-	l_mode = aa_file_mode(active, link);
-	if (l_mode & AA_MAY_LINK) {
+	l_mode = aafile_mode(active, link);
+	if (l_mode & AAMAY_LINK) {
 		/* mask off link bit */
-		l_mode &= ~AA_MAY_LINK;
+		l_mode &= ~AAMAY_LINK;
 
-		t_mode = aa_file_mode(active, target);
-		t_mode &= ~AA_MAY_LINK;
+		t_mode = aafile_mode(active, target);
+		t_mode &= ~AAMAY_LINK;
 
 		if (l_mode == t_mode)
 			ret = 0;
@@ -194,25 +194,25 @@ static int aa_link_perm(struct aa_profil
 	return ret;
 }
 
-static int _aa_perm_vfsmount(struct aa_profile *active, struct dentry *dentry,
-                      struct vfsmount *mnt, struct aa_audit *sa, int mask)
+static int _aaperm_vfsmount(struct aaprofile *active, struct dentry *dentry,
+                      struct vfsmount *mnt, struct aaaudit *sa, int mask)
 {
 	int permerror, error;
 
-	sa->name = aa_get_name(dentry, mnt);
+	sa->name = aaget_name(dentry, mnt);
 
 	if (IS_ERR(sa->name)) {
 		permerror = PTR_ERR(sa->name);
 		sa->name = NULL;
 	} else {
-		permerror = aa_file_perm(active, sa->name, mask);
+		permerror = aafile_perm(active, sa->name, mask);
 	}
 
-	aa_permerror2result(permerror, sa);
+	aapermerror2result(permerror, sa);
 
-	error = aa_audit(active, sa);
+	error = aaaudit(active, sa);
 
-	aa_put_name(sa->name);
+	aaput_name(sa->name);
 
 	return error;
 }
@@ -227,12 +227,12 @@ static int _aa_perm_vfsmount(struct aa_p
  *
  * Return %0 (success) or error (-%ENOMEM)
  */
-int attach_nullprofile(struct aa_profile *profile)
+int attach_nullprofile(struct aaprofile *profile)
 {
-	struct aa_profile *hat = NULL;
+	struct aaprofile *hat = NULL;
 	char *hatname = NULL;
 
-	hat = alloc_aa_profile();
+	hat = alloc_aaprofile();
 	if (!hat)
 		goto fail;
 	if (profile->flags.complain)
@@ -252,7 +252,7 @@ int attach_nullprofile(struct aa_profile
 
 fail:
 	kfree(hatname);
-	free_aa_profile(hat);
+	free_aaprofile(hat);
 
 	return -ENOMEM;
 }
@@ -265,7 +265,7 @@ fail:
  */
 int alloc_null_complain_profile(void)
 {
-	null_complain_profile = alloc_aa_profile();
+	null_complain_profile = alloc_aaprofile();
 	if (!null_complain_profile)
 		goto fail;
 
@@ -282,8 +282,8 @@ int alloc_null_complain_profile(void)
 	return 0;
 
 fail:
-	/* free_aa_profile is safe for freeing partially constructed objects */
-	free_aa_profile(null_complain_profile);
+	/* free_aaprofile is safe for freeing partially constructed objects */
+	free_aaprofile(null_complain_profile);
 	null_complain_profile = NULL;
 
 	return -ENOMEM;
@@ -294,24 +294,24 @@ fail:
  */
 void free_null_complain_profile(void)
 {
-	put_aa_profile(null_complain_profile);
+	put_aaprofile(null_complain_profile);
 	null_complain_profile = NULL;
 }
 
 /**
- * aa_audit_message - Log a message to the audit subsystem
+ * aaaudit_message - Log a message to the audit subsystem
  * @active: profile to check against
  * @gfp: allocation flags
  * @flags: audit flags
  * @fmt: varargs fmt
  */
-int aa_audit_message(struct aa_profile *active, gfp_t gfp, int flags,
+int aaaudit_message(struct aaprofile *active, gfp_t gfp, int flags,
 		     const char *fmt, ...)
 {
 	int ret;
-	struct aa_audit sa;
+	struct aaaudit sa;
 
-	sa.type = AA_AUDITTYPE_MSG;
+	sa.type = AAAUDITTYPE_MSG;
 	sa.name = fmt;
 	va_start(sa.vaval, fmt);
 	sa.flags = flags;
@@ -319,7 +319,7 @@ int aa_audit_message(struct aa_profile *
 	sa.error_code = 0;
 	sa.result = 0;	/* fake failure: force message to be logged */
 
-	ret = aa_audit(active, &sa);
+	ret = aaaudit(active, &sa);
 
 	va_end(sa.vaval);
 
@@ -327,32 +327,32 @@ int aa_audit_message(struct aa_profile *
 }
 
 /**
- * aa_audit_syscallreject - Log a syscall rejection to the audit subsystem
+ * aaaudit_syscallreject - Log a syscall rejection to the audit subsystem
  * @active: profile to check against
  * @msg: string describing syscall being rejected
  * @gfp: memory allocation flags
  */
-int aa_audit_syscallreject(struct aa_profile *active, gfp_t gfp,
+int aaaudit_syscallreject(struct aaprofile *active, gfp_t gfp,
 			   const char *msg)
 {
-	struct aa_audit sa;
+	struct aaaudit sa;
 
-	sa.type = AA_AUDITTYPE_SYSCALL;
+	sa.type = AAAUDITTYPE_SYSCALL;
 	sa.name = msg;
 	sa.flags = 0;
 	sa.gfp_mask = gfp;
 	sa.error_code = 0;
 	sa.result = 0; /* failure */
 
-	return aa_audit(active, &sa);
+	return aaaudit(active, &sa);
 }
 
 /**
- * aa_audit - Log an audit event to the audit subsystem
+ * aaaudit - Log an audit event to the audit subsystem
  * @active: profile to check against
  * @sa: audit event
  */
-int aa_audit(struct aa_profile *active, const struct aa_audit *sa)
+int aaaudit(struct aaprofile *active, const struct aaaudit *sa)
 {
 	struct audit_buffer *ab = NULL;
 	struct audit_context *ctx;
@@ -366,7 +366,7 @@ int aa_audit(struct aa_profile *active, 
 
 	const gfp_t gfp_mask = sa->gfp_mask;
 
-	WARN_ON(sa->type >= AA_AUDITTYPE__END);
+	WARN_ON(sa->type >= AAAUDITTYPE__END);
 
 	/*
 	 * sa->result:	  1 success, 0 failure
@@ -388,13 +388,13 @@ int aa_audit(struct aa_profile *active, 
 		audit_log(current->audit_context, gfp_mask, AUDIT_SD,
 			"Internal error auditing event type %d (error %d)",
 			sa->type, sa->error_code);
-		AA_ERROR("Internal error auditing event type %d (error %d)\n",
+		AAERROR("Internal error auditing event type %d (error %d)\n",
 			sa->type, sa->error_code);
 		error = sa->error_code;
 		goto out;
-	} else if (sa->type == AA_AUDITTYPE_SYSCALL) {
-		/* Currently AA_AUDITTYPE_SYSCALL is for rejects only.
-		 * Values set by aa_audit_syscallreject will get us here.
+	} else if (sa->type == AAAUDITTYPE_SYSCALL) {
+		/* Currently AAAUDITTYPE_SYSCALL is for rejects only.
+		 * Values set by aaaudit_syscallreject will get us here.
 		 */
 		logcls = "REJECTING";
 	} else {
@@ -407,23 +407,23 @@ int aa_audit(struct aa_profile *active, 
 	 */
 	flags = sa->flags;
 	if (apparmor_logsyscall)
-		flags |= AA_AUDITFLAG_AUDITSS_SYSCALL;
+		flags |= AAAUDITFLAG_AUDITSS_SYSCALL;
 
 
 	/* Force full audit syscall logging regardless of global setting if
 	 * we are rejecting a syscall
 	 */
-	if (sa->type == AA_AUDITTYPE_SYSCALL) {
+	if (sa->type == AAAUDITTYPE_SYSCALL) {
 		ctx = current->audit_context;
 	} else {
-		ctx = (flags & AA_AUDITFLAG_AUDITSS_SYSCALL) ?
+		ctx = (flags & AAAUDITFLAG_AUDITSS_SYSCALL) ?
 			current->audit_context : NULL;
 	}
 
 	ab = audit_log_start(ctx, gfp_mask, AUDIT_SD);
 
 	if (!ab) {
-		AA_ERROR("Unable to log event (%d) to audit subsys\n",
+		AAERROR("Unable to log event (%d) to audit subsys\n",
 			sa->type);
 		if (complain)
 			error = 0;
@@ -431,7 +431,7 @@ int aa_audit(struct aa_profile *active, 
 	}
 
 	/* messages get special handling */
-	if (sa->type == AA_AUDITTYPE_MSG) {
+	if (sa->type == AAAUDITTYPE_MSG) {
 		audit_log_vformat(ab, sa->name, sa->vaval);
 		audit_log_end(ab);
 		error = 0;
@@ -442,23 +442,23 @@ int aa_audit(struct aa_profile *active, 
 
 	audit_log_format(ab, "%s ", logcls);	/* REJECTING/ALLOWING/etc */
 
-	if (sa->type == AA_AUDITTYPE_FILE) {
+	if (sa->type == AAAUDITTYPE_FILE) {
 		int perm = audit ? sa->mask : sa->error_code;
 
 		audit_log_format(ab, "%s%s%s%s%s access to %s ",
-				 perm & AA_EXEC_MMAP ? "m" : "",
-				 perm & AA_MAY_READ  ? "r" : "",
-				 perm & AA_MAY_WRITE ? "w" : "",
-				 perm & AA_MAY_EXEC  ? "x" : "",
-				 perm & AA_MAY_LINK  ? "l" : "",
+				 perm & AAEXEC_MMAP ? "m" : "",
+				 perm & AAMAY_READ  ? "r" : "",
+				 perm & AAMAY_WRITE ? "w" : "",
+				 perm & AAMAY_EXEC  ? "x" : "",
+				 perm & AAMAY_LINK  ? "l" : "",
 				 sa->name);
 
 		opspec_error = -EPERM;
 
-	} else if (sa->type == AA_AUDITTYPE_DIR) {
+	} else if (sa->type == AAAUDITTYPE_DIR) {
 		audit_log_format(ab, "%s on %s ", sa->operation, sa->name);
 
-	} else if (sa->type == AA_AUDITTYPE_ATTR) {
+	} else if (sa->type == AAAUDITTYPE_ATTR) {
 		struct iattr *iattr = (struct iattr*)sa->pval;
 
 		audit_log_format(ab,
@@ -474,25 +474,25 @@ int aa_audit(struct aa_profile *active, 
 			iattr->ia_valid & ATTR_CTIME ? "ctime," : "",
 			sa->name);
 
-	} else if (sa->type == AA_AUDITTYPE_XATTR) {
+	} else if (sa->type == AAAUDITTYPE_XATTR) {
 		/* FIXME: how are special characters in sa->name escaped? */
 		/* FIXME: check if this can be handled on the stack
 			  with an inline varargs function. */
 		audit_log_format(ab, "%s on %s ", sa->operation, sa->name);
 
-	} else if (sa->type == AA_AUDITTYPE_LINK) {
+	} else if (sa->type == AAAUDITTYPE_LINK) {
 		audit_log_format(ab,
 			"link access from %s to %s ",
 			sa->name,
 			(char*)sa->pval);
 
-	} else if (sa->type == AA_AUDITTYPE_CAP) {
+	} else if (sa->type == AAAUDITTYPE_CAP) {
 		audit_log_format(ab,
 			"access to capability '%s' ",
 			capability_to_name(sa->capability));
 
 		opspec_error = -EPERM;
-	} else if (sa->type == AA_AUDITTYPE_SYSCALL) {
+	} else if (sa->type == AAAUDITTYPE_SYSCALL) {
 		audit_log_format(ab, "access to syscall '%s' ", sa->name);
 
 		opspec_error = -EPERM;
@@ -517,14 +517,14 @@ out:
 }
 
 /**
- * aa_get_name - retrieve fully qualified path name
+ * aaget_name - retrieve fully qualified path name
  * @dentry: relative path element
  * @mnt: where in tree
  *
  * Returns fully qualified path name on sucess, NULL on failure.
- * aa_put_name must be used to free allocated buffer.
+ * aaput_name must be used to free allocated buffer.
  */
-char *aa_get_name(struct dentry *dentry, struct vfsmount *mnt)
+char *aaget_name(struct dentry *dentry, struct vfsmount *mnt)
 {
 	char *page, *name;
 
@@ -550,7 +550,7 @@ char *aa_get_name(struct dentry *dentry,
 		    size > deleted_size &&
 		    strcmp(name + size - deleted_size, deleted_str) == 0)
 			name[size - deleted_size] = '\0';
-		AA_DEBUG("%s: full_path=%s\n", __FUNCTION__, name);
+		AADEBUG("%s: full_path=%s\n", __FUNCTION__, name);
 	}
 
 out:
@@ -562,29 +562,29 @@ out:
  ***********************************/
 
 /**
- * aa_attr - check whether attribute change allowed
+ * aaattr - check whether attribute change allowed
  * @active: profile to check against
  * @dentry: file to check
  * @iattr: attribute changes requested
  */
-int aa_attr(struct aa_profile *active, struct dentry *dentry,
+int aaattr(struct aaprofile *active, struct dentry *dentry,
 	    struct vfsmount *mnt, struct iattr *iattr)
 {
 	int error;
-	struct aa_audit sa;
+	struct aaaudit sa;
 
-	sa.type = AA_AUDITTYPE_ATTR;
+	sa.type = AAAUDITTYPE_ATTR;
 	sa.pval = iattr;
 	sa.flags = 0;
 	sa.gfp_mask = GFP_KERNEL;
 
-	error = _aa_perm_vfsmount(active, dentry, mnt, &sa, MAY_WRITE);
+	error = _aaperm_vfsmount(active, dentry, mnt, &sa, MAY_WRITE);
 
 	return error;
 }
 
 /**
- * aa_perm_xattr - check whether xattr attribute change allowed
+ * aaperm_xattr - check whether xattr attribute change allowed
  * @active: profile to check against
  * @dentry: file to check
  * @mnt: mount of file to check
@@ -592,26 +592,26 @@ int aa_attr(struct aa_profile *active, s
  * @xattr_name: name of xattr to check
  * @mask: access mode requested
  */
-int aa_perm_xattr(struct aa_profile *active, struct dentry *dentry,
+int aaperm_xattr(struct aaprofile *active, struct dentry *dentry,
 		  struct vfsmount *mnt, const char *operation,
 		  const char *xattr_name, int mask)
 {
 	int error;
-	struct aa_audit sa;
+	struct aaaudit sa;
 
-	sa.type = AA_AUDITTYPE_XATTR;
+	sa.type = AAAUDITTYPE_XATTR;
 	sa.operation = operation;
 	sa.pval = xattr_name;
 	sa.flags = 0;
 	sa.gfp_mask = GFP_KERNEL;
 
-	error = _aa_perm_vfsmount(active, dentry, mnt, &sa, mask);
+	error = _aaperm_vfsmount(active, dentry, mnt, &sa, mask);
 
 	return error;
 }
 
 /**
- * aa_perm - basic apparmor permissions check
+ * aaperm - basic apparmor permissions check
  * @active: profile to check against
  * @dentry: dentry
  * @mnt: mountpoint
@@ -620,27 +620,27 @@ int aa_perm_xattr(struct aa_profile *act
  * Determine if access (mask) for dentry is authorized by active
  * profile.  Result, %0 (success), -ve (error)
  */
-int aa_perm(struct aa_profile *active, struct dentry *dentry,
+int aaperm(struct aaprofile *active, struct dentry *dentry,
 	    struct vfsmount *mnt, int mask)
 {
 	int error = 0;
-	struct aa_audit sa;
+	struct aaaudit sa;
 
-	if ((mask = aa_filter_mask(mask, dentry->d_inode)) == 0)
+	if ((mask = aafilter_mask(mask, dentry->d_inode)) == 0)
 		goto out;
 
-	sa.type = AA_AUDITTYPE_FILE;
+	sa.type = AAAUDITTYPE_FILE;
 	sa.mask = mask;
 	sa.flags = 0;
 	sa.gfp_mask = GFP_KERNEL;
-	error = _aa_perm_vfsmount(active, dentry, mnt, &sa, mask);
+	error = _aaperm_vfsmount(active, dentry, mnt, &sa, mask);
 
 out:
 	return error;
 }
 
 /**
- * aa_perm_dir
+ * aaperm_dir
  * @active: profile to check against
  * @dentry: requested dentry
  * @mnt: mount of file to check
@@ -651,33 +651,33 @@ out:
  * by @active profile.
  * Result, %0 (success), -ve (error)
  */
-int aa_perm_dir(struct aa_profile *active, struct dentry *dentry,
+int aaperm_dir(struct aaprofile *active, struct dentry *dentry,
 		struct vfsmount *mnt, const char *operation, int mask)
 {
-	struct aa_audit sa;
+	struct aaaudit sa;
 
-	sa.type = AA_AUDITTYPE_DIR;
+	sa.type = AAAUDITTYPE_DIR;
 	sa.operation = operation;
 	sa.flags = 0;
 	sa.gfp_mask = GFP_KERNEL;
 
-	return _aa_perm_vfsmount(active, dentry, mnt, &sa, mask);
+	return _aaperm_vfsmount(active, dentry, mnt, &sa, mask);
 }
 
 /**
- * aa_capability - test permission to use capability
+ * aacapability - test permission to use capability
  * @active: profile to check against
  * @cap: capability to be tested
  *
  * Look up capability in active profile capability set.
  * Return %0 (success), -%EPERM (error)
  */
-int aa_capability(struct aa_profile *active, int cap)
+int aacapability(struct aaprofile *active, int cap)
 {
 	int error = 0;
-	struct aa_audit sa;
+	struct aaaudit sa;
 
-	sa.type = AA_AUDITTYPE_CAP;
+	sa.type = AAAUDITTYPE_CAP;
 	sa.name = NULL;
 	sa.capability = cap;
 	sa.flags = 0;
@@ -685,27 +685,27 @@ int aa_capability(struct aa_profile *act
 	sa.result = cap_raised(active->capabilities, cap);
 	sa.gfp_mask = GFP_ATOMIC;
 
-	error = aa_audit(active, &sa);
+	error = aaaudit(active, &sa);
 
 	return error;
 }
 
 /**
- * aa_link - hard link check
+ * aalink - hard link check
  * @active: profile to check against
  * @link: dentry for link being created
  * @target: dentry for link target
  * @mnt: vfsmount (-EXDEV is link and target are not on same vfsmount)
  */
-int aa_link(struct aa_profile *active,
+int aalink(struct aaprofile *active,
 	    struct dentry *link, struct vfsmount *link_mnt,
 	    struct dentry *target, struct vfsmount *target_mnt)
 {
         int permerror = -EPERM, error;
-	struct aa_audit sa;
+	struct aaaudit sa;
 
-        sa.name = aa_get_name(link, link_mnt);
-        sa.pval = aa_get_name(target, target_mnt);
+        sa.name = aaget_name(link, link_mnt);
+        sa.pval = aaget_name(target, target_mnt);
 
         if (IS_ERR(sa.name)) {
                 permerror = PTR_ERR(sa.name);
@@ -717,18 +717,18 @@ int aa_link(struct aa_profile *active,
 	}
 
 	if (sa.name && sa.pval)
-		permerror = aa_link_perm(active, sa.name, sa.pval);
+		permerror = aalink_perm(active, sa.name, sa.pval);
 
-        aa_permerror2result(permerror, &sa);
+        aapermerror2result(permerror, &sa);
 
-	sa.type = AA_AUDITTYPE_LINK;
+	sa.type = AAAUDITTYPE_LINK;
 	sa.flags = 0;
 	sa.gfp_mask = GFP_KERNEL;
 
-	error = aa_audit(active, &sa);
+	error = aaaudit(active, &sa);
 
-        aa_put_name(sa.name);
-        aa_put_name(sa.pval);
+        aaput_name(sa.name);
+        aaput_name(sa.pval);
 
         return error;
 }
@@ -738,27 +738,27 @@ int aa_link(struct aa_profile *active,
  *******************************/
 
 /**
- * aa_fork - create a new subdomain
+ * aafork - create a new subdomain
  * @p: new process
  *
  * Create a new subdomain for newly created process @p if it's parent
  * is already confined.  Otherwise a subdomain will be lazily allocated
  * will get one with NULL values.  Return 0 on sucess.
- * for the child if it subsequently execs (in aa_register).
+ * for the child if it subsequently execs (in aaregister).
  * Return 0 on sucess.
  *
  * The sd_lock is used to maintain consistency against profile
  * replacement/removal.
  */
 
-int aa_fork(struct task_struct *p)
+int aafork(struct task_struct *p)
 {
-	struct subdomain *sd = AA_SUBDOMAIN(current->security);
+	struct subdomain *sd = AASUBDOMAIN(current->security);
 	struct subdomain *newsd = NULL;
 
-	AA_DEBUG("%s\n", __FUNCTION__);
+	AADEBUG("%s\n", __FUNCTION__);
 
-	if (__aa_is_confined(sd)) {
+	if (__aais_confined(sd)) {
 		unsigned long flags;
 
 		newsd = alloc_subdomain(p);
@@ -771,7 +771,7 @@ int aa_fork(struct task_struct *p)
 		 * new reference to be consistent.
 		 */
 		spin_lock_irqsave(&sd_lock, flags);
-		aa_switch(newsd, sd->active);
+		aaswitch(newsd, sd->active);
 		newsd->hat_magic = sd->hat_magic;
 		spin_unlock_irqrestore(&sd_lock, flags);
 
@@ -786,18 +786,18 @@ int aa_fork(struct task_struct *p)
 }
 
 /**
- * aa_register - register a new program
+ * aaregister - register a new program
  * @bprm: binprm of program being registered
  *
  * Try to register a new program during execve().  This should give the
  * new program a valid subdomain.
  */
-int aa_register(struct linux_binprm *bprm)
+int aaregister(struct linux_binprm *bprm)
 {
 	char *filename;
 	struct file *filp = bprm->file;
-	struct aa_profile *active;
-	struct aa_profile *newprofile = NULL, unconstrained_flag;
+	struct aaprofile *active;
+	struct aaprofile *newprofile = NULL, unconstrained_flag;
 	int 	error = -ENOMEM,
 		exec_mode = 0,
 		find_profile = 0,
@@ -805,17 +805,17 @@ int aa_register(struct linux_binprm *bpr
 		complain = 0,
 		unsafe_exec = 0;
 
-	AA_DEBUG("%s\n", __FUNCTION__);
+	AADEBUG("%s\n", __FUNCTION__);
 
-	filename = aa_get_name(filp->f_dentry, filp->f_vfsmnt);
+	filename = aaget_name(filp->f_dentry, filp->f_vfsmnt);
 	if (IS_ERR(filename)) {
-		AA_WARN("%s: Failed to get filename\n", __FUNCTION__);
+		AAWARN("%s: Failed to get filename\n", __FUNCTION__);
 		goto out;
 	}
 
 	error = 0;
 
-	active = get_active_aa_profile();
+	active = get_active_aaprofile();
 
 	if (!active) {
 		/* Unconfined task, load profile if it exists */
@@ -828,22 +828,22 @@ int aa_register(struct linux_binprm *bpr
 	/* Confined task, determine what mode inherit, unconstrained or
 	 * mandatory to load new profile
 	 */
-	exec_mode = AA_EXEC_MASK(aa_match(active->file_rules, filename));
-	unsafe_exec = exec_mode & AA_EXEC_UNSAFE;
+	exec_mode = AAEXEC_MASK(aamatch(active->file_rules, filename));
+	unsafe_exec = exec_mode & AAEXEC_UNSAFE;
 
 	if (exec_mode) {
-		switch (AA_EXEC_MODIFIER_MASK(exec_mode)) {
-		case AA_EXEC_INHERIT:
+		switch (AAEXEC_MODIFIER_MASK(exec_mode)) {
+		case AAEXEC_INHERIT:
 			/* do nothing - setting of profile
-			 * already handed in aa_fork
+			 * already handed in aafork
 			 */
-			AA_DEBUG("%s: INHERIT %s\n",
+			AADEBUG("%s: INHERIT %s\n",
 				 __FUNCTION__,
 				 filename);
 			break;
 
-		case AA_EXEC_UNCONSTRAINED:
-			AA_DEBUG("%s: UNCONSTRAINED %s\n",
+		case AAEXEC_UNCONSTRAINED:
+			AADEBUG("%s: UNCONSTRAINED %s\n",
 				 __FUNCTION__,
 				 filename);
 
@@ -851,8 +851,8 @@ int aa_register(struct linux_binprm *bpr
 			newprofile = &unconstrained_flag;
 			break;
 
-		case AA_EXEC_PROFILE:
-			AA_DEBUG("%s: PROFILE %s\n",
+		case AAEXEC_PROFILE:
+			AADEBUG("%s: PROFILE %s\n",
 				 __FUNCTION__,
 				 filename);
 
@@ -860,13 +860,13 @@ int aa_register(struct linux_binprm *bpr
 			find_profile_mandatory = 1;
 			break;
 
-		case AA_MAY_EXEC:
+		case AAMAY_EXEC:
 			/* this should not happen, entries
 			 * with just EXEC only should be
 			 * rejected at profile load time
 			 */
-			AA_ERROR("%s: Rejecting exec(2) of image '%s'. "
-				"AA_MAY_EXEC without exec qualifier invalid "
+			AAERROR("%s: Rejecting exec(2) of image '%s'. "
+				"AAMAY_EXEC without exec qualifier invalid "
 				"(%s(%d) profile %s active %s\n",
 				 __FUNCTION__,
 				 filename,
@@ -876,7 +876,7 @@ int aa_register(struct linux_binprm *bpr
 			break;
 
 		default:
-			AA_ERROR("%s: Rejecting exec(2) of image '%s'. "
+			AAERROR("%s: Rejecting exec(2) of image '%s'. "
 				 "Unknown exec qualifier %x "
 				 "(%s (pid %d) profile %s active %s)\n",
 				 __FUNCTION__,
@@ -893,10 +893,10 @@ int aa_register(struct linux_binprm *bpr
 		 * describing mode to execute image in.
 		 * Drop into null-profile (disabling secure exec).
 		 */
-		newprofile = get_aa_profile(null_complain_profile);
+		newprofile = get_aaprofile(null_complain_profile);
 		unsafe_exec = 1;
 	} else {
-		AA_WARN("%s: Rejecting exec(2) of image '%s'. "
+		AAWARN("%s: Rejecting exec(2) of image '%s'. "
 			"Unable to determine exec qualifier "
 			"(%s (pid %d) profile %s active %s)\n",
 			__FUNCTION__,
@@ -912,9 +912,9 @@ find_profile:
 		goto apply_profile;
 
 	/* Locate new profile */
-	newprofile = aa_profilelist_find(filename);
+	newprofile = aaprofilelist_find(filename);
 	if (newprofile) {
-		AA_DEBUG("%s: setting profile %s\n",
+		AADEBUG("%s: setting profile %s\n",
 			 __FUNCTION__, newprofile->name);
 	} else if (find_profile_mandatory) {
 		/* Profile (mandatory) could not be found */
@@ -926,9 +926,9 @@ find_profile:
 				current->pid,
 				BASE_PROFILE(active)->name, active->name);
 
-			newprofile = get_aa_profile(null_complain_profile);
+			newprofile = get_aaprofile(null_complain_profile);
 		} else {
-			AA_WARN("REJECTING exec(2) of image '%s'. "
+			AAWARN("REJECTING exec(2) of image '%s'. "
 				"Profile mandatory and not found "
 				"(%s(%d) profile %s active %s)\n",
 				filename,
@@ -945,7 +945,7 @@ find_profile:
 
 		WARN_ON(active);
 
-		AA_DEBUG("%s: No profile found for exec image %s\n",
+		AADEBUG("%s: No profile found for exec image %s\n",
 			 __FUNCTION__,
 			 filename);
 	} /* newprofile */
@@ -978,15 +978,15 @@ apply_profile:
 		 *   the transition occured before replacement.
 		 *
 		 * - If newprofile points to an actual profile (result of
-		 *   aa_profilelist_find above), this profile may have been
+		 *   aaprofilelist_find above), this profile may have been
 		 *   replaced.  We need to fix it up.  Doing this to avoid
 		 *   having to hold a lock around all this code.
 		 */
 
-		if (!active && !(sd = AA_SUBDOMAIN(current->security))) {
+		if (!active && !(sd = AASUBDOMAIN(current->security))) {
 			lazy_sd = alloc_subdomain(current);
 			if (!lazy_sd) {
-				AA_ERROR("%s: Failed to allocate subdomain\n",
+				AAERROR("%s: Failed to allocate subdomain\n",
 					 __FUNCTION__);
 				error = -ENOMEM;
 				goto cleanup;
@@ -995,7 +995,7 @@ apply_profile:
 
 		spin_lock_irqsave(&sd_lock, flags);
 
-		sd = AA_SUBDOMAIN(current->security);
+		sd = AASUBDOMAIN(current->security);
 		if (lazy_sd) {
 			if (sd) {
 				/* raced by setprofile - created sd */
@@ -1016,10 +1016,10 @@ apply_profile:
 		if (newprofile && unlikely(newprofile->isstale)) {
 			WARN_ON(newprofile == null_complain_profile);
 
-			/* drop refcnt obtained from earlier get_aa_profile */
-			put_aa_profile(newprofile);
+			/* drop refcnt obtained from earlier get_aaprofile */
+			put_aaprofile(newprofile);
 
-			newprofile = aa_profilelist_find(filename);
+			newprofile = aaprofilelist_find(filename);
 
 			if (!newprofile) {
 				/* Race, profile was removed, not replaced.
@@ -1039,16 +1039,16 @@ apply_profile:
 		 * Cases 2 and 3 are marked as requiring secure exec
 		 * (unless policy specified "unsafe exec")
 		 */
-		if (__aa_is_confined(sd) && !unsafe_exec) {
+		if (__aais_confined(sd) && !unsafe_exec) {
 			unsigned long bprm_flags;
 
-			bprm_flags = AA_SECURE_EXEC_NEEDED;
+			bprm_flags = AASECURE_EXEC_NEEDED;
 			bprm->security = (void*)
 				((unsigned long)bprm->security | bprm_flags);
 		}
 
-		aa_switch(sd, newprofile);
-		put_aa_profile(newprofile);
+		aaswitch(sd, newprofile);
+		put_aaprofile(newprofile);
 
 		if (complain && newprofile == null_complain_profile)
 			LOG_HINT(newprofile, GFP_ATOMIC, HINT_CHGPROF,
@@ -1059,16 +1059,16 @@ apply_profile:
 	}
 
 cleanup:
-	aa_put_name(filename);
+	aaput_name(filename);
 
-	put_aa_profile(active);
+	put_aaprofile(active);
 
 out:
 	return error;
 }
 
 /**
- * aa_release - release the task's subdomain
+ * aarelease - release the task's subdomain
  * @p: task being released
  *
  * This is called after a task has exited and the parent has reaped it.
@@ -1077,17 +1077,17 @@ out:
  * This is the one case where we don't need to hold the sd_lock before
  * removing a profile from a subdomain.  Once the subdomain has been
  * removed from the subdomain_list, we are no longer racing other writers.
- * There may still be other readers so we must still use aa_switch
+ * There may still be other readers so we must still use aaswitch
  * to put the subdomain's reference safely.
  */
-void aa_release(struct task_struct *p)
+void aarelease(struct task_struct *p)
 {
-	struct subdomain *sd = AA_SUBDOMAIN(p->security);
+	struct subdomain *sd = AASUBDOMAIN(p->security);
 	if (sd) {
 		p->security = NULL;
 
-		aa_subdomainlist_remove(sd);
-		aa_switch_unconfined(sd);
+		aasubdomainlist_remove(sd);
+		aaswitch_unconfined(sd);
 
 		kfree(sd);
 	}
@@ -1106,15 +1106,15 @@ void aa_release(struct task_struct *p)
  */
 static inline int do_change_hat(const char *hat_name, struct subdomain *sd)
 {
-	struct aa_profile *sub;
+	struct aaprofile *sub;
 	int error = 0;
 
-	sub = __aa_find_profile(hat_name, &BASE_PROFILE(sd->active)->sub);
+	sub = __aafind_profile(hat_name, &BASE_PROFILE(sd->active)->sub);
 
 	if (sub) {
 		/* change hat */
-		aa_switch(sd, sub);
-		put_aa_profile(sub);
+		aaswitch(sd, sub);
+		put_aaprofile(sub);
 	} else {
 		/* There is no such subprofile change to a NULL profile.
 		 * The NULL profile grants no file access.
@@ -1133,7 +1133,7 @@ static inline int do_change_hat(const ch
 				BASE_PROFILE(sd->active)->name,
 				sd->active->name);
 		} else {
-			AA_DEBUG("%s: Unknown hatname '%s'. "
+			AADEBUG("%s: Unknown hatname '%s'. "
 				"Changing to NULL profile "
 				"(%s(%d) profile %s active %s)\n",
 				 __FUNCTION__,
@@ -1143,14 +1143,14 @@ static inline int do_change_hat(const ch
 				 sd->active->name);
 			error = -EACCES;
 		}
-		aa_switch(sd, sd->active->null_profile);
+		aaswitch(sd, sd->active->null_profile);
 	}
 
 	return error;
 }
 
 /**
- * aa_change_hat - change hat to/from subprofile
+ * aachange_hat - change hat to/from subprofile
  * @hat_name: specifies hat to change to
  * @hat_magic: token to validate hat change
  *
@@ -1160,25 +1160,25 @@ static inline int do_change_hat(const ch
  * return to original top level profile.  Returns %0 on success, error
  * otherwise.
  */
-int aa_change_hat(const char *hat_name, u32 hat_magic)
+int aachange_hat(const char *hat_name, u32 hat_magic)
 {
-	struct subdomain *sd = AA_SUBDOMAIN(current->security);
+	struct subdomain *sd = AASUBDOMAIN(current->security);
 	int error = 0;
 
-	AA_DEBUG("%s: %p, 0x%x (pid %d)\n",
+	AADEBUG("%s: %p, 0x%x (pid %d)\n",
 		 __FUNCTION__,
 		 hat_name, hat_magic,
 		 current->pid);
 
 	/* Dump out above debugging in WARN mode if we are in AUDIT mode */
 	if (SUBDOMAIN_AUDIT(sd)) {
-		AA_WARN("%s: %s, 0x%x (pid %d)\n",
+		AAWARN("%s: %s, 0x%x (pid %d)\n",
 			__FUNCTION__, hat_name ? hat_name : "NULL",
 			hat_magic, current->pid);
 	}
 
 	/* check to see if an unconfined process is doing a changehat. */
-	if (!__aa_is_confined(sd)) {
+	if (!__aais_confined(sd)) {
 		error = -EPERM;
 		goto out;
 	}
@@ -1198,7 +1198,7 @@ int aa_change_hat(const char *hat_name, 
 		 * parent
 		 */
 		if (hat_name) {
-			AA_DEBUG("%s: switching to %s, 0x%x\n",
+			AADEBUG("%s: switching to %s, 0x%x\n",
 				 __FUNCTION__,
 				 hat_name,
 				 hat_magic);
@@ -1232,7 +1232,7 @@ int aa_change_hat(const char *hat_name, 
 				 * Got here via changehat(NULL, magic)
 				 * Return from subprofile, back to parent
 				 */
-				aa_switch(sd, sd->active->parent);
+				aaswitch(sd, sd->active->parent);
 
 				/* Reset hat_magic to zero.
 				 * New value will be passed on next changehat
@@ -1243,7 +1243,7 @@ int aa_change_hat(const char *hat_name, 
 				error = do_change_hat(hat_name, sd);
 			}
 		} else if (sd->hat_magic) {
-			AA_ERROR("KILLING process %s(%d) "
+			AAERROR("KILLING process %s(%d) "
 				 "Invalid change_hat() magic# 0x%x "
 				 "(hatname %s profile %s active %s)\n",
 				 current->comm, current->pid,
@@ -1255,7 +1255,7 @@ int aa_change_hat(const char *hat_name, 
 			/* terminate current process */
 			(void)send_sig_info(SIGKILL, NULL, current);
 		} else {	/* sd->hat_magic == NULL */
-			AA_ERROR("KILLING process %s(%d) "
+			AAERROR("KILLING process %s(%d) "
 				 "Task was confined to current subprofile "
 				 "(profile %s active %s)\n",
 				 current->comm, current->pid,
Index: linux-2.6/security/apparmor/match.c
===================================================================
--- linux-2.6.orig/security/apparmor/match.c
+++ linux-2.6/security/apparmor/match.c
@@ -16,7 +16,7 @@
 #include <linux/module.h>
 #include "match.h"
 
-static const char *features="pattern=aa_dfa";
+static const char *features="pattern=aadfa";
 
 static struct table_header *unpack_table(void *blob, size_t bsize)
 {
@@ -58,7 +58,7 @@ out:
 	return table;
 }
 
-int unpack_dfa(struct aa_dfa *dfa, void *blob, size_t size)
+int unpack_dfa(struct aadfa *dfa, void *blob, size_t size)
 {
 	int i;
 	int error = -ENOMEM;
@@ -138,7 +138,7 @@ fail:
  *
  * assumes dfa has gone through the verification done by unpacking
  */
-int verify_dfa(struct aa_dfa *dfa)
+int verify_dfa(struct aadfa *dfa)
 {
 	size_t i, state_count, trans_count;
 	int error = -EPROTO;
@@ -186,12 +186,12 @@ out:
 	return error;
 }
 
-struct aa_dfa *aa_match_alloc(void)
+struct aadfa *aamatch_alloc(void)
 {
-	return kzalloc(sizeof(struct aa_dfa), GFP_KERNEL);
+	return kzalloc(sizeof(struct aadfa), GFP_KERNEL);
 }
 
-void aa_match_free(struct aa_dfa *dfa)
+void aamatch_free(struct aadfa *dfa)
 {
 	if (dfa) {
 		int i;
@@ -202,13 +202,13 @@ void aa_match_free(struct aa_dfa *dfa)
 	kfree(dfa);
 }
 
-const char *aa_match_features(void)
+const char *aamatch_features(void)
 {
 	return features;
 }
 
 /**
- * aa_dfa_label - return the permissions associated with @state
+ * aadfa_label - return the permissions associated with @state
  * @dfa: dfa to get state permission from
  * @state: state in the dfa for which to get a label
  *
@@ -217,23 +217,23 @@ const char *aa_match_features(void)
  * Returns the label associated with @state.  0 indicates the state
  * is no-accepting/provides no permissions.
  */
-inline unsigned int aa_dfa_label(struct aa_dfa *dfa, int state)
+inline unsigned int aadfa_label(struct aadfa *dfa, int state)
 {
 	return ACCEPT_TABLE(dfa)[state];
 }
 
 /**
- * aa_dfa_match - match @path against @dfa starting in @state
+ * aadfa_match - match @path against @dfa starting in @state
  * @dfa: the dfa to match @path against
  * @state: the state to start matching in
  * @path: the path to match against the dfa
  *
- * aa_dfa_match will match the full path length and return the state it
+ * aadfa_match will match the full path length and return the state it
  * finished matching in.  The final state returned can be used to
  * lookup the accepting label or as a starting point to continue matching
  * with a new string if the path has been broken into multiple components.
  */
-inline unsigned int aa_dfa_match(struct aa_dfa *dfa, unsigned int state,
+inline unsigned int aadfa_match(struct aadfa *dfa, unsigned int state,
 				 const char *path)
 {
 	u8 *s = (u8 *) path;
@@ -265,10 +265,10 @@ inline unsigned int aa_dfa_match(struct 
 	return state;
 }
 
-unsigned int aa_match(struct aa_dfa *dfa, const char *pathname)
+unsigned int aamatch(struct aadfa *dfa, const char *pathname)
 {
 	if (dfa)
-		return aa_dfa_label(dfa, aa_dfa_match(dfa, 1, pathname));
+		return aadfa_label(dfa, aadfa_match(dfa, 1, pathname));
 
 	return 0;
 }
Index: linux-2.6/security/apparmor/match.h
===================================================================
--- linux-2.6.orig/security/apparmor/match.h
+++ linux-2.6/security/apparmor/match.h
@@ -49,7 +49,7 @@ struct table_header {
 #define EQUIV_TABLE(DFA) ((u8 *)((DFA)->tables[YYTD_ID_EC - 1]->td_data))
 #define ACCEPT_TABLE(DFA) ((u32 *)((DFA)->tables[YYTD_ID_ACCEPT - 1]->td_data))
 
-struct aa_dfa {
+struct aadfa {
 	struct table_header *tables[YYTD_ID_NXT];
 
 	struct table_set_header th;
Index: linux-2.6/security/apparmor/module_interface.c
===================================================================
--- linux-2.6.orig/security/apparmor/module_interface.c
+++ linux-2.6/security/apparmor/module_interface.c
@@ -15,26 +15,26 @@
 #include "inline.h"
 #include "module_interface.h"
 
-/* aa_code defined in module_interface.h */
+/* aacode defined in module_interface.h */
 
-const int aa_code_datasize[] = { 1, 2, 4, 8, 2, 2, 4, 0, 0, 0, 0, 0, 0 };
+const int aacode_datasize[] = { 1, 2, 4, 8, 2, 2, 4, 0, 0, 0, 0, 0, 0 };
 
-struct aa_taskreplace_data {
-	struct aa_profile *old_profile;
-	struct aa_profile *new_profile;
+struct aataskreplace_data {
+	struct aaprofile *old_profile;
+	struct aaprofile *new_profile;
 };
 
 /**
- * free_aa_profile_rcu - rcu callback for free profiles
+ * free_aaprofile_rcu - rcu callback for free profiles
  * @head: rcu_head struct of the profile whose reference is being put.
  *
  * the rcu callback routine, which delays the freeing of a profile when
  * its last reference is put.
  */
-static void free_aa_profile_rcu(struct rcu_head *head)
+static void free_aaprofile_rcu(struct rcu_head *head)
 {
-	struct aa_profile *p = container_of(head, struct aa_profile, rcu);
-	free_aa_profile(p);
+	struct aaprofile *p = container_of(head, struct aaprofile, rcu);
+	free_aaprofile(p);
 }
 
 /**
@@ -47,14 +47,14 @@ static void free_aa_profile_rcu(struct r
 static inline void task_remove(struct subdomain *sd)
 {
 	/* spin_lock(&sd_lock) held here */
-	AA_DEBUG("%s: removing profile from task %s(%d) profile %s active %s\n",
+	AADEBUG("%s: removing profile from task %s(%d) profile %s active %s\n",
 		 __FUNCTION__,
 		 sd->task->comm,
 		 sd->task->pid,
 		 BASE_PROFILE(sd->active)->name,
 		 sd->active->name);
 
-	aa_switch_unconfined(sd);
+	aaswitch_unconfined(sd);
 }
 
 /** taskremove_iter - Iterator to unconfine subdomains which match cookie
@@ -66,12 +66,12 @@ static inline void task_remove(struct su
  */
 static int taskremove_iter(struct subdomain *sd, void *cookie)
 {
-	struct aa_profile *old_profile = (struct aa_profile *)cookie;
+	struct aaprofile *old_profile = (struct aaprofile *)cookie;
 	unsigned long flags;
 
 	spin_lock_irqsave(&sd_lock, flags);
 
-	if (__aa_is_confined(sd) && BASE_PROFILE(sd->active) == old_profile) {
+	if (__aais_confined(sd) && BASE_PROFILE(sd->active) == old_profile) {
 		task_remove(sd);
 	}
 
@@ -89,9 +89,9 @@ static int taskremove_iter(struct subdom
  * hat in the new profile if it exists.  If it doesn't exist the
  * task will be placed in the special null_profile state.
  */
-static inline void task_replace(struct subdomain *sd, struct aa_profile *new)
+static inline void task_replace(struct subdomain *sd, struct aaprofile *new)
 {
-	AA_DEBUG("%s: replacing profile for task %s(%d) "
+	AADEBUG("%s: replacing profile for task %s(%d) "
 		 "profile=%s (%p) active=%s (%p)\n",
 		 __FUNCTION__,
 		 sd->task->comm, sd->task->pid,
@@ -102,19 +102,19 @@ static inline void task_replace(struct s
 		goto out;
 
 	if (IN_SUBPROFILE(sd->active)) {
-		struct aa_profile *nactive;
+		struct aaprofile *nactive;
 
 		/* The old profile was in a hat, check to see if the new
 		 * profile has an equivalent hat */
-		nactive = __aa_find_profile(sd->active->name, &new->sub);
+		nactive = __aafind_profile(sd->active->name, &new->sub);
 
 		if (!nactive)
-			nactive = get_aa_profile(new->null_profile);
+			nactive = get_aaprofile(new->null_profile);
 
-		aa_switch(sd, nactive);
-		put_aa_profile(nactive);
+		aaswitch(sd, nactive);
+		put_aaprofile(nactive);
 	} else {
-		aa_switch(sd, new);
+		aaswitch(sd, new);
 	}
 
  out:
@@ -131,12 +131,12 @@ static inline void task_replace(struct s
  */
 static int taskreplace_iter(struct subdomain *sd, void *cookie)
 {
-	struct aa_taskreplace_data *data = (struct aa_taskreplace_data *)cookie;
+	struct aataskreplace_data *data = (struct aataskreplace_data *)cookie;
 	unsigned long flags;
 
 	spin_lock_irqsave(&sd_lock, flags);
 
-	if (__aa_is_confined(sd) &&
+	if (__aais_confined(sd) &&
 	    BASE_PROFILE(sd->active) == data->old_profile)
 		task_replace(sd, data->new_profile);
 
@@ -145,13 +145,13 @@ static int taskreplace_iter(struct subdo
 	return 0;
 }
 
-static inline int aa_inbounds(struct aa_ext *e, size_t size)
+static inline int aainbounds(struct aaext *e, size_t size)
 {
 	return (e->pos + size <= e->end);
 }
 
 /**
- * aa_convert - convert trailing values of serialized type codes
+ * aaconvert - convert trailing values of serialized type codes
  * @code: type code
  * @dest: pointer to object to receive the converted value
  * @src:  pointer to value to convert
@@ -159,23 +159,23 @@ static inline int aa_inbounds(struct aa_
  * for serialized type codes which have a trailing value, convert it
  * and place it in @dest.  If a code does not have a trailing value nop.
  */
-static void aa_convert(enum aa_code code, void *dest, void *src)
+static void aaconvert(enum aacode code, void *dest, void *src)
 {
 	switch (code) {
-	case AA_U8:
+	case AAU8:
 		*(u8 *)dest = *(u8 *) src;
 		break;
-	case AA_U16:
-	case AA_NAME:
-	case AA_DYN_STRING:
+	case AAU16:
+	case AANAME:
+	case AADYN_STRING:
 		*(u16 *)dest = le16_to_cpu(get_unaligned((u16 *)src));
 		break;
-	case AA_U32:
-	case AA_BLOB_LOC:
-	case AA_STATIC_BLOB:
+	case AAU32:
+	case AABLOB_LOC:
+	case AASTATIC_BLOB:
 		*(u32 *)dest = le32_to_cpu(get_unaligned((u32 *)src));
 		break;
-	case AA_U64:
+	case AAU64:
 		*(u64 *)dest = le64_to_cpu(get_unaligned((u64 *)src));
 		break;
 	default:
@@ -185,7 +185,7 @@ static void aa_convert(enum aa_code code
 }
 
 /**
- * aa_is_X - check if the next element is of type X
+ * aais_X - check if the next element is of type X
  * @e: serialized data extent information
  * @code: type code
  * @data: object located at @e->pos (of type @code) is written into @data
@@ -199,33 +199,33 @@ static void aa_convert(enum aa_code code
  *        data is returned in data, but the size of the blob or string is
  *        returned.
  */
-static u32 aa_is_X(struct aa_ext *e, enum aa_code code, void *data)
+static u32 aais_X(struct aaext *e, enum aacode code, void *data)
 {
 	void *pos = e->pos;
 	int ret = 0;
-	if (!aa_inbounds(e, AA_CODE_BYTE + aa_code_datasize[code]))
+	if (!aainbounds(e, AACODE_BYTE + aacode_datasize[code]))
 		goto fail;
 	if (code != *(u8 *)e->pos &&
-	    !(code == AA_BLOB_LOC && AA_STATIC_BLOB == *(u8 *)e->pos))
+	    !(code == AABLOB_LOC && AASTATIC_BLOB == *(u8 *)e->pos))
 		goto out;
-	e->pos += AA_CODE_BYTE;
-	if (code == AA_NAME) {
+	e->pos += AACODE_BYTE;
+	if (code == AANAME) {
 		u16 size;
 		/* name codes are followed by X bytes */
 		size = le16_to_cpu(get_unaligned((u16 *)e->pos));
-		if (!aa_inbounds(e, (size_t) size))
+		if (!aainbounds(e, (size_t) size))
 			goto fail;
 		if (data)
 			*(u16 *)data = size;
-		e->pos += aa_code_datasize[code];
-		ret = 1 + aa_code_datasize[code];
-	} else if (code == AA_DYN_STRING) {
+		e->pos += aacode_datasize[code];
+		ret = 1 + aacode_datasize[code];
+	} else if (code == AADYN_STRING) {
 		u16 size;
 		char *str;
 		/* strings codes are followed by X bytes */
 		size = le16_to_cpu(get_unaligned((u16 *)e->pos));
-		e->pos += aa_code_datasize[code];
-		if (!aa_inbounds(e, (size_t) size))
+		e->pos += aacode_datasize[code];
+		if (!aainbounds(e, (size_t) size))
 			goto fail;
 		if (data) {
 			* (char **)data = NULL;
@@ -239,12 +239,12 @@ static u32 aa_is_X(struct aa_ext *e, enu
 		e->pos += size;
 		ret = size;
 
-	} else if (code == AA_BLOB_LOC) {
+	} else if (code == AABLOB_LOC) {
 		u32 size;
 		/* blobs are followed by X bytes */
 		size = le32_to_cpu(get_unaligned((u32 *)e->pos));
-		e->pos += aa_code_datasize[AA_STATIC_BLOB];
-		if (!aa_inbounds(e, (size_t) size))
+		e->pos += aacode_datasize[AASTATIC_BLOB];
+		if (!aainbounds(e, (size_t) size))
 			goto fail;
 		if (data) {
 			* (char **)data = e->pos;
@@ -252,12 +252,12 @@ static u32 aa_is_X(struct aa_ext *e, enu
 		e->pos += size;
 		ret = size;
 
-	} else if (code == AA_STATIC_BLOB) {
+	} else if (code == AASTATIC_BLOB) {
 		u32 size;
 		/* blobs are followed by X bytes, that can be 2^32 */
 		size = le32_to_cpu(get_unaligned((u32 *)e->pos));
-		e->pos += aa_code_datasize[code];
-		if (!aa_inbounds(e, (size_t) size))
+		e->pos += aacode_datasize[code];
+		if (!aainbounds(e, (size_t) size))
 			goto fail;
 		if (data)
 			memcpy(data, e->pos, (size_t) size);
@@ -265,9 +265,9 @@ static u32 aa_is_X(struct aa_ext *e, enu
 		ret = size;
 	} else {
 		if (data)
-			aa_convert(code, data, e->pos);
-		e->pos += aa_code_datasize[code];
-		ret = 1 + aa_code_datasize[code];
+			aaconvert(code, data, e->pos);
+		e->pos += aacode_datasize[code];
+		ret = 1 + aacode_datasize[code];
 	}
 out:
 	return ret;
@@ -277,7 +277,7 @@ fail:
 }
 
 /**
- * aa_is_nameX - check is the next element is of type X with a name of @name
+ * aais_nameX - check is the next element is of type X with a name of @name
  * @e: serialized data extent information
  * @code: type code
  * @data: location to store deserialized data if match isX criteria
@@ -289,15 +289,15 @@ fail:
  * size, and the next data in the stream is the string data)
  * returns %0 if either match failes
  */
-static int aa_is_nameX(struct aa_ext *e, enum aa_code code, void *data,
+static int aais_nameX(struct aaext *e, enum aacode code, void *data,
 		       const char *name)
 {
 	void *pos = e->pos;
 	u16 size;
 	u32 ret;
 	/* check for presence of a tagname, and if present name size
-	 * AA_NAME tag value is a u16 */
-	if (aa_is_X(e, AA_NAME, &size)) {
+	 * AANAME tag value is a u16 */
+	if (aais_X(e, AANAME, &size)) {
 		/* if a name is specified it must match. otherwise skip tag */
 		if (name && ((strlen(name) != size-1) ||
 			     strncmp(name, (char *)e->pos, (size_t)size-1)))
@@ -308,7 +308,7 @@ static int aa_is_nameX(struct aa_ext *e,
 	}
 
 	/* now check if data actually matches */
-	ret = aa_is_X(e, code, data);
+	ret = aais_X(e, code, data);
 	if (!ret)
 		goto fail;
 	return ret;
@@ -319,37 +319,37 @@ fail:
 }
 
 /* macro to wrap error case to make a block of reads look nicer */
-#define AA_READ_X(E, C, D, N) \
+#define AAREAD_X(E, C, D, N) \
 	do { \
 		u32 __ret; \
-		__ret = aa_is_nameX((E), (C), (D), (N)); \
+		__ret = aais_nameX((E), (C), (D), (N)); \
 		if (!__ret) \
 			goto fail; \
 	} while (0)
 
 /**
- * aa_activate_net_entry - unpacked serialized net entries
+ * aaactivate_net_entry - unpacked serialized net entries
  * @e: serialized data extent information
  *
  * Ignore/skips net entries if they are present in the serialized data
  * stream.  Network confinement rules are currently unsupported but some
  * user side tools can generate them so they are currently ignored.
  */
-static inline int aa_activate_net_entry(struct aa_ext *e)
+static inline int aaactivate_net_entry(struct aaext *e)
 {
-	AA_READ_X(e, AA_STRUCT, NULL, "ne");
-	AA_READ_X(e, AA_U32, NULL, NULL);
-	AA_READ_X(e, AA_U32, NULL, NULL);
-	AA_READ_X(e, AA_U32, NULL, NULL);
-	AA_READ_X(e, AA_U16, NULL, NULL);
-	AA_READ_X(e, AA_U16, NULL, NULL);
-	AA_READ_X(e, AA_U32, NULL, NULL);
-	AA_READ_X(e, AA_U32, NULL, NULL);
-	AA_READ_X(e, AA_U16, NULL, NULL);
-	AA_READ_X(e, AA_U16, NULL, NULL);
+	AAREAD_X(e, AASTRUCT, NULL, "ne");
+	AAREAD_X(e, AAU32, NULL, NULL);
+	AAREAD_X(e, AAU32, NULL, NULL);
+	AAREAD_X(e, AAU32, NULL, NULL);
+	AAREAD_X(e, AAU16, NULL, NULL);
+	AAREAD_X(e, AAU16, NULL, NULL);
+	AAREAD_X(e, AAU32, NULL, NULL);
+	AAREAD_X(e, AAU32, NULL, NULL);
+	AAREAD_X(e, AAU16, NULL, NULL);
+	AAREAD_X(e, AAU16, NULL, NULL);
 	/* interface name is optional so just ignore return code */
-	aa_is_nameX(e, AA_DYN_STRING, NULL, NULL);
-	AA_READ_X(e, AA_STRUCTEND, NULL, NULL);
+	aais_nameX(e, AADYN_STRING, NULL, NULL);
+	AAREAD_X(e, AASTRUCTEND, NULL, NULL);
 
 	return 1;
 fail:
@@ -357,20 +357,20 @@ fail:
 }
 
 /**
- * aa_activate_dfa - unpack a file rule dfa
+ * aaactivate_dfa - unpack a file rule dfa
  * @e: serialized data extent information
  *
  * returns dfa or ERR_PTR
  */
-struct aa_dfa *aa_activate_dfa(struct aa_ext *e)
+struct aadfa *aaactivate_dfa(struct aaext *e)
 {
 	char *blob = NULL;
 	size_t size, error = 0;
-	struct aa_dfa *dfa = NULL;
+	struct aadfa *dfa = NULL;
 
-	size = aa_is_nameX(e, AA_BLOB_LOC, &blob, "aa_dfa");
+	size = aais_nameX(e, AABLOB_LOC, &blob, "aadfa");
 	if (size) {
-		dfa = aa_match_alloc();
+		dfa = aamatch_alloc();
 		if (dfa) {
 			error = unpack_dfa(dfa, blob, size);
 
@@ -381,7 +381,7 @@ struct aa_dfa *aa_activate_dfa(struct aa
 		}
 
 		if (error) {
-			aa_match_free(dfa);
+			aamatch_free(dfa);
 			dfa = ERR_PTR(error);
 		}
 	}
@@ -390,19 +390,19 @@ struct aa_dfa *aa_activate_dfa(struct aa
 }
 
 /**
- * aa_activate_profile - unpack a serialized profile
+ * aaactivate_profile - unpack a serialized profile
  * @e: serialized data extent information
  * @error: error code returned if unpacking fails
  */
-static struct aa_profile *aa_activate_profile(struct aa_ext *e, ssize_t *error)
+static struct aaprofile *aaactivate_profile(struct aaext *e, ssize_t *error)
 {
-	struct aa_profile *profile = NULL;
+	struct aaprofile *profile = NULL;
 	const char *rulename = "";
 	const char *error_string = "Invalid Profile";
 
 	*error = -EPROTO;
 
-	profile = alloc_aa_profile();
+	profile = alloc_aaprofile();
 	if (!profile) {
 		error_string = "Could not allocate profile";
 		*error = -ENOMEM;
@@ -410,22 +410,22 @@ static struct aa_profile *aa_activate_pr
 	}
 
 	/* check that we have the right struct being passed */
-	AA_READ_X(e, AA_STRUCT, NULL, "profile");
-	AA_READ_X(e, AA_DYN_STRING, &profile->name, NULL);
+	AAREAD_X(e, AASTRUCT, NULL, "profile");
+	AAREAD_X(e, AADYN_STRING, &profile->name, NULL);
 
 	error_string = "Invalid flags";
 	/* per profile debug flags (debug, complain, audit) */
-	AA_READ_X(e, AA_STRUCT, NULL, "flags");
-	AA_READ_X(e, AA_U32, &(profile->flags.debug), NULL);
-	AA_READ_X(e, AA_U32, &(profile->flags.complain), NULL);
-	AA_READ_X(e, AA_U32, &(profile->flags.audit), NULL);
-	AA_READ_X(e, AA_STRUCTEND, NULL, NULL);
+	AAREAD_X(e, AASTRUCT, NULL, "flags");
+	AAREAD_X(e, AAU32, &(profile->flags.debug), NULL);
+	AAREAD_X(e, AAU32, &(profile->flags.complain), NULL);
+	AAREAD_X(e, AAU32, &(profile->flags.audit), NULL);
+	AAREAD_X(e, AASTRUCTEND, NULL, NULL);
 
 	error_string = "Invalid capabilities";
-	AA_READ_X(e, AA_U32, &(profile->capabilities), NULL);
+	AAREAD_X(e, AAU32, &(profile->capabilities), NULL);
 
 	/* get file rules */
-	profile->file_rules = aa_activate_dfa(e);
+	profile->file_rules = aaactivate_dfa(e);
 	if (IS_ERR(profile->file_rules)) {
 		error_string = "Invalid file rule dfa\n";
 		*error = PTR_ERR(profile->file_rules);
@@ -434,21 +434,21 @@ static struct aa_profile *aa_activate_pr
 	}
 
 	/* get the net entries */
-	if (aa_is_nameX(e, AA_LIST, NULL, "net")) {
+	if (aais_nameX(e, AALIST, NULL, "net")) {
 		error_string = "Invalid net entry";
-		while (!aa_is_nameX(e, AA_LISTEND, NULL, NULL)) {
-			if (!aa_activate_net_entry(e))
+		while (!aais_nameX(e, AALISTEND, NULL, NULL)) {
+			if (!aaactivate_net_entry(e))
 				goto fail;
 		}
 	}
 	rulename = "";
 
 	/* get subprofiles */
-	if (aa_is_nameX(e, AA_LIST, NULL, "hats")) {
+	if (aais_nameX(e, AALIST, NULL, "hats")) {
 		error_string = "Invalid profile hat";
-		while (!aa_is_nameX(e, AA_LISTEND, NULL, NULL)) {
-			struct aa_profile *subprofile;
-			subprofile = aa_activate_profile(e, error);
+		while (!aais_nameX(e, AALISTEND, NULL, NULL)) {
+			struct aaprofile *subprofile;
+			subprofile = aaactivate_profile(e, error);
 			if (!subprofile)
 				goto fail;
 			subprofile->parent = profile;
@@ -457,17 +457,17 @@ static struct aa_profile *aa_activate_pr
 	}
 
 	error_string = "Invalid end of profile";
-	AA_READ_X(e, AA_STRUCTEND, NULL, NULL);
+	AAREAD_X(e, AASTRUCTEND, NULL, NULL);
 
 	return profile;
 
 fail:
-	AA_WARN("%s: %s %s in profile %s\n", INTERFACE_ID, rulename,
+	AAWARN("%s: %s %s in profile %s\n", INTERFACE_ID, rulename,
 		error_string, profile && profile->name ? profile->name
 		: "unknown");
 
 	if (profile) {
-		free_aa_profile(profile);
+		free_aaprofile(profile);
 		profile = NULL;
 	}
 
@@ -475,33 +475,33 @@ fail:
 }
 
 /**
- * aa_activate_top_profile - unpack a serialized base profile
+ * aaactivate_top_profile - unpack a serialized base profile
  * @e: serialized data extent information
  * @error: error code returned if unpacking fails
  *
  * check interface version unpack a profile and all its hats and patch
  * in any extra information that the profile needs.
  */
-static void *aa_activate_top_profile(struct aa_ext *e, ssize_t *error)
+static void *aaactivate_top_profile(struct aaext *e, ssize_t *error)
 {
-	struct aa_profile *profile = NULL;
+	struct aaprofile *profile = NULL;
 
 	/* get the interface version */
-	if (!aa_is_nameX(e, AA_U32, &e->version, "version")) {
-		AA_WARN("%s: version missing\n", INTERFACE_ID);
+	if (!aais_nameX(e, AAU32, &e->version, "version")) {
+		AAWARN("%s: version missing\n", INTERFACE_ID);
 		*error = -EPROTONOSUPPORT;
 		goto fail;
 	}
 
 	/* check that the interface version is currently supported */
 	if (e->version != 3) {
-		AA_WARN("%s: unsupported interface version (%d)\n",
+		AAWARN("%s: unsupported interface version (%d)\n",
 			INTERFACE_ID, e->version);
 		*error = -EPROTONOSUPPORT;
 		goto fail;
 	}
 
-	profile = aa_activate_profile(e, error);
+	profile = aaactivate_profile(e, error);
 	if (!profile)
 		goto fail;
 
@@ -512,44 +512,44 @@ static void *aa_activate_top_profile(str
 	return profile;
 
 fail:
-	free_aa_profile(profile);
+	free_aaprofile(profile);
 	return NULL;
 }
 
 /**
- * aa_file_prof_add - add a new profile to the profile list
+ * aafile_prof_add - add a new profile to the profile list
  * @data: serialized data stream
  * @size: size of the serialized data stream
  *
  * unpack and add a profile to the profile list.  Return %0 or error
  */
-ssize_t aa_file_prof_add(void *data, size_t size)
+ssize_t aafile_prof_add(void *data, size_t size)
 {
-	struct aa_profile *profile = NULL;
+	struct aaprofile *profile = NULL;
 
-	struct aa_ext e = {
+	struct aaext e = {
 		.start = data,
 		.end = data + size,
 		.pos = data
 	};
 	ssize_t error;
 
-	profile = aa_activate_top_profile(&e, &error);
+	profile = aaactivate_top_profile(&e, &error);
 	if (!profile) {
-		AA_DEBUG("couldn't activate profile\n");
+		AADEBUG("couldn't activate profile\n");
 		goto out;
 	}
 
-	/* aa_activate_top_profile allocates profile with initial 1 count
-	 * aa_profilelist_add transfers that ref to profile list without
+	/* aaactivate_top_profile allocates profile with initial 1 count
+	 * aaprofilelist_add transfers that ref to profile list without
 	 * further incrementing
 	 */
-	if (aa_profilelist_add(profile)) {
+	if (aaprofilelist_add(profile)) {
 		error = size;
 	} else {
-		AA_WARN("trying to add profile (%s) that already exists.\n",
+		AAWARN("trying to add profile (%s) that already exists.\n",
 			profile->name);
-		put_aa_profile(profile);
+		put_aaprofile(profile);
 		error = -EEXIST;
 	}
 
@@ -558,7 +558,7 @@ out:
 }
 
 /**
- * aa_file_prof_repl - replace a profile on the profile list
+ * aafile_prof_repl - replace a profile on the profile list
  * @udata: serialized data stream
  * @size: size of the serialized data stream
  *
@@ -566,10 +566,10 @@ out:
  * by any subdomain.  If the profile does not exist on the profile list
  * it is added.  Return %0 or error.
  */
-ssize_t aa_file_prof_repl(void *udata, size_t size)
+ssize_t aafile_prof_repl(void *udata, size_t size)
 {
-	struct aa_taskreplace_data data;
-	struct aa_ext e = {
+	struct aataskreplace_data data;
+	struct aaext e = {
 		.start = udata,
 		.end = udata + size,
 		.pos = udata
@@ -577,47 +577,47 @@ ssize_t aa_file_prof_repl(void *udata, s
 
 	ssize_t error;
 
-	data.new_profile = aa_activate_top_profile(&e, &error);
+	data.new_profile = aaactivate_top_profile(&e, &error);
 	if (!data.new_profile) {
-		AA_DEBUG("couldn't activate profile\n");
+		AADEBUG("couldn't activate profile\n");
 		goto out;
 	}
 
-	/* Refcount on data.new_profile is 1 (aa_activate_top_profile).
+	/* Refcount on data.new_profile is 1 (aaactivate_top_profile).
 	 *
-	 * This reference will be inherited by aa_profilelist_replace for it's
+	 * This reference will be inherited by aaprofilelist_replace for it's
 	 * profile list reference but this isn't sufficient.
 	 *
 	 * Another replace (*for-same-profile*) may race us here.
-	 * Task A calls aa_profilelist_replace(new_profile) and is interrupted.
-	 * Task B old_profile = aa_profilelist_replace() will return task A's
+	 * Task A calls aaprofilelist_replace(new_profile) and is interrupted.
+	 * Task B old_profile = aaprofilelist_replace() will return task A's
 	 * new_profile with the count of 1.  If task B proceeeds to put this
 	 * profile it will dissapear from under task A.
 	 *
 	 * Grab extra reference on new_profile to prevent this
 	 */
 
-	get_aa_profile(data.new_profile);
+	get_aaprofile(data.new_profile);
 
-	data.old_profile = aa_profilelist_replace(data.new_profile);
+	data.old_profile = aaprofilelist_replace(data.new_profile);
 
 	/* If there was an old profile,  find all currently executing tasks
 	 * using this profile and replace the old profile with the new.
 	 */
 	if (data.old_profile) {
-		AA_DEBUG("%s: try to replace profile (%p)%s\n",
+		AADEBUG("%s: try to replace profile (%p)%s\n",
 			 __FUNCTION__,
 			 data.old_profile,
 			 data.old_profile->name);
 
-		aa_subdomainlist_iterate(taskreplace_iter, (void *)&data);
+		aasubdomainlist_iterate(taskreplace_iter, (void *)&data);
 
 		/* it's off global list, and we are done replacing */
-		put_aa_profile(data.old_profile);
+		put_aaprofile(data.old_profile);
 	}
 
 	/* release extra reference obtained above (race) */
-	put_aa_profile(data.new_profile);
+	put_aaprofile(data.new_profile);
 
 	error = size;
 
@@ -626,30 +626,30 @@ out:
 }
 
 /**
- * aa_file_prof_remove - remove a profile from the system
+ * aafile_prof_remove - remove a profile from the system
  * @name: name of the profile to remove
  * @size: size of the name
  *
  * remove a profile from the profile list and all subdomain references
  * to said profile.  Return %0 on success, else error.
  */
-ssize_t aa_file_prof_remove(const char *name, size_t size)
+ssize_t aafile_prof_remove(const char *name, size_t size)
 {
-	struct aa_profile *old_profile;
+	struct aaprofile *old_profile;
 
 	/* if the old profile exists it will be removed from the list and
 	 * a reference is returned.
 	 */
-	old_profile = aa_profilelist_remove(name);
+	old_profile = aaprofilelist_remove(name);
 
 	if (old_profile) {
 		/* remove profile from any tasks using it */
-		aa_subdomainlist_iterate(taskremove_iter, (void *)old_profile);
+		aasubdomainlist_iterate(taskremove_iter, (void *)old_profile);
 
-		/* drop reference obtained by aa_profilelist_remove */
-		put_aa_profile(old_profile);
+		/* drop reference obtained by aaprofilelist_remove */
+		put_aaprofile(old_profile);
 	} else {
-		AA_WARN("%s: trying to remove profile (%s) that "
+		AAWARN("%s: trying to remove profile (%s) that "
 			"doesn't exist - skipping.\n", __FUNCTION__, name);
 		return -ENOENT;
 	}
@@ -658,58 +658,58 @@ ssize_t aa_file_prof_remove(const char *
 }
 
 /**
- * free_aa_profile_kref - free aa_profile by kref (called by put_aa_profile)
+ * free_aaprofile_kref - free aaprofile by kref (called by put_aaprofile)
  * @kr: kref callback for freeing of a profile
  */
-void free_aa_profile_kref(struct kref *kr)
+void free_aaprofile_kref(struct kref *kr)
 {
-	struct aa_profile *p=container_of(kr, struct aa_profile, count);
+	struct aaprofile *p=container_of(kr, struct aaprofile, count);
 
-	call_rcu(&p->rcu, free_aa_profile_rcu);
+	call_rcu(&p->rcu, free_aaprofile_rcu);
 }
 
 /**
- * free_aa_profile - free aa_profile structure
+ * free_aaprofile - free aaprofile structure
  * @profile: the profile to free
  *
  * free a profile, its file entries hats and null_profile.  All references
  * to the profile, its hats and null_profile must have been put.
- * If the profile was referenced by a subdomain free_aa_profile should be
+ * If the profile was referenced by a subdomain free_aaprofile should be
  * called from an rcu callback routine.
  */
-void free_aa_profile(struct aa_profile *profile)
+void free_aaprofile(struct aaprofile *profile)
 {
-	struct aa_profile *p, *ptmp;
+	struct aaprofile *p, *ptmp;
 
-	AA_DEBUG("%s(%p)\n", __FUNCTION__, profile);
+	AADEBUG("%s(%p)\n", __FUNCTION__, profile);
 
 	if (!profile)
 		return;
 
 	/* profile is still on global profile list -- invalid */
 	if (!list_empty(&profile->list)) {
-		AA_ERROR("%s: internal error, "
+		AAERROR("%s: internal error, "
 			 "profile '%s' still on global list\n",
 			 __FUNCTION__,
 			 profile->name);
 		BUG();
 	}
 
-	aa_match_free(profile->file_rules);
+	aamatch_free(profile->file_rules);
 
-	/* use free_aa_profile instead of put_aa_profile to destroy the
+	/* use free_aaprofile instead of put_aaprofile to destroy the
 	 * null_profile, because the null_profile use the same reference
 	 * counting as hats, ie. the count goes to the base profile.
 	 */
-	free_aa_profile(profile->null_profile);
+	free_aaprofile(profile->null_profile);
 	list_for_each_entry_safe(p, ptmp, &profile->sub, list) {
 		list_del_init(&p->list);
 		p->parent = NULL;
-		put_aa_profile(p);
+		put_aaprofile(p);
 	}
 
 	if (profile->name) {
-		AA_DEBUG("%s: %s\n", __FUNCTION__, profile->name);
+		AADEBUG("%s: %s\n", __FUNCTION__, profile->name);
 		kfree(profile->name);
 	}
 
Index: linux-2.6/security/apparmor/module_interface.h
===================================================================
--- linux-2.6.orig/security/apparmor/module_interface.h
+++ linux-2.6/security/apparmor/module_interface.h
@@ -2,33 +2,33 @@
 #define __MODULEINTERFACE_H
 
 /* Codes of the types of basic structures that are understood */
-#define AA_CODE_BYTE (sizeof(u8))
+#define AACODE_BYTE (sizeof(u8))
 #define INTERFACE_ID "INTERFACE"
 
 #define APPARMOR_INTERFACE_VERSION 2
 
-enum aa_code {
-	AA_U8,
-	AA_U16,
-	AA_U32,
-	AA_U64,
-	AA_NAME,	/* same as string except it is items name */
-	AA_DYN_STRING,
-	AA_STATIC_BLOB,
-	AA_STRUCT,
-	AA_STRUCTEND,
-	AA_LIST,
-	AA_LISTEND,
-	AA_OFFSET,
-	AA_BLOB_LOC,
-	AA_BAD
+enum aacode {
+	AAU8,
+	AAU16,
+	AAU32,
+	AAU64,
+	AANAME,	/* same as string except it is items name */
+	AADYN_STRING,
+	AASTATIC_BLOB,
+	AASTRUCT,
+	AASTRUCTEND,
+	AALIST,
+	AALISTEND,
+	AAOFFSET,
+	AABLOB_LOC,
+	AABAD
 };
 
-/* aa_ext tracks the kernel buffer and read position in it.  The interface
+/* aaext tracks the kernel buffer and read position in it.  The interface
  * data is copied into a kernel buffer in apparmorfs and then handed off to
  * the activate routines.
  */
-struct aa_ext {
+struct aaext {
 	void *start;
 	void *end;
 	void *pos;	/* pointer to current position in the buffer */
Index: linux-2.6/security/apparmor/procattr.c
===================================================================
--- linux-2.6.orig/security/apparmor/procattr.c
+++ linux-2.6/security/apparmor/procattr.c
@@ -15,7 +15,7 @@
 #include "apparmor.h"
 #include "inline.h"
 
-size_t aa_getprocattr(struct aa_profile *active, char *str, size_t size)
+size_t aagetprocattr(struct aaprofile *active, char *str, size_t size)
 {
 	int error = -EACCES;	/* default to a perm denied */
 	size_t len;
@@ -77,7 +77,7 @@ size_t aa_getprocattr(struct aa_profile 
 
 }
 
-int aa_setprocattr_changehat(char *hatinfo, size_t infosize)
+int aasetprocattr_changehat(char *hatinfo, size_t infosize)
 {
 	int error = -EINVAL;
 	char *token = NULL, *hat, *smagic, *tmp;
@@ -85,7 +85,7 @@ int aa_setprocattr_changehat(char *hatin
 	int rc, len, consumed;
 	unsigned long flags;
 
-	AA_DEBUG("%s: %p %zd\n", __FUNCTION__, hatinfo, infosize);
+	AADEBUG("%s: %p %zd\n", __FUNCTION__, hatinfo, infosize);
 
 	/* strip leading white space */
 	while (infosize && isspace(*hatinfo)) {
@@ -120,7 +120,7 @@ int aa_setprocattr_changehat(char *hatin
 	}
 
 	if (!*tmp || tmp == token) {
-		AA_WARN("%s: Invalid input '%s'\n", __FUNCTION__, token);
+		AAWARN("%s: Invalid input '%s'\n", __FUNCTION__, token);
 		goto out;
 	}
 
@@ -139,7 +139,7 @@ int aa_setprocattr_changehat(char *hatin
 	rc = sscanf(smagic, "%x%n", &magic, &consumed);
 
 	if (rc != 1 || consumed != len) {
-		AA_WARN("%s: Invalid hex magic %s\n",
+		AAWARN("%s: Invalid hex magic %s\n",
 			__FUNCTION__,
 			smagic);
 		goto out;
@@ -151,16 +151,16 @@ int aa_setprocattr_changehat(char *hatin
 		hat = NULL;
 
 	if (!hat && !magic) {
-		AA_WARN("%s: Invalid input, NULL hat and NULL magic\n",
+		AAWARN("%s: Invalid input, NULL hat and NULL magic\n",
 			__FUNCTION__);
 		goto out;
 	}
 
-	AA_DEBUG("%s: Magic 0x%x Hat '%s'\n",
+	AADEBUG("%s: Magic 0x%x Hat '%s'\n",
 		 __FUNCTION__, magic, hat ? hat : NULL);
 
 	spin_lock_irqsave(&sd_lock, flags);
-	error = aa_change_hat(hat, magic);
+	error = aachange_hat(hat, magic);
 	spin_unlock_irqrestore(&sd_lock, flags);
 
 out:
@@ -172,16 +172,16 @@ out:
 	return error;
 }
 
-int aa_setprocattr_setprofile(struct task_struct *p, char *profilename,
+int aasetprocattr_setprofile(struct task_struct *p, char *profilename,
 			      size_t profilesize)
 {
 	int error = -EINVAL;
-	struct aa_profile *profile = NULL;
+	struct aaprofile *profile = NULL;
 	struct subdomain *sd;
 	char *name = NULL;
 	unsigned long flags;
 
-	AA_DEBUG("%s: current %s(%d)\n",
+	AADEBUG("%s: current %s(%d)\n",
 		 __FUNCTION__, current->comm, current->pid);
 
 	/* strip leading white space */
@@ -209,9 +209,9 @@ int aa_setprocattr_setprofile(struct tas
 
  repeat:
 	if (strcmp(name, "unconstrained") != 0) {
-		profile = aa_profilelist_find(name);
+		profile = aaprofilelist_find(name);
 		if (!profile) {
-			AA_WARN("%s: Unable to switch task %s(%d) to profile"
+			AAWARN("%s: Unable to switch task %s(%d) to profile"
 				"'%s'. No such profile.\n",
 				__FUNCTION__,
 				p->comm, p->pid,
@@ -224,21 +224,21 @@ int aa_setprocattr_setprofile(struct tas
 
 	spin_lock_irqsave(&sd_lock, flags);
 
-	sd = AA_SUBDOMAIN(p->security);
+	sd = AASUBDOMAIN(p->security);
 
 	/* switch to unconstrained */
 	if (!profile) {
-		if (__aa_is_confined(sd)) {
-			AA_WARN("%s: Unconstraining task %s(%d) "
+		if (__aais_confined(sd)) {
+			AAWARN("%s: Unconstraining task %s(%d) "
 				"profile %s active %s\n",
 				__FUNCTION__,
 				p->comm, p->pid,
 				BASE_PROFILE(sd->active)->name,
 				sd->active->name);
 
-			aa_switch_unconfined(sd);
+			aaswitch_unconfined(sd);
 		} else {
-			AA_WARN("%s: task %s(%d) "
+			AAWARN("%s: task %s(%d) "
 				"is already unconstrained\n",
 				__FUNCTION__, p->comm, p->pid);
 		}
@@ -247,7 +247,7 @@ int aa_setprocattr_setprofile(struct tas
 			/* this task was created before module was
 			 * loaded, allocate a subdomain
 			 */
-			AA_WARN("%s: task %s(%d) has no subdomain\n",
+			AAWARN("%s: task %s(%d) has no subdomain\n",
 				__FUNCTION__, p->comm, p->pid);
 
 			/* unlock so we can safely GFP_KERNEL */
@@ -255,7 +255,7 @@ int aa_setprocattr_setprofile(struct tas
 
 			sd = alloc_subdomain(p);
 			if (!sd) {
-				AA_WARN("%s: Unable to allocate subdomain for "
+				AAWARN("%s: Unable to allocate subdomain for "
 					"task %s(%d). Cannot confine task to "
 					"profile %s\n",
 					__FUNCTION__,
@@ -263,17 +263,17 @@ int aa_setprocattr_setprofile(struct tas
 					name);
 
 				error = -ENOMEM;
-				put_aa_profile(profile);
+				put_aaprofile(profile);
 
 				goto out;
 			}
 
 			spin_lock_irqsave(&sd_lock, flags);
-			if (!AA_SUBDOMAIN(p->security)) {
+			if (!AASUBDOMAIN(p->security)) {
 				p->security = sd;
 			} else { /* race */
 				free_subdomain(sd);
-				sd = AA_SUBDOMAIN(p->security);
+				sd = AASUBDOMAIN(p->security);
 			}
 		}
 
@@ -282,9 +282,9 @@ int aa_setprocattr_setprofile(struct tas
 		if (unlikely(profile->isstale)) {
 			WARN_ON(profile == null_complain_profile);
 
-			/* drop refcnt obtained from earlier get_aa_profile */
-			put_aa_profile(profile);
-			profile = aa_profilelist_find(name);
+			/* drop refcnt obtained from earlier get_aaprofile */
+			put_aaprofile(profile);
+			profile = aaprofilelist_find(name);
 
 			if (!profile) {
 				/* Race, profile was removed. */
@@ -300,7 +300,7 @@ int aa_setprocattr_setprofile(struct tas
 		 * profile has a identical named hat.
 		 */
 
-		AA_WARN("%s: Switching task %s(%d) "
+		AAWARN("%s: Switching task %s(%d) "
 			"profile %s active %s to new profile %s\n",
 			__FUNCTION__,
 			p->comm, p->pid,
@@ -309,15 +309,15 @@ int aa_setprocattr_setprofile(struct tas
 			sd->active ? sd->active->name : "unconstrained",
 			name);
 
-		aa_switch(sd, profile);
+		aaswitch(sd, profile);
 
-		put_aa_profile(profile); /* drop ref we obtained above
-					 * from aa_profilelist_find
+		put_aaprofile(profile); /* drop ref we obtained above
+					 * from aaprofilelist_find
 					 */
 
 		/* Reset magic in case we were in a subhat before
 		 * This is the only case where we zero the magic after
-		 * calling aa_switch
+		 * calling aaswitch
 		 */
 		sd->hat_magic = 0;
 	}
Index: linux-2.6/security/apparmor/shared.h
===================================================================
--- linux-2.6.orig/security/apparmor/shared.h
+++ linux-2.6/security/apparmor/shared.h
@@ -13,39 +13,39 @@
 #define _SHARED_H
 
 /* start of system offsets */
-#define POS_AA_FILE_MIN			0
-#define POS_AA_MAY_EXEC			POS_AA_FILE_MIN
-#define POS_AA_MAY_WRITE		(POS_AA_MAY_EXEC + 1)
-#define POS_AA_MAY_READ			(POS_AA_MAY_WRITE + 1)
-#define POS_AA_MAY_APPEND		(POS_AA_MAY_READ + 1)
+#define POS_AAFILE_MIN			0
+#define POS_AAMAY_EXEC			POS_AAFILE_MIN
+#define POS_AAMAY_WRITE		(POS_AAMAY_EXEC + 1)
+#define POS_AAMAY_READ			(POS_AAMAY_WRITE + 1)
+#define POS_AAMAY_APPEND		(POS_AAMAY_READ + 1)
 /* end of system offsets */
 
-#define POS_AA_MAY_LINK			(POS_AA_MAY_APPEND + 1)
-#define POS_AA_EXEC_INHERIT		(POS_AA_MAY_LINK + 1)
-#define POS_AA_EXEC_UNCONSTRAINED	(POS_AA_EXEC_INHERIT + 1)
-#define POS_AA_EXEC_PROFILE		(POS_AA_EXEC_UNCONSTRAINED + 1)
-#define POS_AA_EXEC_MMAP		(POS_AA_EXEC_PROFILE + 1)
-#define POS_AA_EXEC_UNSAFE		(POS_AA_EXEC_MMAP + 1)
-#define POS_AA_FILE_MAX			POS_AA_EXEC_UNSAFE
+#define POS_AAMAY_LINK			(POS_AAMAY_APPEND + 1)
+#define POS_AAEXEC_INHERIT		(POS_AAMAY_LINK + 1)
+#define POS_AAEXEC_UNCONSTRAINED	(POS_AAEXEC_INHERIT + 1)
+#define POS_AAEXEC_PROFILE		(POS_AAEXEC_UNCONSTRAINED + 1)
+#define POS_AAEXEC_MMAP		(POS_AAEXEC_PROFILE + 1)
+#define POS_AAEXEC_UNSAFE		(POS_AAEXEC_MMAP + 1)
+#define POS_AAFILE_MAX			POS_AAEXEC_UNSAFE
 
 /* Invalid perm permission */
-#define POS_AA_INVALID_POS		31
+#define POS_AAINVALID_POS		31
 
 /* Modeled after MAY_READ, MAY_WRITE, MAY_EXEC def'ns */
-#define AA_MAY_EXEC			(0x01 << POS_AA_MAY_EXEC)
-#define AA_MAY_WRITE			(0x01 << POS_AA_MAY_WRITE)
-#define AA_MAY_READ			(0x01 << POS_AA_MAY_READ)
-#define AA_MAY_LINK			(0x01 << POS_AA_MAY_LINK)
-#define AA_EXEC_INHERIT			(0x01 << POS_AA_EXEC_INHERIT)
-#define AA_EXEC_UNCONSTRAINED		(0x01 << POS_AA_EXEC_UNCONSTRAINED)
-#define AA_EXEC_PROFILE			(0x01 << POS_AA_EXEC_PROFILE)
-#define AA_EXEC_MMAP			(0x01 << POS_AA_EXEC_MMAP)
-#define AA_EXEC_UNSAFE			(0x01 << POS_AA_EXEC_UNSAFE)
-#define AA_INVALID_PERM			(0x01 << POS_AA_INVALID_POS)
-
-#define AA_EXEC_MODIFIERS		(AA_EXEC_INHERIT | \
-					 AA_EXEC_UNCONSTRAINED | \
-					 AA_EXEC_PROFILE)
-#define AA_VALID_PERM_MASK		((1 << (POS_AA_FILE_MAX + 1)) - 1)
+#define AAMAY_EXEC			(0x01 << POS_AAMAY_EXEC)
+#define AAMAY_WRITE			(0x01 << POS_AAMAY_WRITE)
+#define AAMAY_READ			(0x01 << POS_AAMAY_READ)
+#define AAMAY_LINK			(0x01 << POS_AAMAY_LINK)
+#define AAEXEC_INHERIT			(0x01 << POS_AAEXEC_INHERIT)
+#define AAEXEC_UNCONSTRAINED		(0x01 << POS_AAEXEC_UNCONSTRAINED)
+#define AAEXEC_PROFILE			(0x01 << POS_AAEXEC_PROFILE)
+#define AAEXEC_MMAP			(0x01 << POS_AAEXEC_MMAP)
+#define AAEXEC_UNSAFE			(0x01 << POS_AAEXEC_UNSAFE)
+#define AAINVALID_PERM			(0x01 << POS_AAINVALID_POS)
+
+#define AAEXEC_MODIFIERS		(AAEXEC_INHERIT | \
+					 AAEXEC_UNCONSTRAINED | \
+					 AAEXEC_PROFILE)
+#define AAVALID_PERM_MASK		((1 << (POS_AAFILE_MAX + 1)) - 1)
 
 #endif /* _SHARED_H */
Index: linux-2.6/security/apparmor/lsm.c
===================================================================
--- linux-2.6.orig/security/apparmor/lsm.c
+++ linux-2.6/security/apparmor/lsm.c
@@ -66,15 +66,15 @@ MODULE_PARM_DESC(apparmor_logsyscall, "T
 static int apparmor_ptrace(struct task_struct *parent,
 			    struct task_struct *child)
 {
-	struct aa_profile *active = get_task_active_aa_profile(parent);
+	struct aaprofile *active = get_task_active_aaprofile(parent);
 	int error = cap_ptrace(parent, child);
 
 	if (!error && active) {
-		error = aa_audit_syscallreject(active, GFP_KERNEL, "ptrace");
+		error = aaaudit_syscallreject(active, GFP_KERNEL, "ptrace");
 		WARN_ON(error != -EPERM);
 	}
 
-	put_aa_profile(active);
+	put_aaprofile(active);
 
 	return error;
 }
@@ -112,12 +112,12 @@ static int apparmor_capable(struct task_
 	error = cap_capable(tsk, cap);
 
 	if (error == 0) {
-		struct aa_profile *active = get_task_active_aa_profile(tsk);
+		struct aaprofile *active = get_task_active_aaprofile(tsk);
 
 		if (active)
-			error = aa_capability(active, cap);
+			error = aacapability(active, cap);
 
-		put_aa_profile(active);
+		put_aaprofile(active);
 	}
 
 	return error;
@@ -126,15 +126,15 @@ static int apparmor_capable(struct task_
 static int apparmor_sysctl(struct ctl_table *table, int op)
 {
 	int error = 0;
-	struct aa_profile *active = get_active_aa_profile();
+	struct aaprofile *active = get_active_aaprofile();
 
 	if ((op & 002) && active && !capable(CAP_SYS_ADMIN)) {
-		error = aa_audit_syscallreject(active, GFP_KERNEL,
+		error = aaaudit_syscallreject(active, GFP_KERNEL,
 					       "sysctl (write)");
 		WARN_ON(error != -EPERM);
 	}
 
-	put_aa_profile(active);
+	put_aaprofile(active);
 
 	return error;
 }
@@ -167,7 +167,7 @@ static int apparmor_bprm_set_security(st
 	/* already set based on script name */
 	if (bprm->sh_bang)
 		return 0;
-	return aa_register(bprm);
+	return aaregister(bprm);
 }
 
 static int apparmor_bprm_secureexec(struct linux_binprm *bprm)
@@ -175,8 +175,8 @@ static int apparmor_bprm_secureexec(stru
 	int ret = cap_bprm_secureexec(bprm);
 
 	if (ret == 0 &&
-	    (unsigned long)bprm->security & AA_SECURE_EXEC_NEEDED) {
-		AA_DEBUG("%s: secureexec required for %s\n",
+	    (unsigned long)bprm->security & AASECURE_EXEC_NEEDED) {
+		AADEBUG("%s: secureexec required for %s\n",
 			 __FUNCTION__, bprm->filename);
 		ret = 1;
 	}
@@ -188,17 +188,17 @@ static int apparmor_sb_mount(char *dev_n
 			      unsigned long flags, void *data)
 {
 	int error = 0;
-	struct aa_profile *active = get_active_aa_profile();
+	struct aaprofile *active = get_active_aaprofile();
 
 	if (active) {
-		error = aa_audit_syscallreject(active, GFP_KERNEL, "mount");
+		error = aaaudit_syscallreject(active, GFP_KERNEL, "mount");
 		WARN_ON(error != -EPERM);
 	} else {
-		AA_ERROR("labelling volume %s\n", nd->mnt->mnt_sb->s_id);
-		nd->mnt->mnt_sb->s_security = AA_MEDIATE_FS;
+		AAERROR("labelling volume %s\n", nd->mnt->mnt_sb->s_id);
+		nd->mnt->mnt_sb->s_security = AAMEDIATE_FS;
 	}
 
-	put_aa_profile(active);
+	put_aaprofile(active);
 
 	return error;
 }
@@ -206,16 +206,16 @@ static int apparmor_sb_mount(char *dev_n
 static int apparmor_umount(struct vfsmount *mnt, int flags)
 {
 	int error = 0;
-	struct aa_profile *active = get_active_aa_profile();
+	struct aaprofile *active = get_active_aaprofile();
 
 	if (active) {
-		error = aa_audit_syscallreject(active, GFP_ATOMIC, "umount");
+		error = aaaudit_syscallreject(active, GFP_ATOMIC, "umount");
 		WARN_ON(error != -EPERM);
 	} else {
 		mnt->mnt_sb->s_security = NULL;
 	}
 
-	put_aa_profile(active);
+	put_aaprofile(active);
 
 	return error;
 }
@@ -225,14 +225,14 @@ static int apparmor_inode_mkdir(struct i
 {
 	int error = 0;
 
-	if (mnt && dir->i_sb->s_security == AA_MEDIATE_FS) {
-		struct aa_profile *active = get_active_aa_profile();
+	if (mnt && dir->i_sb->s_security == AAMEDIATE_FS) {
+		struct aaprofile *active = get_active_aaprofile();
 
 		if (active)
-			error = aa_perm_dir(active, dentry, mnt, "mkdir",
-					    AA_MAY_WRITE);
+			error = aaperm_dir(active, dentry, mnt, "mkdir",
+					    AAMAY_WRITE);
 
-		put_aa_profile(active);
+		put_aaprofile(active);
 	}
 
 	return error;
@@ -243,14 +243,14 @@ static int apparmor_inode_rmdir(struct i
 {
 	int error = 0;
 
-	if (mnt && dir->i_sb->s_security == AA_MEDIATE_FS) {
-		struct aa_profile *active = get_active_aa_profile();
+	if (mnt && dir->i_sb->s_security == AAMEDIATE_FS) {
+		struct aaprofile *active = get_active_aaprofile();
 
 		if (active)
-			error = aa_perm_dir(active, dentry, mnt, "rmdir",
-					    AA_MAY_WRITE);
+			error = aaperm_dir(active, dentry, mnt, "rmdir",
+					    AAMAY_WRITE);
 
-		put_aa_profile(active);
+		put_aaprofile(active);
 	}
 
 	return error;
@@ -262,13 +262,13 @@ static int apparmor_inode_create(struct 
 	int error = 0;
 
 	if (mnt) {
-		struct aa_profile *active = get_active_aa_profile();
+		struct aaprofile *active = get_active_aaprofile();
 
 		/* At a minimum, need write perm to create */
 		if (active)
-			error = aa_perm(active, dentry, mnt, MAY_WRITE);
+			error = aaperm(active, dentry, mnt, MAY_WRITE);
 
-		put_aa_profile(active);
+		put_aaprofile(active);
 	}
 
 	return error;
@@ -281,14 +281,14 @@ static int apparmor_inode_link(struct de
 {
 	int error = 0;
 
-	if (old_mnt && new_mnt && dir->i_sb->s_security == AA_MEDIATE_FS) {
-		struct aa_profile *active = get_active_aa_profile();
+	if (old_mnt && new_mnt && dir->i_sb->s_security == AAMEDIATE_FS) {
+		struct aaprofile *active = get_active_aaprofile();
 
 		if (active)
-			error = aa_link(active, new_dentry, new_mnt,
+			error = aalink(active, new_dentry, new_mnt,
 					old_dentry, old_mnt);
 
-		put_aa_profile(active);
+		put_aaprofile(active);
 	}
 
 	return error;
@@ -300,13 +300,13 @@ static int apparmor_inode_unlink(struct 
 {
 	int error = 0;
 
-	if (mnt && dentry->d_inode->i_sb->s_security == AA_MEDIATE_FS) {
-		struct aa_profile *active = get_active_aa_profile();
+	if (mnt && dentry->d_inode->i_sb->s_security == AAMEDIATE_FS) {
+		struct aaprofile *active = get_active_aaprofile();
 
 		if (active)
-			error = aa_perm(active, dentry, mnt, MAY_WRITE);
+			error = aaperm(active, dentry, mnt, MAY_WRITE);
 
-		put_aa_profile(active);
+		put_aaprofile(active);
 	}
 
 	return error;
@@ -317,13 +317,13 @@ static int apparmor_inode_mknod(struct i
 {
 	int error = 0;
 
-	if (mnt && dir->i_sb->s_security == AA_MEDIATE_FS) {
-		struct aa_profile *active = get_active_aa_profile();
+	if (mnt && dir->i_sb->s_security == AAMEDIATE_FS) {
+		struct aaprofile *active = get_active_aaprofile();
 
 		if (active)
-			error = aa_perm(active, dentry, mnt, MAY_WRITE);
+			error = aaperm(active, dentry, mnt, MAY_WRITE);
 
-		put_aa_profile(active);
+		put_aaprofile(active);
 	}
 
 	return error;
@@ -336,26 +336,26 @@ static int apparmor_inode_rename(struct 
 				 struct dentry *new_dentry,
 				 struct vfsmount *new_mnt)
 {
-	struct aa_profile *active;
+	struct aaprofile *active;
 	int error = 0;
 
 	if (!old_mnt && !new_mnt)
 		goto out;
 
-	active = get_active_aa_profile();
+	active = get_active_aaprofile();
 
 	if (active) {
-		if (old_mnt && old_dir->i_sb->s_security == AA_MEDIATE_FS)
-			error = aa_perm(active, old_dentry, old_mnt,
+		if (old_mnt && old_dir->i_sb->s_security == AAMEDIATE_FS)
+			error = aaperm(active, old_dentry, old_mnt,
 					MAY_READ|MAY_WRITE);
 
 		if (!error && new_mnt &&
-		    new_dir->i_sb->s_security == AA_MEDIATE_FS)
-			error = aa_perm(active, new_dentry, new_mnt,
+		    new_dir->i_sb->s_security == AAMEDIATE_FS)
+			error = aaperm(active, new_dentry, new_mnt,
 					MAY_WRITE);
 	}
 
-	put_aa_profile(active);
+	put_aaprofile(active);
 
 out:
 	return error;
@@ -369,12 +369,12 @@ static int apparmor_inode_permission(str
 	/* Do not perform check on pipes or sockets
 	 * Same as apparmor_file_permission
 	 */
-	if (nd && inode->i_sb->s_security == AA_MEDIATE_FS) {
-		struct aa_profile *active = get_active_aa_profile();
+	if (nd && inode->i_sb->s_security == AAMEDIATE_FS) {
+		struct aaprofile *active = get_active_aaprofile();
 
 		if (active)
-			error = aa_perm(active, nd->dentry, nd->mnt, mask);
-		put_aa_profile(active);
+			error = aaperm(active, nd->dentry, nd->mnt, mask);
+		put_aaprofile(active);
 	}
 
 	return error;
@@ -385,17 +385,17 @@ static int apparmor_inode_setattr(struct
 {
 	int error = 0;
 
-	if (mnt && dentry->d_inode->i_sb->s_security == AA_MEDIATE_FS) {
-		struct aa_profile *active = get_active_aa_profile();
+	if (mnt && dentry->d_inode->i_sb->s_security == AAMEDIATE_FS) {
+		struct aaprofile *active = get_active_aaprofile();
 
 		/*
 		 * Mediate any attempt to change attributes of a file
 		 * (chmod, chown, chgrp, etc)
 		 */
 		if (active)
-			error = aa_attr(active, dentry, mnt, iattr);
+			error = aaattr(active, dentry, mnt, iattr);
 
-		put_aa_profile(active);
+		put_aaprofile(active);
 	}
 
 	return error;
@@ -407,12 +407,12 @@ static int apparmor_inode_setxattr(struc
 {
 	int error = 0;
 
-	if (mnt && dentry->d_inode->i_sb->s_security == AA_MEDIATE_FS) {
-		struct aa_profile *active = get_active_aa_profile();
+	if (mnt && dentry->d_inode->i_sb->s_security == AAMEDIATE_FS) {
+		struct aaprofile *active = get_active_aaprofile();
 		if (active)
-			error = aa_perm_xattr(active, dentry, mnt, name,
-					      "xattr set", AA_MAY_WRITE);
-		put_aa_profile(active);
+			error = aaperm_xattr(active, dentry, mnt, name,
+					      "xattr set", AAMAY_WRITE);
+		put_aaprofile(active);
 	}
 
 	return error;
@@ -423,13 +423,13 @@ static int apparmor_inode_getxattr(struc
 {
 	int error = 0;
 
-	if (mnt && dentry->d_inode->i_sb->s_security == AA_MEDIATE_FS) {
-		struct aa_profile *active = get_active_aa_profile();
+	if (mnt && dentry->d_inode->i_sb->s_security == AAMEDIATE_FS) {
+		struct aaprofile *active = get_active_aaprofile();
 
 		if (active)
-			error = aa_perm_xattr(active, dentry, mnt, name,
-					      "xattr get", AA_MAY_READ);
-		put_aa_profile(active);
+			error = aaperm_xattr(active, dentry, mnt, name,
+					      "xattr get", AAMAY_READ);
+		put_aaprofile(active);
 	}
 
 	return error;
@@ -438,13 +438,13 @@ static int apparmor_inode_listxattr(stru
 {
 	int error = 0;
 
-	if (mnt && dentry->d_inode->i_sb->s_security == AA_MEDIATE_FS) {
-		struct aa_profile *active = get_active_aa_profile();
+	if (mnt && dentry->d_inode->i_sb->s_security == AAMEDIATE_FS) {
+		struct aaprofile *active = get_active_aaprofile();
 
 		if (active)
-			error = aa_perm_xattr(active, dentry, mnt, NULL,
-					      "xattr list", AA_MAY_READ);
-		put_aa_profile(active);
+			error = aaperm_xattr(active, dentry, mnt, NULL,
+					      "xattr list", AAMAY_READ);
+		put_aaprofile(active);
 	}
 
 	return error;
@@ -455,13 +455,13 @@ static int apparmor_inode_removexattr(st
 {
 	int error = 0;
 
-	if (mnt && dentry->d_inode->i_sb->s_security == AA_MEDIATE_FS) {
-		struct aa_profile *active = get_active_aa_profile();
+	if (mnt && dentry->d_inode->i_sb->s_security == AAMEDIATE_FS) {
+		struct aaprofile *active = get_active_aaprofile();
 
 		if (active)
-			error = aa_perm_xattr(active, dentry, mnt, name,
-					      "xattr remove", AA_MAY_WRITE);
-		put_aa_profile(active);
+			error = aaperm_xattr(active, dentry, mnt, name,
+					      "xattr remove", AAMAY_WRITE);
+		put_aaprofile(active);
 	}
 
 	return error;
@@ -471,15 +471,15 @@ static int apparmor_file_permission(stru
 {
 	int error = 0;
 
-	if (file->f_vfsmnt->mnt_sb->s_security == AA_MEDIATE_FS &&
+	if (file->f_vfsmnt->mnt_sb->s_security == AAMEDIATE_FS &&
 	    file->f_security) {
-		struct aa_profile *active = get_active_aa_profile();
+		struct aaprofile *active = get_active_aaprofile();
 
 		/* FIXME: Q: what's going on here? */
-		if (active && (struct aa_profile*)file->f_security != active)
-			error = aa_perm(active, file->f_dentry, file->f_vfsmnt,
+		if (active && (struct aaprofile*)file->f_security != active)
+			error = aaperm(active, file->f_dentry, file->f_vfsmnt,
 					mask & (MAY_EXEC|MAY_WRITE|MAY_READ));
-		put_aa_profile(active);
+		put_aaprofile(active);
 	}
 
 	return error;
@@ -487,30 +487,30 @@ static int apparmor_file_permission(stru
 
 static int apparmor_file_alloc_security(struct file *file)
 {
-	struct aa_profile *active = get_active_aa_profile();
+	struct aaprofile *active = get_active_aaprofile();
 
 	if (active)
-		file->f_security = get_aa_profile(active);
+		file->f_security = get_aaprofile(active);
 
-	put_aa_profile(active);
+	put_aaprofile(active);
 
 	return 0;
 }
 
 static void apparmor_file_free_security(struct file *file)
 {
-	put_aa_profile((struct aa_profile *)file->f_security);
+	put_aaprofile((struct aaprofile *)file->f_security);
 }
 
-static inline int aa_mmap(struct file *file, unsigned long prot,
+static inline int aammap(struct file *file, unsigned long prot,
 			  unsigned long flags)
 {
 	int error = 0, mask = 0;
-	struct aa_profile *active;
+	struct aaprofile *active;
 
-	if (!file || file->f_vfsmnt->mnt_sb->s_security != AA_MEDIATE_FS)
+	if (!file || file->f_vfsmnt->mnt_sb->s_security != AAMEDIATE_FS)
 		goto out;
-	active = get_active_aa_profile();
+	active = get_active_aaprofile();
 	if (!active)
 		goto out;
 
@@ -523,12 +523,12 @@ static inline int aa_mmap(struct file *f
 	if ((prot & PROT_WRITE) && !(flags & MAP_PRIVATE))
 		mask |= MAY_WRITE;
 	if (prot & PROT_EXEC)
-		mask |= AA_EXEC_MMAP;
+		mask |= AAEXEC_MMAP;
 
 	if (mask)
-		error = aa_perm(active, file->f_dentry, file->f_vfsmnt, mask);
+		error = aaperm(active, file->f_dentry, file->f_vfsmnt, mask);
 
-	put_aa_profile(active);
+	put_aaprofile(active);
 
 out:
 	return error;
@@ -537,24 +537,24 @@ out:
 static int apparmor_file_mmap(struct file *file, unsigned long reqprot,
 			       unsigned long prot, unsigned long flags)
 {
-	return aa_mmap(file, prot, flags);
+	return aammap(file, prot, flags);
 }
 
 static int apparmor_file_mprotect(struct vm_area_struct *vma,
 				  unsigned long reqprot, unsigned long prot)
 {
-	return aa_mmap(vma->vm_file, prot,
+	return aammap(vma->vm_file, prot,
 		       !(vma->vm_flags & VM_SHARED) ? MAP_PRIVATE : 0);
 }
 
 static int apparmor_task_alloc_security(struct task_struct *task)
 {
-	return aa_fork(task);
+	return aafork(task);
 }
 
 static void apparmor_task_free_security(struct task_struct *task)
 {
-	aa_release(task);
+	aarelease(task);
 }
 
 static int apparmor_task_post_setuid(uid_t id0, uid_t id1, uid_t id2,
@@ -580,9 +580,9 @@ static int apparmor_getprocattr(struct t
 
 	error = -EPERM;
 	if (task == current || capable(CAP_SYS_ADMIN)) {
-		struct aa_profile *active = get_task_active_aa_profile(task);
-		error = aa_getprocattr(active, (char *) value, size);
-		put_aa_profile(active);
+		struct aaprofile *active = get_task_active_aaprofile(task);
+		error = aagetprocattr(active, (char *) value, size);
+		put_aaprofile(active);
 	}
 
 	return error;
@@ -612,7 +612,7 @@ static int apparmor_setprocattr(struct t
 
 		/* Only the current process may change it's hat */
 		if (current != task) {
-			AA_WARN("%s: Attempt by foreign task %s(%d) "
+			AAWARN("%s: Attempt by foreign task %s(%d) "
 				"[user %d] to changehat of task %s(%d)\n",
 				__FUNCTION__,
 				current->comm,
@@ -625,21 +625,21 @@ static int apparmor_setprocattr(struct t
 			goto out;
 		}
 
-		error = aa_setprocattr_changehat(hatinfo, infosize);
+		error = aasetprocattr_changehat(hatinfo, infosize);
 		if (error == 0)
 			error = size;
 
 	/* SET NEW PROFILE */
 	} else if (size > strlen(cmd_setprofile) &&
 		   strncmp(cmd, cmd_setprofile, strlen(cmd_setprofile)) == 0) {
-		struct aa_profile *active;
+		struct aaprofile *active;
 
 		/* only an unconfined process with admin capabilities
 		 * may change the profile of another task
 		 */
 
 		if (!capable(CAP_SYS_ADMIN)) {
-			AA_WARN("%s: Unprivileged attempt by task %s(%d) "
+			AAWARN("%s: Unprivileged attempt by task %s(%d) "
 				"[user %d] to assign profile to task %s(%d)\n",
 				__FUNCTION__,
 				current->comm,
@@ -651,19 +651,19 @@ static int apparmor_setprocattr(struct t
 			goto out;
 		}
 
-		active = get_active_aa_profile();
+		active = get_active_aaprofile();
 		if (!active) {
 			char *profile = cmd + strlen(cmd_setprofile);
 			size_t profilesize = size - strlen(cmd_setprofile);
 
-			error = aa_setprocattr_setprofile(task, profile, profilesize);
+			error = aasetprocattr_setprofile(task, profile, profilesize);
 			if (error == 0)
 				/* success,
 				 * set return to #bytes in orig request
 				 */
 				error = size;
 		} else {
-			AA_WARN("%s: Attempt by confined task %s(%d) "
+			AAWARN("%s: Attempt by confined task %s(%d) "
 				"[user %d] to assign profile to task %s(%d)\n",
 				__FUNCTION__,
 				current->comm,
@@ -674,10 +674,10 @@ static int apparmor_setprocattr(struct t
 
 			error = -EACCES;
 		}
-		put_aa_profile(active);
+		put_aaprofile(active);
 	} else {
 		/* unknown operation */
-		AA_WARN("%s: Unknown setprocattr command '%.*s' by task %s(%d) "
+		AAWARN("%s: Unknown setprocattr command '%.*s' by task %s(%d) "
 			"[user %d] for task %s(%d)\n",
 			__FUNCTION__,
 			size < 16 ? (int)size : 16,
@@ -748,28 +748,28 @@ static int __init apparmor_init(void)
 	const char *complainmsg = ": complainmode enabled";
 
 	if (!apparmor_enabled) {
-		AA_INFO("AppArmor: Disabled by boottime parameter\n");
+		AAINFO("AppArmor: Disabled by boottime parameter\n");
 		return 0;
 	}
 
 	if ((error = create_apparmorfs())) {
-		AA_ERROR("Unable to activate AppArmor filesystem\n");
+		AAERROR("Unable to activate AppArmor filesystem\n");
 		goto createfs_out;
 	}
 
 	if ((error = alloc_null_complain_profile())){
-		AA_ERROR("Unable to allocate null complain profile\n");
+		AAERROR("Unable to allocate null complain profile\n");
 		goto alloc_out;
 	}
 
 	if ((error = register_security(&apparmor_ops))) {
-		AA_ERROR("Unable to load AppArmor\n");
+		AAERROR("Unable to load AppArmor\n");
 		goto register_security_out;
 	}
 
-	AA_INFO("AppArmor initialized%s\n",
+	AAINFO("AppArmor initialized%s\n",
 		apparmor_complain ? complainmsg : "");
-	aa_audit_message(NULL, GFP_KERNEL, 0,
+	aaaudit_message(NULL, GFP_KERNEL, 0,
 		"AppArmor initialized%s\n",
 		apparmor_complain ? complainmsg : "");
 
