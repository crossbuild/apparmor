Index: b/security/apparmor/main.c
===================================================================
--- a/security/apparmor/main.c
+++ b/security/apparmor/main.c
@@ -12,6 +12,7 @@
 #include <linux/security.h>
 #include <linux/namei.h>
 #include <linux/audit.h>
+#include <linux/mount.h>
 
 #include "apparmor.h"
 
@@ -486,38 +487,20 @@ out:
  * @mnt: where in tree
  *
  * Returns fully qualified path name on sucess, NULL on failure.
- * aa_put_name must be used to free allocated buffer.
+ * aa_put_name must be used to free the allocated buffer.
  */
 char *aa_get_name(struct dentry *dentry, struct vfsmount *mnt)
 {
 	char *page, *name;
 
 	page = (char *)__get_free_page(GFP_KERNEL);
-	if (!page) {
-		name = ERR_PTR(-ENOMEM);
-		goto out;
-	}
+	if (!page)
+		return ERR_PTR(-ENOMEM);
 
-	name = d_path(dentry, mnt, page, PAGE_SIZE);
-	/* check for (deleted) that d_path appends to pathnames if the dentry
-	 * has been removed from the cache.
-	 * The size > deleted_size and strcmp checks are redundant safe guards.
-	 */
-	if (IS_ERR(name)) {
+	name = d_namespace_path(dentry, mnt, page, PAGE_SIZE);
+	if (IS_ERR(name))
 		free_page((unsigned long)page);
-	} else {
-		const char deleted_str[] = " (deleted)";
-		const size_t deleted_size = sizeof(deleted_str) - 1;
-		size_t size;
-		size = strlen(name);
-		if (!IS_ROOT(dentry) && d_unhashed(dentry) &&
-		    size > deleted_size &&
-		    strcmp(name + size - deleted_size, deleted_str) == 0)
-			name[size - deleted_size] = '\0';
-		AA_DEBUG("%s: full_path=%s\n", __FUNCTION__, name);
-	}
 
-out:
 	return name;
 }
 
