Index: linux-2.6/security/apparmor/match/Kbuild
===================================================================
--- linux-2.6.orig/security/apparmor/match/Kbuild
+++ linux-2.6/security/apparmor/match/Kbuild
@@ -1,6 +1,6 @@
 # Makefile for AppArmor aamatch submodule
 #
 
-obj-$(CONFIG_SECURITY_APPARMOR) += aamatch_pcre.o
+obj-$(CONFIG_SECURITY_APPARMOR) += aamatch_dfa.o
 
-aamatch_pcre-y := match_pcre.o pcre_exec.o
+aamatch_dfa-y := match_dfa.o
Index: linux-2.6/security/apparmor/match/match_dfa.c
===================================================================
--- /dev/null
+++ linux-2.6/security/apparmor/match/match_dfa.c
@@ -0,0 +1,398 @@
+/*
+ *	Copyright (C) 2002-2005 Novell/SUSE
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation, version 2 of the
+ *	License.
+ *
+ *	http://forge.novell.com/modules/xfmod/project/?apparmor
+ *
+ *	AppArmor aamatch submodule (w/ pattern expansion).
+ *
+ */
+
+#include <asm/unaligned.h>
+#include <linux/module.h>
+#include "match.h"
+
+static const char *features="literal tailglob pattern=aadfa";
+
+#define YYTH_MAGIC	0x1B5E783D
+
+struct table_set_header {
+	u32		th_magic;	/* TH_MAGIC */
+	u32		th_hsize;
+	u32		th_ssize;
+	u16		th_flags;
+	char		th_version[];
+};
+
+#define	YYTD_ID_ACCEPT	1 /* 1 */
+#define YYTD_ID_BASE	2 /* 2 */
+#define YYTD_ID_CHK	3 /* 3 */
+#define YYTD_ID_DEF	4 /* 4 */
+#define YYTD_ID_EC	5 /* 5 */
+#define YYTD_ID_NXT	6 /* 8 */
+#define YYTD_ID_META	7 /* 6 */
+
+#define YYTD_DATA8	1
+#define YYTD_DATA16	2
+#define YYTD_DATA32	4
+
+struct table_header {
+	u16		td_id;
+	u16		td_flags;
+	u32		td_hilen;
+	u32		td_lolen;
+	char		td_data[];
+};
+
+#define DEFAULT_TABLE(DFA) ((u16 *)((DFA)->tables[YYTD_ID_DEF - 1]->td_data))
+#define BASE_TABLE(DFA) ((u32 *)((DFA)->tables[YYTD_ID_BASE - 1]->td_data))
+#define NEXT_TABLE(DFA) ((u16 *)((DFA)->tables[YYTD_ID_NXT - 1]->td_data))
+#define CHECK_TABLE(DFA) ((u16 *)((DFA)->tables[YYTD_ID_CHK - 1]->td_data))
+#define EQUIV_TABLE(DFA) ((u8 *)((DFA)->tables[YYTD_ID_EC - 1]->td_data))
+#define ACCEPT_TABLE(DFA) ((u32 *)((DFA)->tables[YYTD_ID_ACCEPT - 1]->td_data))
+
+struct aa_dfa {
+	struct table_header *tables[YYTD_ID_NXT];
+
+	struct table_set_header th;
+};
+
+#define ntohb(X) (X)
+
+#define UNPACK_ARRAY(TABLE, BLOB, LEN, TYPE, NTOHX) \
+	do { \
+		typeof(LEN) __i; \
+		TYPE *__t = (TYPE *) TABLE; \
+		TYPE *__b = (TYPE *) BLOB; \
+		for (__i = 0; __i < LEN; __i++) { \
+			__t[__i] = NTOHX(__b[__i]); \
+		} \
+	} while (0)
+
+static inline size_t pad64(size_t i)
+{
+	return (i + (size_t)7) & ~(size_t)7;
+}
+
+static inline size_t table_size(size_t len, size_t el_size)
+{
+	return pad64(sizeof(struct table_header) + len * el_size);
+}
+
+static struct table_header *unpack_table(void *blob, size_t bsize)
+{
+	struct table_header *table = NULL;
+	struct table_header th;
+	size_t tsize;
+
+	if (bsize < sizeof(struct table_header))
+		goto out;
+
+	th.td_id = ntohs(get_unaligned((u16 *) (blob)));
+	th.td_flags = ntohs(get_unaligned((u16 *) (blob + 2)));
+	th.td_lolen = ntohl(get_unaligned((u32 *) (blob + 8)));
+	blob += sizeof(struct table_header);
+
+	if (!(th.td_flags == YYTD_DATA16 || th.td_flags == YYTD_DATA32 ||
+		th.td_flags == YYTD_DATA8))
+		goto out;
+
+	tsize = table_size(th.td_lolen, th.td_flags);
+	if (bsize < tsize)
+		goto out;
+
+	table = kmalloc(tsize, GFP_KERNEL);
+	if (table) {
+		*table = th;
+		if (th.td_flags == YYTD_DATA8)
+			UNPACK_ARRAY(table->td_data, blob, th.td_lolen,
+				     u8, ntohb);
+		else if (th.td_flags == YYTD_DATA16)
+			UNPACK_ARRAY(table->td_data, blob, th.td_lolen,
+				     u16, ntohs);
+		else
+			UNPACK_ARRAY(table->td_data, blob, th.td_lolen,
+				     u32, ntohl);
+	}
+
+out:
+	return table;
+}
+
+static int unpack_dfa(struct aa_dfa *dfa, void *blob, size_t size)
+{
+	int i;
+	int error = -ENOMEM;
+
+	/* get dfa table set header */
+	if (size < sizeof(struct table_set_header))
+		goto fail;
+
+	dfa->th.th_magic = ntohl(get_unaligned((u32 *) (blob + 0)));
+	dfa->th.th_hsize = ntohl(get_unaligned((u32 *) (blob + 4)));
+	dfa->th.th_ssize = ntohl(get_unaligned((u32 *) (blob + 8)));
+	dfa->th.th_flags = ntohs(get_unaligned((u16 *) (blob + 12)));
+
+	if (dfa->th.th_magic != YYTH_MAGIC)
+		goto fail;
+
+	if (size < dfa->th.th_hsize)
+		goto fail;
+
+	blob += dfa->th.th_hsize;
+	size -= dfa->th.th_hsize;
+
+	while (size > 0) {
+		struct table_header *table;
+		table = unpack_table(blob, size);
+		if (!table)
+			goto fail;
+
+		switch(table->td_id) {
+		case YYTD_ID_ACCEPT:
+		case YYTD_ID_BASE:
+			dfa->tables[table->td_id - 1] = table;
+			if (table->td_flags != YYTD_DATA32)
+				goto fail_proto;
+			break;
+		case YYTD_ID_DEF:
+		case YYTD_ID_NXT:
+		case YYTD_ID_CHK:
+			dfa->tables[table->td_id - 1] = table;
+			if (table->td_flags != YYTD_DATA16)
+				goto fail_proto;
+			break;
+		case YYTD_ID_EC:
+			dfa->tables[table->td_id - 1] = table;
+			if (table->td_flags != YYTD_DATA8)
+				goto fail_proto;
+			break;
+		default:
+			kfree(table);
+			goto fail_proto;
+		}
+
+		blob += table_size(table->td_lolen, table->td_flags);
+		size -= table_size(table->td_lolen, table->td_flags);
+	}
+
+	error = 0;
+
+	return error;
+
+fail_proto:
+	error = -EPROTO;
+fail:
+	for (i = 0; i < YYTD_ID_NXT; i++) {
+		if (dfa->tables[i]) {
+			kfree(dfa->tables[i]);
+			dfa->tables[i] = NULL;
+		}
+	}
+	return error;
+}
+
+/**
+ * verify_dfa - verify that all the transitions and states in the dfa tables
+ *              are in bounds.
+ * @dfa: dfa to test
+ *
+ * assumes dfa has gone through the verification done by unpacking
+ */
+static int verify_dfa(struct aa_dfa *dfa)
+{
+	size_t i, state_count, trans_count;
+	int error = -EPROTO;
+
+	/* check that required tables exist */
+	if (!(dfa->tables[YYTD_ID_ACCEPT -1 ] &&
+	      dfa->tables[YYTD_ID_DEF - 1] &&
+	      dfa->tables[YYTD_ID_BASE - 1] &&
+	      dfa->tables[YYTD_ID_NXT - 1] &&
+	      dfa->tables[YYTD_ID_CHK - 1]))
+		goto out;
+
+	/* accept.size == default.size == base.size */
+	state_count = dfa->tables[YYTD_ID_BASE - 1]->td_lolen;
+	if (!(state_count == dfa->tables[YYTD_ID_DEF - 1]->td_lolen &&
+	      state_count == dfa->tables[YYTD_ID_ACCEPT - 1]->td_lolen))
+		goto out;
+
+	/* next.size == chk.size */
+	trans_count = dfa->tables[YYTD_ID_NXT - 1]->td_lolen;
+	if (trans_count != dfa->tables[YYTD_ID_CHK - 1]->td_lolen)
+		goto out;
+
+	/* if equivalence classes then its table must be 256 */
+	if (dfa->tables[YYTD_ID_EC - 1] &&
+	    dfa->tables[YYTD_ID_EC - 1]->td_lolen != 256)
+		goto out;
+
+	for (i = 0; i < state_count; i++) {
+		if (DEFAULT_TABLE(dfa)[i] >= state_count)
+			goto out;
+		if (BASE_TABLE(dfa)[i] >= trans_count + 256)
+			goto out;
+	}
+
+	for (i = 0; i < trans_count ; i++) {
+		if (NEXT_TABLE(dfa)[i] >= state_count)
+			goto out;
+		if (CHECK_TABLE(dfa)[i] >= state_count)
+			goto out;
+	}
+
+	error = 0;
+out:
+	return error;
+}
+
+/**
+ * aadfa_label - return the permissions associated with @state
+ * @dfa: dfa to get state permission from
+ * @state: state in the dfa for which to get a label
+ *
+ * Assumes that state is a valid state of the dfa
+ *
+ * Returns the label associated with @state.  0 indicates the state
+ * is no-accepting/provides no permissions.
+ */
+inline unsigned int aadfa_label(struct aa_dfa *dfa, int state)
+{
+	return ACCEPT_TABLE(dfa)[state] & AA_VALID_PERM_MASK;
+}
+
+/**
+ * aadfa_match - match @path against @dfa starting in @state
+ * @dfa: the dfa to match @path against
+ * @state: the state to start matching in
+ * @path: the path to match against the dfa
+ *
+ * aadfa_match will match the full path length and return the state it
+ * finished matching in.  The final state returned can be used to
+ * lookup the accepting label or as a starting point to continue matching
+ * with a new string if the path has been broken into multiple components.
+ */
+static unsigned int aadfa_match(struct aa_dfa *dfa, unsigned int state,
+				const char *path)
+{
+	u8 *s = (u8 *) path;
+	u16 *def = DEFAULT_TABLE(dfa);
+	u32 *base = BASE_TABLE(dfa);
+	u16 *next = NEXT_TABLE(dfa);
+	u16 *check = CHECK_TABLE(dfa);
+	unsigned int pos;
+
+	/* current state is <state>, matching character *s */
+	if (dfa->tables[YYTD_ID_EC - 1]) {
+		u8 *equiv = EQUIV_TABLE(dfa);
+		for ( ; *s; ++s) {
+			pos = base[state] + equiv[*s];
+			if (check[pos] == state)
+				state = next[pos];
+			else
+				state = def[state];
+		}
+	} else {
+		for ( ; *s; ++s) {
+			pos = base[state] + *s;
+			if (check[pos] == state)
+				state = next[pos];
+			else
+				state = def[state];
+		}
+	}
+	return state;
+}
+
+void* aamatch_alloc(enum entry_match_type entry_type)
+{
+	void *ptr=NULL;
+
+	if (entry_type == aa_entry_pattern) {
+		ptr = kmalloc(sizeof(struct aa_dfa), GFP_KERNEL);
+		if (ptr)
+			memset(ptr, 0, sizeof(struct aa_dfa));
+		else
+			ptr=ERR_PTR(-ENOMEM);
+	} else if (entry_type != aa_entry_literal &&
+		   entry_type != aa_entry_tailglob) {
+		ptr = ERR_PTR(-EINVAL);
+	}
+
+	return ptr;
+}
+
+void aamatch_free(void *ptr)
+{
+	if (ptr) {
+		int i;
+		struct aa_dfa *dfa = (struct aa_dfa *) ptr;
+		for (i = 0; i < YYTD_ID_NXT; i++) {
+			if (dfa->tables[i])
+				kfree(dfa->tables[i]);
+		}
+	}
+	kfree(ptr);
+}
+
+const char *aamatch_features(void)
+{
+	return features;
+}
+
+int aamatch_serialize(void *entry_extradata, struct aa_ext *e,
+		      aamatch_serializecb cb)
+{
+	int error = 0;
+	char *blob = NULL;
+	size_t size;
+
+	struct aa_dfa *dfa = (struct aa_dfa *) entry_extradata;
+	if (dfa == NULL)
+		goto done;
+
+	error = -EPROTO;
+	size = cb(e, AA_BLOB_LOC, &blob, "aadfa");
+
+	if (size)
+		error = unpack_dfa(dfa, blob, size);
+
+	if (!error)
+		error = verify_dfa(dfa);
+done:
+	return error;
+}
+
+int aamatch_match(struct aa_entry *entry, const char *pathname)
+{
+	int ret;
+
+	if (entry->type == aa_entry_pattern) {
+		unsigned int state;
+		struct aa_dfa *dfa = (struct aa_dfa *) entry->extradata;
+
+        	state = aadfa_match(dfa, 1, pathname);
+
+		/* label returned is the permissions of the matched state */
+		ret = aadfa_label(dfa, state);
+	} else {
+		ret = aamatch_match_common(entry, pathname);
+	}
+
+        return ret;
+}
+
+EXPORT_SYMBOL_GPL(aamatch_alloc);
+EXPORT_SYMBOL_GPL(aamatch_free);
+EXPORT_SYMBOL_GPL(aamatch_features);
+EXPORT_SYMBOL_GPL(aamatch_serialize);
+EXPORT_SYMBOL_GPL(aamatch_match);
+
+MODULE_DESCRIPTION("AppArmor aa_match module [dfa]");
+MODULE_AUTHOR("John Johansen <jjohansen@suse.de>");
+MODULE_LICENSE("GPL");
Index: linux-2.6/security/apparmor/module_interface.c
===================================================================
--- linux-2.6.orig/security/apparmor/module_interface.c
+++ linux-2.6/security/apparmor/module_interface.c
@@ -206,6 +206,7 @@ static void aaconvert(enum aa_code code,
 		*(u16 *)dest = le16_to_cpu(get_unaligned((u16 *)src));
 		break;
 	case AA_U32:
+	case AA_BLOB_LOC:
 	case AA_STATIC_BLOB:
 		*(u32 *)dest = le32_to_cpu(get_unaligned((u32 *)src));
 		break;
@@ -239,7 +240,8 @@ static u32 aa_is_X(struct aa_ext *e, enu
 	int ret = 0;
 	if (!aa_inbounds(e, AA_CODE_BYTE + aacode_datasize[code]))
 		goto fail;
-	if (code != *(u8 *)e->pos)
+	if (code != *(u8 *)e->pos &&
+	    !(code == AA_BLOB_LOC && AA_STATIC_BLOB == *(u8 *)e->pos))
 		goto out;
 	e->pos += AA_CODE_BYTE;
 	if (code == AA_NAME) {
@@ -271,6 +273,20 @@ static u32 aa_is_X(struct aa_ext *e, enu
 		}
 		e->pos += size;
 		ret = size;
+
+	} else if (code == AA_BLOB_LOC) {
+		u32 size;
+		/* blobs are followed by X bytes */
+		size = le32_to_cpu(get_unaligned((u32 *)e->pos));
+		e->pos += aacode_datasize[AA_STATIC_BLOB];
+		if (!aa_inbounds(e, (size_t) size))
+			goto fail;
+		if (data) {
+			* (char **)data = e->pos;
+		}
+		e->pos += size;
+		ret = size;
+
 	} else if (code == AA_STATIC_BLOB) {
 		u32 size;
 		/* blobs are followed by X bytes, that can be 2^32 */
@@ -434,7 +450,6 @@ static inline struct aa_entry *aa_activa
 	return entry;
 
 fail:
-	aamatch_free(entry->extradata);
 	free_aa_entry(entry);
 	return NULL;
 }
Index: linux-2.6/security/apparmor/module_interface.h
===================================================================
--- linux-2.6.orig/security/apparmor/module_interface.h
+++ linux-2.6/security/apparmor/module_interface.h
@@ -20,6 +20,7 @@ enum aa_code {
 	AA_LIST,
 	AA_LISTEND,
 	AA_OFFSET,
+	AA_BLOB_LOC,
 	AA_BAD
 };
 
Index: linux-2.6/security/apparmor/shared.h
===================================================================
--- linux-2.6.orig/security/apparmor/shared.h
+++ linux-2.6/security/apparmor/shared.h
@@ -28,6 +28,9 @@
 #define POS_AA_EXEC_UNSAFE		(POS_AA_EXEC_MMAP + 1)
 #define POS_AA_FILE_MAX			POS_AA_EXEC_UNSAFE
 
+/* Invalid perm permission */
+#define POS_AA_INVALID_POS		31
+
 /* Modeled after MAY_READ, MAY_WRITE, MAY_EXEC def'ns */
 #define AA_MAY_EXEC			(0x01 << POS_AA_MAY_EXEC)
 #define AA_MAY_WRITE			(0x01 << POS_AA_MAY_WRITE)
@@ -38,9 +41,11 @@
 #define AA_EXEC_PROFILE			(0x01 << POS_AA_EXEC_PROFILE)
 #define AA_EXEC_MMAP			(0x01 << POS_AA_EXEC_MMAP)
 #define AA_EXEC_UNSAFE			(0x01 << POS_AA_EXEC_UNSAFE)
+#define AA_INVALID_PERM			(0x01 << POS_AA_INVALID_POS)
 
 #define AA_EXEC_MODIFIERS		(AA_EXEC_INHERIT | \
 					 AA_EXEC_UNCONSTRAINED | \
 					 AA_EXEC_PROFILE)
+#define AA_VALID_PERM_MASK		((1 << (POS_AA_FILE_MAX + 1)) - 1)
 
 #endif /* _SHARED_H */
