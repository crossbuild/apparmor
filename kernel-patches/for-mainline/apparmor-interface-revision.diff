Index: b/security/apparmor/module_interface.c
===================================================================
--- a/security/apparmor/module_interface.c
+++ b/security/apparmor/module_interface.c
@@ -13,11 +13,6 @@
 
 #include "apparmor.h"
 #include "inline.h"
-#include "module_interface.h"
-
-/* aa_code defined in module_interface.h */
-
-const int aa_code_datasize[] = { 1, 2, 4, 8, 2, 2, 4, 0, 0, 0, 0, 0, 0 };
 
 /**
  * free_aa_profile_rcu - rcu callback for free profiles
@@ -67,187 +62,178 @@ static inline void task_replace(struct a
 		aa_change_profile(cxt, new_profile, cxt->hat_magic);
 }
 
+/* The AppArmor interface treats data as a type byte followed by the
+ * actual data.  The interface has the notion of a a named entry
+ * which has a name (AA_NAME typecode followed by name string) followed by
+ * the entries typecode and data.  Named types allow for optional
+ * elements and extensions to be added and tested for without breaking
+ * backwards compatability.
+ */
+
+enum aa_code {
+	AA_U8,
+	AA_U16,
+	AA_U32,
+	AA_U64,
+	AA_NAME,	/* same as string except it is items name */
+	AA_STRING,
+	AA_BLOB,
+	AA_STRUCT,
+	AA_STRUCTEND,
+	AA_LIST,
+	AA_LISTEND,
+};
+
+/* aa_ext is the read of the buffer containing the serialized profile.  The
+ * data is copied into a kernel buffer in apparmorfs and then handed off to
+ * the activate routines.
+ */
+struct aa_ext {
+	void *start;
+	void *end;
+	void *pos;	/* pointer to current position in the buffer */
+	u32 version;
+};
+
 static inline int aa_inbounds(struct aa_ext *e, size_t size)
 {
 	return (e->pos + size <= e->end);
 }
 
 /**
- * aa_convert - convert trailing values of serialized type codes
- * @code: type code
- * @dest: pointer to object to receive the converted value
- * @src:  pointer to value to convert
+ * aa_u16_chunck - test and do bounds checking for a u16 size based chunk
+ * @e: serialized data read head
+ * @chunk: start address for chunk of data
  *
- * for serialized type codes which have a trailing value, convert it
- * and place it in @dest.  If a code does not have a trailing value nop.
+ * return the size of chunk found with the read head at the end of
+ * the chunk.
  */
-static void aa_convert(enum aa_code code, void *dest, void *src)
-{
-	switch (code) {
-	case AA_U8:
-		*(u8 *)dest = *(u8 *) src;
-		break;
-	case AA_U16:
-	case AA_NAME:
-	case AA_DYN_STRING:
-		*(u16 *)dest = le16_to_cpu(get_unaligned((u16 *)src));
-		break;
-	case AA_U32:
-	case AA_BLOB_LOC:
-	case AA_STATIC_BLOB:
-		*(u32 *)dest = le32_to_cpu(get_unaligned((u32 *)src));
-		break;
-	case AA_U64:
-		*(u64 *)dest = le64_to_cpu(get_unaligned((u64 *)src));
-		break;
-	default:
-		/* nop - all other type codes do not have a trailing value */
-		;
-	}
-}
-
-/**
- * aa_is_X - check if the next element is of type X
- * @e: serialized data extent information
- * @code: type code
- * @data: object located at @e->pos (of type @code) is written into @data
- *        if @data is non-null.  if data is null it means skip this
- *        entry
- * check to see if the next element in the serialized data stream is of type
- * X and check that it is with in bounds, if so put the associated value in
- * @data.
- * return the size of bytes associated with the returned data
- *        for complex object like blob and string a pointer to the allocated
- *        data is returned in data, but the size of the blob or string is
- *        returned.
- */
-static u32 aa_is_X(struct aa_ext *e, enum aa_code code, void *data)
+static size_t aa_is_u16_chunk(struct aa_ext *e, char **chunk)
 {
 	void *pos = e->pos;
-	int ret = 0;
-	if (!aa_inbounds(e, AA_CODE_BYTE + aa_code_datasize[code]))
-		goto fail;
-	if (code != *(u8 *)e->pos &&
-	    !(code == AA_BLOB_LOC && AA_STATIC_BLOB == *(u8 *)e->pos))
-		goto out;
-	e->pos += AA_CODE_BYTE;
-	if (code == AA_NAME) {
-		u16 size;
-		/* name codes are followed by X bytes */
-		size = le16_to_cpu(get_unaligned((u16 *)e->pos));
-		if (!aa_inbounds(e, (size_t) size))
-			goto fail;
-		if (data)
-			*(u16 *)data = size;
-		e->pos += aa_code_datasize[code];
-		ret = 1 + aa_code_datasize[code];
-	} else if (code == AA_DYN_STRING) {
-		u16 size;
-		char *str;
-		/* strings codes are followed by X bytes */
-		size = le16_to_cpu(get_unaligned((u16 *)e->pos));
-		e->pos += aa_code_datasize[code];
-		if (!aa_inbounds(e, (size_t) size))
-			goto fail;
-		if (data) {
-			* (char **)data = NULL;
-			str = kmalloc(size, GFP_KERNEL);
-			if (!str)
-				goto fail;
-			memcpy(str, e->pos, (size_t) size);
-			str[size-1] = '\0';
-			* (char **)data = str;
-		}
-		e->pos += size;
-		ret = size;
+	size_t size = 0;
 
-	} else if (code == AA_BLOB_LOC) {
-		u32 size;
-		/* blobs are followed by X bytes */
-		size = le32_to_cpu(get_unaligned((u32 *)e->pos));
-		e->pos += aa_code_datasize[AA_STATIC_BLOB];
-		if (!aa_inbounds(e, (size_t) size))
-			goto fail;
-		if (data) {
-			* (char **)data = e->pos;
-		}
-		e->pos += size;
-		ret = size;
+	if (!aa_inbounds(e, sizeof(u16)))
+		goto fail;
+	size = le16_to_cpu(get_unaligned((u16 *)e->pos));
+	e->pos += sizeof(u16);
+	if (!aa_inbounds(e, size))
+		goto fail;
+	*chunk = e->pos;
+	e->pos += size;
+	return size;
 
-	} else if (code == AA_STATIC_BLOB) {
-		u32 size;
-		/* blobs are followed by X bytes, that can be 2^32 */
-		size = le32_to_cpu(get_unaligned((u32 *)e->pos));
-		e->pos += aa_code_datasize[code];
-		if (!aa_inbounds(e, (size_t) size))
-			goto fail;
-		if (data)
-			memcpy(data, e->pos, (size_t) size);
-		e->pos += size;
-		ret = size;
-	} else {
-		if (data)
-			aa_convert(code, data, e->pos);
-		e->pos += aa_code_datasize[code];
-		ret = 1 + aa_code_datasize[code];
-	}
-out:
-	return ret;
 fail:
 	e->pos = pos;
 	return 0;
 }
 
+static inline int aa_is_X(struct aa_ext *e, enum aa_code code)
+{
+	if (!aa_inbounds(e, 1))
+		return 0;
+	if (*(u8 *) e->pos != code)
+		return 0;
+	e->pos++;
+	return 1;
+}
+
 /**
  * aa_is_nameX - check is the next element is of type X with a name of @name
  * @e: serialized data extent information
  * @code: type code
- * @data: location to store deserialized data if match isX criteria
  * @name: name to match to the serialized element.
  *
  * check that the next serialized data element is of type X and has a tag
- * name @name.  If the code matches and name (if specified) matches then
- * the packed data is unpacked into *data.  (Note for strings this is the
- * size, and the next data in the stream is the string data)
- * returns %0 if either match failes
+ * name @name.  If @name is specified then there must be a matching
+ * name element in the stream.  If @name is NULL any name element will be
+ * skipped and only the typecode will be tested.
+ * returns 1 on success (both type code and name tests match) and the read
+ * head is advanced past the headers
+ * returns %0 if either match failes, the read head does not move
  */
-static int aa_is_nameX(struct aa_ext *e, enum aa_code code, void *data,
-		       const char *name)
+static int aa_is_nameX(struct aa_ext *e, enum aa_code code, const char *name)
 {
 	void *pos = e->pos;
-	u16 size;
-	u32 ret;
 	/* check for presence of a tagname, and if present name size
 	 * AA_NAME tag value is a u16 */
-	if (aa_is_X(e, AA_NAME, &size)) {
+	if (aa_is_X(e, AA_NAME)) {
+		char *tag;
+		size_t size = aa_is_u16_chunk(e, &tag);
 		/* if a name is specified it must match. otherwise skip tag */
-		if (name && ((strlen(name) != size-1) ||
-			     strncmp(name, (char *)e->pos, (size_t)size-1)))
+		if (name && (!size || strcmp(name, tag)))
 			goto fail;
-		e->pos += size;
 	} else if (name) {
+		/* if a name is specified and there is no name tag fail */
 		goto fail;
 	}
 
-	/* now check if data actually matches */
-	ret = aa_is_X(e, code, data);
-	if (!ret)
-		goto fail;
-	return ret;
+	/* now check if type code matches */
+	if (aa_is_X(e, code))
+		return 1;
+
+fail:
+	e->pos = pos;
+	return 0;
+}
+
+static int aa_is_u32(struct aa_ext *e, u32 *data, const char *name)
+{
+	void *pos = e->pos;
+	if (aa_is_nameX(e, AA_U32, name)) {
+		if (!aa_inbounds(e, sizeof(u32)))
+			goto fail;
+		if (data)
+			*data = le32_to_cpu(get_unaligned((u32 *)e->pos));
+		e->pos += sizeof(u32);
+		return 1;
+	}
+fail:
+	e->pos = pos;
+	return 0;
+}
 
+static size_t aa_is_blob(struct aa_ext *e, char **blob, const char *name)
+{
+	void *pos = e->pos;
+	if (aa_is_nameX(e, AA_BLOB, name)) {
+		u32 size;
+		if (!aa_inbounds(e, sizeof(u32)))
+			goto fail;
+		size = le32_to_cpu(get_unaligned((u32 *)e->pos));
+		e->pos += sizeof(u32);
+		if (aa_inbounds(e, (size_t) size)) {
+			* blob = e->pos;
+			e->pos += size;
+			return size;
+		}
+	}
 fail:
 	e->pos = pos;
 	return 0;
 }
 
-/* macro to wrap error case to make a block of reads look nicer */
-#define AA_READ_X(E, C, D, N) \
-	do { \
-		u32 __ret; \
-		__ret = aa_is_nameX((E), (C), (D), (N)); \
-		if (!__ret) \
-			goto fail; \
-	} while (0)
+static int aa_is_dynstring(struct aa_ext *e, char **string, const char *name)
+{
+	char *src_str;
+	size_t size = 0;
+	void *pos = e->pos;
+	*string = NULL;
+	if (aa_is_nameX(e, AA_STRING, name) &&
+	    (size = aa_is_u16_chunk(e, &src_str))) {
+		char *str;
+		if (!(str = kmalloc(size, GFP_KERNEL)))
+			goto fail;
+		memcpy(str, src_str, size);
+		*string = str;
+	}
+
+	return size;
+
+fail:
+	e->pos = pos;
+	return 0;
+}
 
 /**
  * aa_activate_dfa - unpack a file rule dfa
@@ -261,12 +247,16 @@ struct aa_dfa *aa_activate_dfa(struct aa
 	size_t size, error = 0;
 	struct aa_dfa *dfa = NULL;
 
-	size = aa_is_nameX(e, AA_BLOB_LOC, &blob, "aadfa");
+	size = aa_is_blob(e, &blob, "aadfa");
 	if (size) {
 		dfa = aa_match_alloc();
 		if (dfa) {
-			error = unpack_dfa(dfa, blob, size);
-
+			/* the dfa is aligned with in the blob to 8 bytes
+			 * from the beginning of the stream
+			 */
+			size_t pad = pad64(blob - (char *) e->start) -
+				(blob - (char *) e->start);
+			error = unpack_dfa(dfa, blob + pad, size - pad);
 			if (!error)
 				error = verify_dfa(dfa);
 		} else {
@@ -287,118 +277,116 @@ struct aa_dfa *aa_activate_dfa(struct aa
  * @e: serialized data extent information
  * @error: error code returned if unpacking fails
  */
-static struct aa_profile *aa_activate_profile(struct aa_ext *e, ssize_t *error)
+static struct aa_profile *aa_activate_profile(struct aa_ext *e)
 {
 	struct aa_profile *profile = NULL;
-	const char *rulename = "";
-	const char *error_string = "Invalid Profile";
 
-	*error = -EPROTO;
+	int error = -EPROTO;
 
 	profile = alloc_aa_profile();
-	if (!profile) {
-		error_string = "Could not allocate profile";
-		*error = -ENOMEM;
-		goto fail;
-	}
+	if (!profile)
+		return ERR_PTR(-ENOMEM);
 
 	/* check that we have the right struct being passed */
-	AA_READ_X(e, AA_STRUCT, NULL, "profile");
-	AA_READ_X(e, AA_DYN_STRING, &profile->name, NULL);
+	if (!aa_is_nameX(e, AA_STRUCT, "profile"))
+		goto fail;
+	if (!aa_is_dynstring(e, &profile->name, NULL))
+		goto fail;
 
-	error_string = "Invalid flags";
 	/* per profile debug flags (complain, audit) */
-	AA_READ_X(e, AA_STRUCT, NULL, "flags");
-	AA_READ_X(e, AA_U32, NULL, NULL);  /* obsolete flags.debug */
-	AA_READ_X(e, AA_U32, &(profile->flags.complain), NULL);
-	AA_READ_X(e, AA_U32, &(profile->flags.audit), NULL);
-	AA_READ_X(e, AA_STRUCTEND, NULL, NULL);
+	if (!aa_is_nameX(e, AA_STRUCT, "flags"))
+		goto fail;
+	if (!aa_is_u32(e, NULL, NULL))
+		goto fail;
+	if (!aa_is_u32(e, &(profile->flags.complain), NULL))
+		goto fail;
+	if (!aa_is_u32(e, &(profile->flags.audit), NULL))
+		goto fail;
+	if (!aa_is_nameX(e, AA_STRUCTEND, NULL))
+		goto fail;
 
-	error_string = "Invalid capabilities";
-	AA_READ_X(e, AA_U32, &(profile->capabilities), NULL);
+	if (!aa_is_u32(e, &(profile->capabilities), NULL))
+		goto fail;
 
 	/* get file rules */
 	profile->file_rules = aa_activate_dfa(e);
 	if (IS_ERR(profile->file_rules)) {
-		error_string = "Invalid file rule dfa\n";
-		*error = PTR_ERR(profile->file_rules);
+		error = PTR_ERR(profile->file_rules);
 		profile->file_rules = NULL;
 		goto fail;
 	}
 
-	rulename = "";
-
-	/* get subprofiles */
-	if (aa_is_nameX(e, AA_LIST, NULL, "hats")) {
-		error_string = "Invalid profile hat";
-		while (!aa_is_nameX(e, AA_LISTEND, NULL, NULL)) {
+	/* get optional subprofiles */
+	if (aa_is_nameX(e, AA_LIST, "hats")) {
+		while (!aa_is_nameX(e, AA_LISTEND, NULL)) {
 			struct aa_profile *subprofile;
-			subprofile = aa_activate_profile(e, error);
-			if (!subprofile)
+			subprofile = aa_activate_profile(e);
+			if (IS_ERR(subprofile)) {
+				error = PTR_ERR(subprofile);
 				goto fail;
+			}
 			subprofile->parent = profile;
 			list_add(&subprofile->list, &profile->sub);
 		}
 	}
 
-	error_string = "Invalid end of profile";
-	AA_READ_X(e, AA_STRUCTEND, NULL, NULL);
+	if (!aa_is_nameX(e, AA_STRUCTEND, NULL))
+		goto fail;
 
 	return profile;
 
 fail:
-	AA_WARN("%s: %s %s in profile %s\n", INTERFACE_ID, rulename,
-		error_string, profile && profile->name ? profile->name
-		: "unknown");
+	AA_WARN("Invalid profile %s\n",
+		profile && profile->name ? profile->name : "unknown");
 
-	if (profile) {
+	if (profile)
 		free_aa_profile(profile);
-		profile = NULL;
-	}
 
-	return NULL;
+	return ERR_PTR(error);
 }
 
 /**
- * aa_activate_top_profile - unpack a serialized base profile
+ * aa_activate_profile_wrapper - unpack a serialized base profile
  * @e: serialized data extent information
- * @error: error code returned if unpacking fails
  *
  * check interface version unpack a profile and all its hats and patch
  * in any extra information that the profile needs.
  */
-static void *aa_activate_top_profile(struct aa_ext *e, ssize_t *error)
+static struct aa_profile *aa_activate_profile_wrapper(struct aa_ext *e)
 {
-	struct aa_profile *profile = NULL;
+	struct aa_profile *profile = aa_activate_profile(e);
+	if (!IS_ERR(profile) &&
+	    (!list_empty(&profile->sub) || profile->flags.complain)) {
+		int error;
+		if ((error = attach_nullprofile(profile))) {
+			aa_put_profile(profile);
+			return ERR_PTR(error);
+		}
+	}
+
+	return profile;
+}
 
+/**
+ * aa_verify_head - unpack serialized stream header
+ * @e: serialized data read head
+ *
+ * returns error or 0 if header is good
+ */
+static int aa_verify_header(struct aa_ext *e)
+{
 	/* get the interface version */
-	if (!aa_is_nameX(e, AA_U32, &e->version, "version")) {
-		AA_WARN("%s: version missing\n", INTERFACE_ID);
-		*error = -EPROTONOSUPPORT;
-		goto fail;
+	if (!aa_is_u32(e, &e->version, "version")) {
+		AA_WARN("Interface version missing\n");
+		return -EPROTONOSUPPORT;
 	}
 
 	/* check that the interface version is currently supported */
 	if (e->version != 3) {
-		AA_WARN("%s: unsupported interface version (%d)\n",
-			INTERFACE_ID, e->version);
-		*error = -EPROTONOSUPPORT;
-		goto fail;
-	}
-
-	profile = aa_activate_profile(e, error);
-	if (!profile)
-		goto fail;
-
-	if (!list_empty(&profile->sub) || profile->flags.complain) {
-		if (attach_nullprofile(profile))
-			goto fail;
+		AA_WARN("Unsupported interface version (%d)\n", e->version);
+		return -EPROTONOSUPPORT;
 	}
-	return profile;
-
-fail:
-	free_aa_profile(profile);
-	return NULL;
+	return 0;
 }
 
 /**
@@ -414,12 +402,14 @@ ssize_t aa_file_prof_add(void *data, siz
 		.end = data + size,
 		.pos = data
 	};
-	ssize_t error;
-
-	profile = aa_activate_top_profile(&e, &error);
-	if (!profile)
+	ssize_t error = aa_verify_header(&e);
+	if (error)
 		return error;
 
+	profile = aa_activate_profile_wrapper(&e);
+	if (IS_ERR(profile))
+		return PTR_ERR(profile);
+
 	write_lock(&profile_list_lock);
 	if (__aa_find_profile(profile->name, &profile_list)) {
 		/* A profile with this name exists already. */
@@ -450,12 +440,14 @@ ssize_t aa_file_prof_replace(void *udata
 		.end = udata + size,
 		.pos = udata
 	};
-	ssize_t error;
-
-	new_profile = aa_activate_top_profile(&e, &error);
-	if (!new_profile)
+	ssize_t error = aa_verify_header(&e);
+	if (error)
 		return error;
 
+	new_profile = aa_activate_profile_wrapper(&e);
+	if (IS_ERR(new_profile))
+		return PTR_ERR(new_profile);
+
 	write_lock(&profile_list_lock);
 	old_profile = __aa_find_profile(new_profile->name, &profile_list);
 	if (old_profile) {
Index: b/security/apparmor/module_interface.h
===================================================================
--- a/security/apparmor/module_interface.h
+++ /dev/null
@@ -1,38 +0,0 @@
-#ifndef __MODULEINTERFACE_H
-#define __MODULEINTERFACE_H
-
-/* Codes of the types of basic structures that are understood */
-#define AA_CODE_BYTE (sizeof(u8))
-#define INTERFACE_ID "INTERFACE"
-
-#define APPARMOR_INTERFACE_VERSION 2
-
-enum aa_code {
-	AA_U8,
-	AA_U16,
-	AA_U32,
-	AA_U64,
-	AA_NAME,	/* same as string except it is items name */
-	AA_DYN_STRING,
-	AA_STATIC_BLOB,
-	AA_STRUCT,
-	AA_STRUCTEND,
-	AA_LIST,
-	AA_LISTEND,
-	AA_OFFSET,
-	AA_BLOB_LOC,
-	AA_BAD
-};
-
-/* aa_ext tracks the kernel buffer and read position in it.  The interface
- * data is copied into a kernel buffer in apparmorfs and then handed off to
- * the activate routines.
- */
-struct aa_ext {
-	void *start;
-	void *end;
-	void *pos;	/* pointer to current position in the buffer */
-	u32 version;
-};
-
-#endif /* __MODULEINTERFACE_H */
Index: b/security/apparmor/match.c
===================================================================
--- a/security/apparmor/match.c
+++ b/security/apparmor/match.c
@@ -25,9 +25,9 @@ static struct table_header *unpack_table
 	if (bsize < sizeof(struct table_header))
 		goto out;
 
-	th.td_id = ntohs(get_unaligned((u16 *) (blob)));
-	th.td_flags = ntohs(get_unaligned((u16 *) (blob + 2)));
-	th.td_lolen = ntohl(get_unaligned((u32 *) (blob + 8)));
+	th.td_id = ntohs(*(u16 *) (blob));
+	th.td_flags = ntohs(*(u16 *) (blob + 2));
+	th.td_lolen = ntohl(*(u32 *) (blob + 8));
 	blob += sizeof(struct table_header);
 
 	if (!(th.td_flags == YYTD_DATA16 || th.td_flags == YYTD_DATA32 ||
@@ -65,10 +65,10 @@ int unpack_dfa(struct aa_dfa *dfa, void 
 	if (size < sizeof(struct table_set_header))
 		goto fail;
 
-	dfa->th.th_magic = ntohl(get_unaligned((u32 *) (blob + 0)));
-	dfa->th.th_hsize = ntohl(get_unaligned((u32 *) (blob + 4)));
-	dfa->th.th_ssize = ntohl(get_unaligned((u32 *) (blob + 8)));
-	dfa->th.th_flags = ntohs(get_unaligned((u16 *) (blob + 12)));
+	dfa->th.th_magic = ntohl(*(u32 *) (blob + 0));
+	dfa->th.th_hsize = ntohl(*(u32 *) (blob + 4));
+	dfa->th.th_ssize = ntohl(*(u32 *) (blob + 8));
+	dfa->th.th_flags = ntohs(*(u16 *) (blob + 12));
 
 	if (dfa->th.th_magic != YYTH_MAGIC)
 		goto fail;
