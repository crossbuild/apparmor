Index: linux-2.6/security/apparmor/main.c
===================================================================
--- linux-2.6.orig/security/apparmor/main.c
+++ linux-2.6/security/apparmor/main.c
@@ -61,7 +61,7 @@ static inline int aa_taskattr_access(con
 static inline int aa_file_mode(struct aaprofile *profile, const char *name)
 {
 	struct aa_entry *entry;
-	int mode = 0;
+	int perms = 0;
 
 	AA_DEBUG("%s: %s\n", __FUNCTION__, name);
 	if (!name) {
@@ -74,12 +74,10 @@ static inline int aa_file_mode(struct aa
 		goto out;
 	}
 	list_for_each_entry(entry, &profile->file_entry, list) {
-		if (aamatch_match(name, entry->filename,
-				  entry->type, entry->extradata))
-			mode |= entry->mode;
+		perms |= aamatch_match(entry, name);
 	}
 out:
-	return mode;
+	return perms;
 }
 
 /**
@@ -109,8 +107,7 @@ static inline int aa_get_execmode(struct
 				  int *xmod, int *unsafe)
 {
 	struct aa_entry *entry;
-	struct aa_entry *match = NULL;
-
+	int entry_perms = 0, match_perms = 0;
 	int pattern_match_invalid = 0, rc = 0;
 
 	/* search list of profiles with 'x' permission
@@ -127,47 +124,44 @@ static inline int aa_get_execmode(struct
 			    listp[POS_AA_MAY_EXEC]) {
 		if (!pattern_match_invalid &&
 		    entry->type == aa_entry_pattern &&
-		    aamatch_match(name, entry->filename,
-				  entry->type, entry->extradata)) {
-			if (match &&
-			    AA_EXEC_UNSAFE_MASK(entry->mode) !=
-			    AA_EXEC_UNSAFE_MASK(match->mode))
+		    (entry_perms = aamatch_match(entry, name))) {
+			if (match_perms &&
+			    AA_EXEC_UNSAFE_MASK(entry_perms) !=
+			    AA_EXEC_UNSAFE_MASK(match_perms))
 				pattern_match_invalid = 1;
 			else
 				/* keep searching for an exact match */
-				match = entry;
+				match_perms = entry_perms;
 		} else if ((entry->type == aa_entry_literal ||
 			    (!pattern_match_invalid &&
 			     entry->type == aa_entry_tailglob)) &&
-			    aamatch_match(name, entry->filename,
-					  entry->type,
-					  entry->extradata)) {
+			   (entry_perms = aamatch_match(entry, name))) {
 			if (entry->type == aa_entry_literal) {
 				/* got an exact match -- there can be only
 				 * one, asserted at profile load time
 				 */
-				match = entry;
+				match_perms = entry_perms;
 				pattern_match_invalid = 0;
 				break;
 			} else {
-				if (match &&
-				    AA_EXEC_UNSAFE_MASK(entry->mode) !=
-				    AA_EXEC_UNSAFE_MASK(match->mode))
+				if (match_perms &&
+				    AA_EXEC_UNSAFE_MASK(entry_perms) !=
+				    AA_EXEC_UNSAFE_MASK(match_perms))
 					pattern_match_invalid = 1;
 				else
 					/* got a tailglob match, keep searching
 					 * for an exact match
 					 */
-					match = entry;
+					match_perms = entry_perms;
 			}
 		}
 
 	}
 
-	rc = match && !pattern_match_invalid;
+	rc = match_perms && !pattern_match_invalid;
 
 	if (rc) {
-		int mode = AA_EXEC_MASK(match->mode);
+		int mode = AA_EXEC_MASK(match_perms);
 
 		/* check for qualifiers, if present
 		 * we just return the qualifier
@@ -176,8 +170,8 @@ static inline int aa_get_execmode(struct
 			mode = mode & ~AA_MAY_EXEC;
 
 		*xmod = mode;
-		*unsafe = (match->mode & AA_EXEC_UNSAFE);
-	} else if (!match) {
+		*unsafe = (match_perms & AA_EXEC_UNSAFE);
+	} else if (!match_perms) {
 		AA_DEBUG("%s: Unable to find execute entry in profile "
 			 "for image '%s'\n",
 			 __FUNCTION__,
@@ -251,7 +245,8 @@ static inline void aa_permerror2result(i
 static unsigned int aa_file_perm(struct aaprofile *active, const char *name,
 				 int mask)
 {
-	int i, error = 0, mode;
+	int i, error = 0;
+	int perms;
 
 #define PROCPFX "/proc/"
 #define PROCLEN sizeof(PROCPFX) - 1
@@ -270,7 +265,7 @@ static unsigned int aa_file_perm(struct 
 	    aa_taskattr_access(name + PROCLEN))
 		goto done;
 
-	mode = 0;
+	perms = 0;
 
 	/* iterate over partition, one permission bit at a time */
 	for (i = 0; i <= POS_AA_FILE_MAX; i++) {
@@ -278,32 +273,27 @@ static unsigned int aa_file_perm(struct 
 
 		/* do we have to accumulate this bit?
 		 * or have we already accumulated it (shortcut below)? */
-		if (!(mask & (1 << i)) || mode & (1 << i))
+		if (!(mask & (1 << i)) || perms & (1 << i))
 			continue;
 
 		list_for_each_entry(entry, &active->file_entryp[i],
 				    listp[i]) {
-			if (aamatch_match(name, entry->filename,
-				entry->type, entry->extradata)) {
-				/* Shortcut, accumulate all bits present */
-				mode |= entry->mode;
-
-				/* Mask bits are overloaded
-				 * MAY_{EXEC,WRITE,READ,APPEND} are used by
-				 * kernel, other values are used locally only.
-				 */
-				if ((mode & mask) == mask) {
-					AA_DEBUG("MATCH! %s=0x%x [total mode=0x%x]\n",
-						 name, mask, mode);
+			perms |= aamatch_match(entry, name);
 
-					goto done;
-				}
+			/* Mask bits are overloaded
+			 * MAY_{EXEC,WRITE,READ,APPEND} are used by
+			 * kernel, other values are used locally only.
+			 */
+			if ((perms & mask) == mask) {
+				AA_DEBUG("MATCH! %s=0x%x [total mode=0x%x]\n",
+					 name, mask, perms);
+				goto done;
 			}
 		}
 	}
 
 	/* return permissions not satisfied */
-	error = mask & ~mode;
+	error = mask & ~perms;
 
 done:
 	return error;
Index: linux-2.6/security/apparmor/match/match.h
===================================================================
--- linux-2.6.orig/security/apparmor/match/match.h
+++ linux-2.6/security/apparmor/match/match.h
@@ -69,16 +69,11 @@ extern int aamatch_serialize(void *entry
 
 /**
  * aamatch_match: determine if pathname matches entry
+ * @entry: rule entry to match against
  * @pathname: pathname to verify
- * @entry_name: entry name
- * @type: type of entry
- * @entry_extradata: data previously allocated by aamatch_alloc
- * Return value: 1 match, 0 othersise
+ * Return value: permission match, 0 othersise
  */
-extern unsigned int aamatch_match(const char *pathname, const char *entry_name,
-				  enum entry_match_type type,
-				  void *entry_extradata);
-
+extern int aamatch_match(struct aa_entry *entry, const char *pathname);
 
 /**
  * sd_getmatch_type - return string representation of entry_match_type
@@ -107,26 +102,25 @@ static inline const char *sd_getmatch_ty
  * @entry_name: name from aa_entry
  * @type: type of entry
  */
-static inline int aamatch_match_common(const char *path,
-					   const char *entry_name,
-			   		   enum entry_match_type type)
+static inline int aamatch_match_common(struct aa_entry *entry,
+				       const char *path)
 {
 	int retval;
 
 	/* literal, no pattern matching characters */
-	if (type == aa_entry_literal) {
-		retval = (strcmp(entry_name, path) == 0);
+	if (entry->type == aa_entry_literal) {
+		retval = (strcmp(entry->filename, path) == 0);
 	/* trailing ** glob pattern */
-	} else if (type == aa_entry_tailglob) {
-		retval = (strncmp(entry_name, path,
-				  strlen(entry_name) - 2) == 0);
+	} else if (entry->type == aa_entry_tailglob) {
+		retval = (strncmp(entry->filename, path,
+				  strlen(entry->filename) - 2) == 0);
 	} else {
 		AA_WARN("%s: Invalid entry_match_type %d\n",
-			__FUNCTION__, type);
+			__FUNCTION__, entry->type);
 		retval = 0;
 	}
 
-	return retval;
+	return retval ? entry->mode : 0;
 }
 
 #endif /* __MATCH_H */
Index: linux-2.6/security/apparmor/match/match_default.c
===================================================================
--- linux-2.6.orig/security/apparmor/match/match_default.c
+++ linux-2.6/security/apparmor/match/match_default.c
@@ -36,12 +36,11 @@ int aamatch_serialize(void *entry_extrad
 	return 0;
 }
 
-unsigned int aamatch_match(const char *pathname, const char *entry_name,
-			   enum entry_match_type type, void *entry_extradata)
+int aamatch_match(struct aa_entry *entry, const char *pathname)
 {
 	int ret;
 
-	ret = aamatch_match_common(pathname, entry_name, type);
+	ret = aamatch_match_common(entry, pathname);
 
 	return ret;
 }
Index: linux-2.6/security/apparmor/match/match_pcre.c
===================================================================
--- linux-2.6.orig/security/apparmor/match/match_pcre.c
+++ linux-2.6/security/apparmor/match/match_pcre.c
@@ -132,27 +132,26 @@ done:
 	return error;
 }
 
-unsigned int aamatch_match(const char *pathname, const char *entry_name,
-			   enum entry_match_type entry_type, void *entry_extradata)
+int aamatch_match(struct aa_entry *entry, const char *pathname)
 {
 	int ret;
 
-	if (entry_type == aa_entry_pattern) {
+	if (entry->type == aa_entry_pattern) {
 		int pcreret;
 		struct aamatch_entry *ed =
-			(struct aamatch_entry *) entry_extradata;
+			(struct aamatch_entry *) entry->extradata;
 
         	pcreret = pcre_exec(ed->compiled, NULL,
 				    pathname, strlen(pathname),
 			    	    0, 0, NULL, 0);
 
-        	ret = (pcreret >= 0);
+        	ret = (pcreret >= 0) ? entry->mode : 0;
 
 		// XXX - this needs access to subdomain_debug,  hmmm
         	//AA_DEBUG("%s(%d): %s %s %d\n", __FUNCTION__,
 		//	 ret, pathname, ed->pattern, pcreret);
 	} else {
-		ret = aamatch_match_common(pathname, entry_name, entry_type);
+		ret = aamatch_match_common(entry, pathname);
 	}
 
         return ret;
