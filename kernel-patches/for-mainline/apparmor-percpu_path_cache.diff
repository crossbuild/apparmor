Index: linux-2.6.19.1/security/apparmor/apparmor.h
===================================================================
--- linux-2.6.19.1.orig/security/apparmor/apparmor.h
+++ linux-2.6.19.1/security/apparmor/apparmor.h
@@ -197,7 +197,19 @@ enum aa_xattroptype {
 #define BASE_PROFILE(p) ((p)->parent ? (p)->parent : (p))
 #define IN_SUBPROFILE(p) ((p)->parent)
 
+/* path name buffer cache */
+#define AAPATH_CACHE_MAX_COUNT 2
+
+struct aa_path_cache_head {
+	unsigned int count;
+	struct list_head list;
+};
+
 /* main.c */
+extern void aa_destroy_path_cache(void);
+extern int aa_init_path_cache(void);
+extern char *aa_get_path(gfp_t gfp);
+extern void aa_put_path(char *path);
 extern int alloc_null_complain_profile(void);
 extern void free_null_complain_profile(void);
 extern int attach_nullprofile(struct aaprofile *profile);
Index: linux-2.6.19.1/security/apparmor/inline.h
===================================================================
--- linux-2.6.19.1.orig/security/apparmor/inline.h
+++ linux-2.6.19.1/security/apparmor/inline.h
@@ -216,7 +216,7 @@ static inline struct aaprofile *alloc_aa
  */
 static inline void aa_put_name(const char *name)
 {
-	free_page((unsigned long)name);
+	aa_put_path((char *)name);
 }
 
 /** __aa_find_profile
Index: linux-2.6.19.1/security/apparmor/lsm.c
===================================================================
--- linux-2.6.19.1.orig/security/apparmor/lsm.c
+++ linux-2.6.19.1/security/apparmor/lsm.c
@@ -814,6 +814,11 @@ static int __init apparmor_init(void)
 		goto alloc_out;
 	}
 
+	if ((error = aa_init_path_cache())) {
+		AA_ERROR("Unable to allocate path cache\n");
+		goto path_out;
+	}
+
 	if ((error = register_security(&apparmor_ops))) {
 		AA_ERROR("Unable to load AppArmor\n");
 		goto register_security_out;
@@ -828,6 +833,9 @@ static int __init apparmor_init(void)
 	return error;
 
 register_security_out:
+	aa_destroy_path_cache();
+
+path_out:
 	free_null_complain_profile();
 
 alloc_out:
Index: linux-2.6.19.1/security/apparmor/main.c
===================================================================
--- linux-2.6.19.1.orig/security/apparmor/main.c
+++ linux-2.6.19.1/security/apparmor/main.c
@@ -12,11 +12,132 @@
 #include <linux/security.h>
 #include <linux/namei.h>
 #include <linux/audit.h>
+#include <linux/mm.h>
 
 #include "apparmor.h"
 
 #include "inline.h"
 
+static DEFINE_PER_CPU(struct aa_path_cache_head, aa_path_cache);
+
+/**
+ * aa_destroy_path_cache - destroy the path cache initialized
+ */
+void aa_destroy_path_cache(void)
+{
+	int cpu;
+
+	for_each_possible_cpu(cpu) {
+		struct list_head *n, *tmp;
+		if (per_cpu(aa_path_cache, cpu).count == 0)
+			continue;
+		per_cpu(aa_path_cache, cpu).count = 0;
+		list_for_each_safe(n, tmp, &per_cpu(aa_path_cache, cpu).list) {
+			list_del(n);
+			free_page((unsigned long) n);
+		}
+	}
+}
+
+#define ALIGN_TO_PAGE(X) (((unsigned long)(X)) & PAGE_MASK)
+
+static inline int aa_push_path(struct aa_path_cache_head *cache, char *path)
+{
+	int ret = 0;
+
+	if (cache->count < AAPATH_CACHE_MAX_COUNT) {
+		list_add((struct list_head *) ALIGN_TO_PAGE(path),
+			 &cache->list);
+		cache->count++;
+		ret = 1;
+	}
+
+	return ret;
+}
+
+/**
+ * aa_init_path_cache - initialize AA's path cache
+ */
+int aa_init_path_cache(void)
+{
+	int cpu;
+	int error = -ENOMEM;
+
+	for_each_possible_cpu(cpu) {
+		per_cpu(aa_path_cache, cpu).count = 0;
+		INIT_LIST_HEAD(&per_cpu(aa_path_cache, cpu).list);
+	}
+
+	/* initialize the path cache with 2 pages/cpu */
+	for_each_possible_cpu(cpu) {
+		char *page;
+
+		page = (char *) __get_free_page(GFP_KERNEL);
+		if (!page)
+			goto out;
+		aa_push_path(&per_cpu(aa_path_cache, cpu), page);
+		page = (char *) __get_free_page(GFP_KERNEL);
+		if (!page)
+			goto out;
+		aa_push_path(&per_cpu(aa_path_cache, cpu), page);
+		error = 0;
+	}
+
+out:
+	return error;
+}
+
+/**
+ * aa_get_path - get a path buffer for use in path lookups
+ * @gfp: the type of memory allocation to perform if no buffer available in
+ *       the cache.
+ */
+char *aa_get_path(gfp_t gfp)
+{
+	struct aa_path_cache_head *cache;
+	char *path;
+
+	cache = &get_cpu_var(aa_path_cache);
+	if (cache->count) {
+		struct list_head *node;
+		list_for_each(node, &cache->list) {
+			list_del(node);
+			break;
+		}
+		cache->count--;
+		path = (char *) node;
+		put_cpu_var(aa_path_cache);
+	} else {
+		put_cpu_var(aa_path_cache);
+		path = (char *) __get_free_page(gfp);
+	}
+	return path;
+}
+
+/**
+ * aa_put_path - put a path buffer obtained with aa_get_path
+ * @path: the path buffer to return to the path buffer cache
+ */
+void aa_put_path(char *path)
+{
+	if (!path)
+		goto out;
+
+	/* does the path buffer belong on the current cpu's node */
+	if (cpu_to_node(smp_processor_id()) ==
+	    page_to_nid(virt_to_page(path))) {
+		struct aa_path_cache_head *cache = &get_cpu_var(aa_path_cache);
+		int success = aa_push_path(cache, path);
+		put_cpu_var(aa_path_cache);
+		if (success)
+			goto out;
+	}
+	free_page((unsigned long) path);
+
+out:
+	return;
+}
+
 /* NULL complain profile
  *
  * Used when in complain mode, to emit Permitting messages for non-existant
@@ -545,7 +666,7 @@ char *aa_get_name(struct dentry *dentry,
 {
 	char *page, *name;
 
-	page = (char *)__get_free_page(GFP_KERNEL);
+	page = (char *)aa_get_path(GFP_KERNEL);
 	if (!page) {
 		name = ERR_PTR(-ENOMEM);
 		goto out;
@@ -557,7 +678,7 @@ char *aa_get_name(struct dentry *dentry,
 	 * The size > deleted_size and strcmp checks are redundant safe guards.
 	 */
 	if (IS_ERR(name)) {
-		free_page((unsigned long)page);
+		aa_put_path(page);
 	} else {
 		const char deleted_str[] = " (deleted)";
 		const size_t deleted_size = sizeof(deleted_str) - 1;
