---
 security/apparmor/apparmor.h |    2 ++
 security/apparmor/lsm.c      |   34 +++++++++++++++-------------------
 security/apparmor/main.c     |   35 +++++++++++++++++++++++++++++++----
 3 files changed, 48 insertions(+), 23 deletions(-)

--- a/security/apparmor/apparmor.h
+++ b/security/apparmor/apparmor.h
@@ -238,6 +238,8 @@ extern struct aa_task_context *lock_task
 extern void aa_change_task_context(struct task_struct *task,
 				   struct aa_task_context *new_cxt,
 				   struct aa_profile *profile, u64 hat_magic);
+extern int aa_may_ptrace(struct aa_task_context *cxt,
+			 struct aa_profile *tracee);
 
 /* list.c */
 extern void aa_profilelist_release(void);
--- a/security/apparmor/lsm.c
+++ b/security/apparmor/lsm.c
@@ -73,30 +73,26 @@ static int aa_reject_syscall(struct task
 }
 
 static int apparmor_ptrace(struct task_struct *parent,
-			    struct task_struct *child)
+			   struct task_struct *child)
 {
-	int error;
+	struct aa_task_context *cxt;
+	struct aa_task_context *child_cxt;
+	struct aa_profile *child_profile;
+	int error = 0;
 
 	/**
-	 * Right now, we only allow confined processes to ptrace other
-	 * processes if they have CAP_SYS_PTRACE. We could allow ptrace
-	 * under the rules that the kernel normally permits if the two
-	 * processes are running under the same profile, but then we
-	 * would probably have to reject profile changes for processes
-	 * that are being ptraced as well as for processes ptracing
-	 * others.
+	 * parent can ptrace child when
+	 * - parent is unconfined
+	 * - parent is in complain mode
+	 * - parent and child are confined by the same profile
 	 */
 
-	error = cap_ptrace(parent, child);
-	if (!error) {
-		struct aa_task_context *cxt;
-
-		rcu_read_lock();
-		cxt = aa_task_context(parent);
-		if (cxt)
-			error = aa_capability(cxt, CAP_SYS_PTRACE);
-		rcu_read_unlock();
-	}
+	rcu_read_lock();
+	cxt = aa_task_context(parent);
+	child_cxt = aa_task_context(child);
+	child_profile = child_cxt ? child_cxt->profile : NULL;
+	error = aa_may_ptrace(cxt, child_profile);
+	rcu_read_unlock();
 
 	return error;
 }
--- a/security/apparmor/main.c
+++ b/security/apparmor/main.c
@@ -13,6 +13,7 @@
 #include <linux/namei.h>
 #include <linux/audit.h>
 #include <linux/mount.h>
+#include <linux/ptrace.h>
 
 #include "apparmor.h"
 
@@ -703,6 +704,15 @@ int aa_capability(struct aa_task_context
 	return error;
 }
 
+/* must be used inside rcu_read_lock or task_lock */
+int aa_may_ptrace(struct aa_task_context *cxt, struct aa_profile *tracee)
+{
+	if (!cxt || cxt->profile == null_complain_profile ||
+	    cxt->profile == tracee)
+		return 0;
+	return aa_capability(cxt, CAP_SYS_PTRACE);
+}
+
 /**
  * aa_link - hard link check
  * @profile: profile to check against
@@ -953,6 +963,14 @@ repeat:
 		aa_put_profile(profile);
 		if (PTR_ERR(old_profile) == -ESTALE)
 			goto repeat;
+		if (PTR_ERR(old_profile) == -EPERM)
+			AA_WARN(GFP_KERNEL,
+				"Rejecting exec(2) of image '%s'. "
+				"Unable to change profile due to ptrace. ",
+				"(%s (pid %d) profile %s active %s)\n",
+				filename,
+				current->comm, current->pid,
+				profile->parent->name, profile->name);
 		new_profile = old_profile;
 		goto cleanup;
 	}
@@ -1041,9 +1059,8 @@ repeat:
  *
  * Switch to a new hat.  Returns %0 on success, error otherwise.
  */
-static inline int do_change_hat(const char *hat_name,
-				struct aa_task_context *new_cxt,
-				u64 hat_magic)
+static int do_change_hat(const char *hat_name,
+			 struct aa_task_context *new_cxt, u64 hat_magic)
 {
 	struct aa_task_context *cxt = aa_task_context(current);
 	struct aa_profile *sub;
@@ -1054,6 +1071,10 @@ static inline int do_change_hat(const ch
 	 * no need to grab an additional reference count.
 	 */
 	sub = __aa_find_profile(hat_name, &cxt->profile->parent->sub);
+
+	if ((current->ptrace & PT_PTRACED) && aa_may_ptrace(cxt, sub))
+		return -EPERM;
+
 	if (sub) {
 		/* change hat */
 		aa_change_task_context(current, new_cxt, sub, hat_magic);
@@ -1232,6 +1253,13 @@ struct aa_profile *__aa_replace_profile(
 		return ERR_PTR(-ESTALE);
 	}
 
+	if ((current->ptrace & PT_PTRACED) && aa_may_ptrace(cxt, profile)) {
+		task_unlock(task);
+		unlock_both_profiles(profile, cxt ? cxt->profile : NULL);
+		aa_free_task_context(new_cxt);
+		return ERR_PTR(-EPERM);
+	}
+
 	if (cxt) {
 		old_profile = aa_dup_profile(cxt->profile);
 		aa_change_task_context(task, new_cxt, profile, cxt->hat_magic);
@@ -1240,7 +1268,6 @@ struct aa_profile *__aa_replace_profile(
 
 	task_unlock(task);
 	unlock_both_profiles(profile, old_profile);
-
 	return old_profile;
 }
 
