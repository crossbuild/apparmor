---
 security/apparmor/apparmor.h |    3 +++
 security/apparmor/lsm.c      |   39 ++++++++++++++++++++-------------------
 security/apparmor/main.c     |   34 ++++++++++++++++++++++++++++++----
 3 files changed, 53 insertions(+), 23 deletions(-)

--- a/security/apparmor/apparmor.h
+++ b/security/apparmor/apparmor.h
@@ -189,6 +189,7 @@ struct aa_audit {
 #define HINT_FORK "fork"
 #define HINT_MANDPROF "missing_mandatory_profile"
 #define HINT_CHGPROF "changing_profile"
+#define HINT_PTRACE "ptrace"
 
 #define LOG_HINT(p, gfp, hint, fmt, args...) \
 	do {\
@@ -238,6 +239,8 @@ extern struct aa_task_context *lock_task
 extern void aa_change_task_context(struct task_struct *task,
 				   struct aa_task_context *new_cxt,
 				   struct aa_profile *profile, u64 hat_magic);
+extern int aa_may_ptrace(struct aa_task_context *cxt,
+			 struct aa_profile *tracee);
 
 /* list.c */
 extern void aa_profilelist_release(void);
--- a/security/apparmor/lsm.c
+++ b/security/apparmor/lsm.c
@@ -71,30 +71,31 @@ static int aa_reject_syscall(struct task
 }
 
 static int apparmor_ptrace(struct task_struct *parent,
-			    struct task_struct *child)
+			   struct task_struct *child)
 {
-	int error;
+	struct aa_task_context *cxt;
+	struct aa_task_context *child_cxt;
+	struct aa_profile *child_profile;
+	int error = 0;
 
 	/**
-	 * Right now, we only allow confined processes to ptrace other
-	 * processes if they have CAP_SYS_PTRACE. We could allow ptrace
-	 * under the rules that the kernel normally permits if the two
-	 * processes are running under the same profile, but then we
-	 * would probably have to reject profile changes for processes
-	 * that are being ptraced as well as for processes ptracing
-	 * others.
+	 * parent can ptrace child when
+	 * - parent is unconfined
+	 * - parent is in complain mode
+	 * - parent and child are confined by the same profile
 	 */
 
-	error = cap_ptrace(parent, child);
-	if (!error) {
-		struct aa_task_context *cxt;
-
-		rcu_read_lock();
-		cxt = aa_task_context(parent);
-		if (cxt)
-			error = aa_capability(cxt, CAP_SYS_PTRACE);
-		rcu_read_unlock();
-	}
+	rcu_read_lock();
+	cxt = aa_task_context(parent);
+	child_cxt = aa_task_context(child);
+	child_profile = child_cxt ? child_cxt->profile : NULL;
+	error = aa_may_ptrace(cxt, child_profile);
+	if (cxt && PROFILE_COMPLAIN(cxt->profile)) {
+		LOG_HINT(cxt->profile, GFP_ATOMIC, HINT_PTRACE,
+				 "pid=%d child=%d\n",
+				 current->pid, child->pid);
+		}
+	rcu_read_unlock();
 
 	return error;
 }
--- a/security/apparmor/main.c
+++ b/security/apparmor/main.c
@@ -13,6 +13,7 @@
 #include <linux/namei.h>
 #include <linux/audit.h>
 #include <linux/mount.h>
+#include <linux/ptrace.h>
 
 #include "apparmor.h"
 
@@ -703,6 +704,14 @@ int aa_capability(struct aa_task_context
 	return error;
 }
 
+/* must be used inside rcu_read_lock or task_lock */
+int aa_may_ptrace(struct aa_task_context *cxt, struct aa_profile *tracee)
+{
+	if (!cxt || cxt->profile == tracee)
+		return 0;
+	return aa_capability(cxt, CAP_SYS_PTRACE);
+}
+
 /**
  * aa_link - hard link check
  * @profile: profile to check against
@@ -953,6 +962,14 @@ repeat:
 		aa_put_profile(profile);
 		if (PTR_ERR(old_profile) == -ESTALE)
 			goto repeat;
+		if (PTR_ERR(old_profile) == -EPERM)
+			AA_WARN(GFP_KERNEL,
+				"Rejecting exec(2) of image '%s'. "
+				"Unable to change profile, ptraced by %d. ",
+				"(%s (pid %d) profile %s active %s)\n",
+				filename, current->parent->pid,
+				current->comm, current->pid,
+				profile->parent->name, profile->name);
 		new_profile = old_profile;
 		goto cleanup;
 	}
@@ -1041,9 +1058,8 @@ repeat:
  *
  * Switch to a new hat.  Returns %0 on success, error otherwise.
  */
-static inline int do_change_hat(const char *hat_name,
-				struct aa_task_context *new_cxt,
-				u64 hat_magic)
+static int do_change_hat(const char *hat_name,
+			 struct aa_task_context *new_cxt, u64 hat_magic)
 {
 	struct aa_task_context *cxt = aa_task_context(current);
 	struct aa_profile *sub;
@@ -1054,6 +1070,10 @@ static inline int do_change_hat(const ch
 	 * no need to grab an additional reference count.
 	 */
 	sub = __aa_find_profile(hat_name, &cxt->profile->parent->sub);
+
+	if ((current->ptrace & PT_PTRACED) && aa_may_ptrace(cxt, sub))
+		return -EPERM;
+
 	if (sub) {
 		/* change hat */
 		aa_change_task_context(current, new_cxt, sub, hat_magic);
@@ -1232,6 +1252,13 @@ struct aa_profile *__aa_replace_profile(
 		return ERR_PTR(-ESTALE);
 	}
 
+	if ((current->ptrace & PT_PTRACED) && aa_may_ptrace(cxt, profile)) {
+		task_unlock(task);
+		unlock_both_profiles(profile, cxt ? cxt->profile : NULL);
+		aa_free_task_context(new_cxt);
+		return ERR_PTR(-EPERM);
+	}
+
 	if (cxt) {
 		old_profile = aa_dup_profile(cxt->profile);
 		aa_change_task_context(task, new_cxt, profile, cxt->hat_magic);
@@ -1240,7 +1267,6 @@ struct aa_profile *__aa_replace_profile(
 
 	task_unlock(task);
 	unlock_both_profiles(profile, old_profile);
-
 	return old_profile;
 }
 
