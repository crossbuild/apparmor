---
 security/apparmor/apparmor.h |    1 +
 security/apparmor/lsm.c      |   28 +++++++++++++++++++++++++---
 security/apparmor/main.c     |   16 ++++++++++++++++
 3 files changed, 42 insertions(+), 3 deletions(-)

--- a/security/apparmor/apparmor.h
+++ b/security/apparmor/apparmor.h
@@ -230,6 +230,7 @@ extern int aa_perm(struct aa_profile *pr
 		   struct vfsmount *mnt, int mask, int check);
 extern int aa_perm_dir(struct aa_profile *profile, struct dentry *dentry,
 		       struct vfsmount *mnt, const char *operation, int mask);
+extern int aa_perm_path(struct aa_profile *, const char *, int);
 extern int aa_link(struct aa_profile *profile,
 		   struct dentry *link, struct vfsmount *link_mnt,
 		   struct dentry *target, struct vfsmount *target_mnt);
--- a/security/apparmor/lsm.c
+++ b/security/apparmor/lsm.c
@@ -16,6 +16,7 @@
 #include <linux/mount.h>
 #include <linux/namei.h>
 #include <linux/ctype.h>
+#include <linux/sysctl.h>
 
 #include "apparmor.h"
 #include "inline.h"
@@ -164,12 +165,33 @@ static int apparmor_capable(struct task_
 
 static int apparmor_sysctl(struct ctl_table *table, int op)
 {
+	struct aa_profile *profile = aa_get_profile(current);
 	int error = 0;
 
-	if ((op & 002) && !capable(CAP_SYS_ADMIN))
-		error = aa_reject_syscall(current, GFP_KERNEL,
-					  "sysctl (write)");
+	if (profile) {
+		char *buffer, *name;
+		int mask;
 
+		mask = 0;
+		if (op & 4)
+			mask |= MAY_READ;
+		if (op & 2)
+			mask |= MAY_WRITE;
+
+		error = -ENOMEM;
+		buffer = (char*)__get_free_page(GFP_KERNEL);
+		if (!buffer)
+			goto out;
+		name = sysctl_pathname(table, buffer, PAGE_SIZE);
+		if (name && name - buffer >= 5) {
+			name -= 5;
+			memcpy(name, "/proc", 5);
+			error = aa_perm_path(profile, name, mask);
+		}
+		free_page((unsigned long)buffer);
+	}
+
+out:
 	return error;
 }
 
--- a/security/apparmor/main.c
+++ b/security/apparmor/main.c
@@ -634,6 +634,22 @@ int aa_perm_dir(struct aa_profile *profi
 			      AA_CHECK_DIR | AA_CHECK_LEAF);
 }
 
+int aa_perm_path(struct aa_profile *profile, const char *name, int mask)
+{
+	struct aa_audit sa;
+	int denied_mask;
+
+	sa.type = AA_AUDITTYPE_FILE;
+	sa.mask = mask;
+	sa.flags = 0;
+	sa.gfp_mask = GFP_KERNEL;
+
+	denied_mask = aa_file_denied(profile, name, mask);
+	aa_permerror2result(denied_mask, &sa);
+
+	return aa_audit(profile, &sa);
+}
+
 /**
  * aa_capability - test permission to use capability
  * @cxt: aa_task_context with profile to check against
