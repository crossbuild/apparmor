Index: linux-2.6/security/apparmor/apparmor.h
===================================================================
--- linux-2.6.orig/security/apparmor/apparmor.h
+++ linux-2.6/security/apparmor/apparmor.h
@@ -188,16 +188,6 @@ struct subdomain {
 
 typedef int (*aa_iter) (struct subdomain *, void *);
 
-/* aa_path_data
- * temp (cookie) data used by aa_path_* functions, see inline.h
- */
-struct aa_path_data {
-	struct dentry *root, *dentry;
-	struct namespace *namespace;
-	struct list_head *head, *pos;
-	int errno;
-};
-
 #define AA_SUBDOMAIN(sec)	((struct subdomain*)(sec))
 #define AA_PROFILE(sec)		((struct aaprofile*)(sec))
 
@@ -281,20 +271,18 @@ extern int aa_audit(struct aaprofile *ac
 extern char *aa_get_name(struct dentry *dentry, struct vfsmount *mnt);
 
 extern int aa_attr(struct aaprofile *active, struct dentry *dentry,
-		   struct iattr *iattr);
+		   struct vfsmount *mnt, struct iattr *iattr);
 extern int aa_xattr(struct aaprofile *active, struct dentry *dentry,
+		    struct vfsmount *mnt,
 		    const char *xattr, enum aa_xattroptype xattroptype);
 extern int aa_capability(struct aaprofile *active, int cap);
 extern int aa_perm(struct aaprofile *active, struct dentry *dentry,
 		   struct vfsmount *mnt, int mask);
-extern int aa_perm_nameidata(struct aaprofile *active, struct nameidata *nd,
-			     int mask);
-extern int aa_perm_dentry(struct aaprofile *active, struct dentry *dentry,
-			  int mask);
 extern int aa_perm_dir(struct aaprofile *active, struct dentry *dentry,
-		       enum aa_diroptype diroptype);
+		       struct vfsmount *mnt, enum aa_diroptype diroptype);
 extern int aa_link(struct aaprofile *active,
-		   struct dentry *link, struct dentry *target);
+		   struct dentry *link, struct vfsmount *link_mnt,
+		   struct dentry *target, struct vfsmount *target_mnt);
 extern int aa_fork(struct task_struct *p);
 extern int aa_register(struct linux_binprm *bprm);
 extern void aa_release(struct task_struct *p);
Index: linux-2.6/security/apparmor/inline.h
===================================================================
--- linux-2.6.orig/security/apparmor/inline.h
+++ linux-2.6/security/apparmor/inline.h
@@ -10,7 +10,7 @@
 #ifndef __INLINE_H
 #define __INLINE_H
 
-#include <linux/namespace.h>
+#include <linux/sched.h>
 
 static inline int __aa_is_confined(struct subdomain *sd)
 {
@@ -252,84 +252,4 @@ static inline struct aaprofile *__aa_fin
 	}
 	return NULL;
 }
-
-/** __aa_path_begin
- * @rdentry: filesystem root dentry (searching for vfsmnts matching this)
- * @dentry: dentry object to obtain pathname from (relative to matched vfsmnt)
- *
- * Setup data for iterating over vfsmounts (in current tasks namespace).
- */
-static inline void __aa_path_begin(struct dentry *rdentry,
-				   struct dentry *dentry,
-				   struct aa_path_data *data)
-{
-	data->dentry = dentry;
-	data->root = dget(rdentry->d_sb->s_root);
-	data->namespace = current->namespace;
-	data->head = &data->namespace->list;
-	data->pos = data->head->next;
-	prefetch(data->pos->next);
-	data->errno = 0;
-
-	down_read(&namespace_sem);
-}
-
-/** aa_path_begin
- * @dentry: filesystem root dentry and object to obtain pathname from
- *
- * Utility function for calling _aa_path_begin for when the dentry we are
- * looking for and the root are the same (this is the usual case).
- */
-static inline void aa_path_begin(struct dentry *dentry,
-				     struct aa_path_data *data)
-{
-	__aa_path_begin(dentry, dentry, data);
-}
-
-/** aa_path_end
- * @data: data object previously initialized by aa_path_begin
- *
- * End iterating over vfsmounts.
- * If an error occured in begin or get, it is returned. Otherwise 0.
- */
-static inline int aa_path_end(struct aa_path_data *data)
-{
-	up_read(&namespace_sem);
-	dput(data->root);
-
-	return data->errno;
-}
-
-/** aa_path_getname
- * @data: data object previously initialized by aa_path_begin
- *
- * Return the next mountpoint which has the same root dentry as data->root.
- * If no more mount points exist (or in case of error) NULL is returned
- * (caller should call aa_path_end() and inspect return code to differentiate)
- */
-static inline char *aa_path_getname(struct aa_path_data *data)
-{
-	char *name = NULL;
-	struct vfsmount *mnt;
-
-	while (data->pos != data->head) {
-		mnt = list_entry(data->pos, struct vfsmount, mnt_list);
-
-		/* advance to next -- so that it is done before we break */
-		data->pos = data->pos->next;
-		prefetch(data->pos->next);
-
-		if (mnt->mnt_root == data->root) {
-			name = aa_get_name(data->dentry, mnt);
-			if (IS_ERR(name)) {
-				data->errno = PTR_ERR(name);
-				name = NULL;
-			}
-			break;
-		}
-	}
-
-	return name;
-}
-
 #endif /* __INLINE_H__ */
Index: linux-2.6/security/apparmor/lsm.c
===================================================================
--- linux-2.6.orig/security/apparmor/lsm.c
+++ linux-2.6/security/apparmor/lsm.c
@@ -15,6 +15,8 @@
 #include <linux/module.h>
 #include <linux/mm.h>
 #include <linux/mman.h>
+#include <linux/mount.h>
+#include <linux/namei.h>
 
 #include "apparmor.h"
 #include "inline.h"
@@ -247,121 +249,157 @@ static int apparmor_umount(struct vfsmou
 }
 
 static int apparmor_inode_mkdir(struct inode *inode, struct dentry *dentry,
-				 int mask)
+				struct vfsmount *mnt, int mask)
 {
 	struct aaprofile *active;
 	int error = 0;
 
+	if (!mnt)
+		goto out;
+
 	active = get_active_aaprofile();
 
 	if (active)
-		error = aa_perm_dir(active, dentry, aa_dir_mkdir);
+		error = aa_perm_dir(active, dentry, mnt, aa_dir_mkdir);
 
 	put_aaprofile(active);
 
+out:
 	return error;
 }
 
-static int apparmor_inode_rmdir(struct inode *inode, struct dentry *dentry)
+static int apparmor_inode_rmdir(struct inode *inode, struct dentry *dentry,
+				struct vfsmount *mnt)
 {
 	struct aaprofile *active;
 	int error = 0;
 
+	if (!mnt)
+		goto out;
+
 	active = get_active_aaprofile();
 
 	if (active)
-		error = aa_perm_dir(active, dentry, aa_dir_rmdir);
+		error = aa_perm_dir(active, dentry, mnt, aa_dir_rmdir);
 
 	put_aaprofile(active);
 
+out:
 	return error;
 }
 
 static int apparmor_inode_create(struct inode *inode, struct dentry *dentry,
-				  int mask)
+				 struct vfsmount *mnt, int mask)
 {
 	struct aaprofile *active;
 	int error = 0;
 
+	if (!mnt)
+		goto out;
+
 	active = get_active_aaprofile();
 
 	/* At a minimum, need write perm to create */
 	if (active)
-		error = aa_perm_dentry(active, dentry, MAY_WRITE);
+		error = aa_perm(active, dentry, mnt, MAY_WRITE);
 
 	put_aaprofile(active);
-
+out:
 	return error;
 }
 
-static int apparmor_inode_link(struct dentry *old_dentry, struct inode *inode,
-				struct dentry *new_dentry)
+static int apparmor_inode_link(struct dentry *old_dentry,
+			       struct vfsmount *old_mnt, struct inode *inode,
+			       struct dentry *new_dentry,
+			       struct vfsmount *new_mnt)
 {
 	int error = 0;
 	struct aaprofile *active;
 
+	if (!old_mnt || !new_mnt)
+		goto out;
+
 	active = get_active_aaprofile();
 
 	if (active)
-		error = aa_link(active, new_dentry, old_dentry);
+		error = aa_link(active, new_dentry, new_mnt,
+				old_dentry, old_mnt);
 
 	put_aaprofile(active);
 
+out:
 	return error;
 }
 
-static int apparmor_inode_unlink(struct inode *inode, struct dentry *dentry)
+static int apparmor_inode_unlink(struct inode *dir,
+				 struct dentry *dentry,
+				 struct vfsmount *mnt)
 {
 	struct aaprofile *active;
 	int error = 0;
 
+	if (!mnt)
+		goto out;
+
 	active = get_active_aaprofile();
 
 	if (active)
-		error = aa_perm_dentry(active, dentry, MAY_WRITE);
+		error = aa_perm(active, dentry, mnt, MAY_WRITE);
 
 	put_aaprofile(active);
 
+out:
 	return error;
 }
 
 static int apparmor_inode_mknod(struct inode *inode, struct dentry *dentry,
-				 int mode, dev_t dev)
+				struct vfsmount *mnt, int mode, dev_t dev)
 {
 	struct aaprofile *active;
 	int error = 0;
 
+	if (!mnt)
+		goto out;
+
 	active = get_active_aaprofile();
 
 	if (active)
-		error = aa_perm_dentry(active, dentry, MAY_WRITE);
+		error = aa_perm(active, dentry, mnt, MAY_WRITE);
 
 	put_aaprofile(active);
 
+out:
 	return error;
 }
 
 static int apparmor_inode_rename(struct inode *old_inode,
-				  struct dentry *old_dentry,
-				  struct inode *new_inode,
-				  struct dentry *new_dentry)
+				 struct dentry *old_dentry,
+				 struct vfsmount *old_mnt,
+				 struct inode *new_inode,
+				 struct dentry *new_dentry,
+				 struct vfsmount *new_mnt)
 {
 	struct aaprofile *active;
 	int error = 0;
 
+	if (!old_mnt && !new_mnt)
+		goto out;
+
 	active = get_active_aaprofile();
 
 	if (active) {
-		error = aa_perm_dentry(active, old_dentry, MAY_READ |
-				       MAY_WRITE);
-
-		if (!error)
-			error = aa_perm_dentry(active, new_dentry,
-					       MAY_WRITE);
+		if (old_mnt)
+			error = aa_perm(active, old_dentry, old_mnt,
+					MAY_READ|MAY_WRITE);
+
+		if (!error && new_mnt)
+			error = aa_perm(active, new_dentry, new_mnt,
+					MAY_WRITE);
 	}
 
 	put_aaprofile(active);
 
+out:
 	return error;
 }
 
@@ -373,22 +411,26 @@ static int apparmor_inode_permission(str
 	/* Do not perform check on pipes or sockets
 	 * Same as apparmor_file_permission
 	 */
-	if (VALID_FSTYPE(inode)) {
+	if (nd && VALID_FSTYPE(inode)) {
 		struct aaprofile *active;
 
 		active = get_active_aaprofile();
 		if (active)
-			error = aa_perm_nameidata(active, nd, mask);
+			error = aa_perm(active, nd->dentry, nd->mnt, mask);
 		put_aaprofile(active);
 	}
 
 	return error;
 }
 
-static int apparmor_inode_setattr(struct dentry *dentry, struct iattr *iattr)
+static int apparmor_inode_setattr(struct dentry *dentry, struct vfsmount *mnt,
+				  struct iattr *iattr)
 {
 	int error = 0;
 
+	if (!mnt)
+		goto out;
+
 	if (VALID_FSTYPE(dentry->d_inode)) {
 		struct aaprofile *active;
 
@@ -398,76 +440,99 @@ static int apparmor_inode_setattr(struct
 		 * (chmod, chown, chgrp, etc)
 		 */
 		if (active)
-			error = aa_attr(active, dentry, iattr);
+			error = aa_attr(active, dentry, mnt, iattr);
 
 		put_aaprofile(active);
 	}
 
+out:
 	return error;
 }
 
-static int apparmor_inode_setxattr(struct dentry *dentry, char *name,
-				    void *value, size_t size, int flags)
+static int apparmor_inode_setxattr(struct dentry *dentry, struct vfsmount *mnt,
+				   char *name, void *value, size_t size,
+				   int flags)
 {
 	int error = 0;
 
+	if (!mnt)
+		goto out;
+
 	if (VALID_FSTYPE(dentry->d_inode)) {
 		struct aaprofile *active;
 
 		active = get_active_aaprofile();
 		if (active)
-			error = aa_xattr(active, dentry, name, aa_xattr_set);
+			error = aa_xattr(active, dentry, mnt, name,
+					 aa_xattr_set);
 		put_aaprofile(active);
 	}
 
+out:
 	return error;
 }
 
-static int apparmor_inode_getxattr(struct dentry *dentry, char *name)
+static int apparmor_inode_getxattr(struct dentry *dentry, struct vfsmount *mnt,
+				   char *name)
 {
 	int error = 0;
 
+	if (!mnt)
+		goto out;
+
 	if (VALID_FSTYPE(dentry->d_inode)) {
 		struct aaprofile *active;
 
 		active = get_active_aaprofile();
 		if (active)
-			error = aa_xattr(active, dentry, name, aa_xattr_get);
+			error = aa_xattr(active, dentry, mnt, name,
+					 aa_xattr_get);
 		put_aaprofile(active);
 	}
 
+out:
 	return error;
 }
-static int apparmor_inode_listxattr(struct dentry *dentry)
+static int apparmor_inode_listxattr(struct dentry *dentry, struct vfsmount *mnt)
 {
 	int error = 0;
 
+	if (!mnt)
+		goto out;
+
 	if (VALID_FSTYPE(dentry->d_inode)) {
 		struct aaprofile *active;
 
 		active = get_active_aaprofile();
 		if (active)
-			error = aa_xattr(active, dentry, NULL, aa_xattr_list);
+			error = aa_xattr(active, dentry, mnt, NULL,
+					 aa_xattr_list);
 		put_aaprofile(active);
 	}
 
+out:
 	return error;
 }
 
-static int apparmor_inode_removexattr(struct dentry *dentry, char *name)
+static int apparmor_inode_removexattr(struct dentry *dentry,
+				      struct vfsmount *mnt, char *name)
 {
 	int error = 0;
 
+	if (!mnt)
+		goto out;
+
 	if (VALID_FSTYPE(dentry->d_inode)) {
 		struct aaprofile *active;
 
 		active = get_active_aaprofile();
 		if (active)
-			error = aa_xattr(active, dentry, name,
+			error = aa_xattr(active, dentry, mnt, name,
 					 aa_xattr_remove);
 		put_aaprofile(active);
 	}
 
+out:
 	return error;
 }
 
Index: linux-2.6/security/apparmor/main.c
===================================================================
--- linux-2.6.orig/security/apparmor/main.c
+++ linux-2.6/security/apparmor/main.c
@@ -35,34 +35,6 @@ struct aaprofile *null_complain_profile;
  **************************/
 
 /**
- * dentry_xlate_error
- * @dentry: pointer to dentry
- * @error: error number
- * @dtype: type of dentry
- *
- * Display error message when a dentry translation error occured
- */
-static void dentry_xlate_error(struct dentry *dentry, int error, char *dtype)
-{
-	const unsigned int len = 16;
-	char buf[len];
-
-	if (dentry->d_inode) {
-		snprintf(buf, len, "%lu", dentry->d_inode->i_ino);
-	} else {
-		strncpy(buf, "<negative>", len);
-		buf[len-1]=0;
-	}
-
-	AA_ERROR("An error occured while translating %s %p "
-		 "inode# %s to a pathname. Error %d\n",
-		 dtype,
-		 dentry,
-		 buf,
-		 error);
-}
-
-/**
  * aa_taskattr_access
  * @procrelname: name of file to check permission
  *
@@ -345,12 +317,12 @@ done:
  *
  * Look up permission mode on both @link and @target.  @link must have same
  * permission mode as @target.  At least @link must have the link bit enabled.
- * Return %0 on success, error otherwise.
+ * Return %0 on success, else -EPERM
  */
 static int aa_link_perm(struct aaprofile *active,
 			const char *link, const char *target)
 {
-	int l_mode, t_mode, ret;
+	int l_mode, t_mode, ret = -EPERM;
 
 	l_mode = aa_file_mode(active, link);
 	if (l_mode & AA_MAY_LINK) {
@@ -360,76 +332,32 @@ static int aa_link_perm(struct aaprofile
 		t_mode = aa_file_mode(active, target);
 		t_mode &= ~AA_MAY_LINK;
 
-		ret = (l_mode == t_mode);
-	} else {
-		ret = 0;
+		if (l_mode == t_mode)
+			ret = 0;
 	}
 
 	return ret;
 }
 
-/**
- * _aa_perm_dentry
- * @active: profile to check against
- * @dentry: requested dentry
- * @mask: mask of requested operations
- * @pname: pointer to hold matched pathname (if any)
- *
- * Helper function.  Obtain pathname for specified dentry. Verify if profile
- * authorizes mask operations on pathname (due to lack of vfsmnt it is sadly
- * necessary to search mountpoints in namespace -- when nameidata is passed
- * more fully, this code can go away).  If more than one mountpoint matches
- * but none satisfy the profile, only the first pathname (mountpoint) is
- * returned for subsequent logging.
- *
- * Return %0 (success), +ve (mask of permissions not satisfied) or -ve (system
- * error, most likely -%ENOMEM).
- */
-static int _aa_perm_dentry(struct aaprofile *active, struct dentry *dentry,
-			   int mask, const char **pname)
+static int _aa_perm_vfsmount(struct aaprofile *active, struct dentry *dentry,
+		      struct vfsmount *mnt, struct aa_audit *sa, int mask)
 {
-	char *name = NULL, *failed_name = NULL;
-	struct aa_path_data data;
-	int error = 0, failed_error = 0, path_error,
-	    complain = PROFILE_COMPLAIN(active);
-
-	/* search all paths to dentry */
-
-	aa_path_begin(dentry, &data);
-	do {
-		name = aa_path_getname(&data);
-		if (name) {
-			/* error here is 0 (success) or +ve (mask of perms) */
-			error = aa_file_perm(active, name, mask);
-
-			/* access via any path is enough */
-			if (complain || error == 0)
-				break; /* Caller must free name */
-
-			/* Already have an path that failed? */
-			if (failed_name) {
-				aa_put_name(name);
-			} else {
-				failed_name = name;
-				failed_error = error;
-			}
-		}
-	} while (name);
+	int permerror, error;
+
+	sa->name = aa_get_name(dentry, mnt);
 
-	if ((path_error = aa_path_end(&data)) != 0) {
-		dentry_xlate_error(dentry, path_error, "dentry");
-		WARN_ON(name);	/* name should not be set if error */
-		error = path_error;
-		name = NULL;
-	} else if (name) {
-		if (failed_name)
-			aa_put_name(failed_name);
+	if (IS_ERR(sa->name)) {
+		permerror = PTR_ERR(sa->name);
+		sa->name = NULL;
 	} else {
-		name = failed_name;
-		error = failed_error;
+		permerror = aa_file_perm(active, sa->name, mask);
 	}
 
-	*pname = name;
+	aa_permerror2result(permerror, sa);
+
+	error = aa_audit(active, sa);
+
+	aa_put_name(sa->name);
 
 	return error;
 }
@@ -803,9 +731,9 @@ out:
  * @iattr: attribute changes requested
  */
 int aa_attr(struct aaprofile *active, struct dentry *dentry,
-	    struct iattr *iattr)
+	    struct vfsmount *mnt, struct iattr *iattr)
 {
-	int error = 0, permerror;
+	int error;
 	struct aa_audit sa;
 
 	sa.type = AA_AUDITTYPE_ATTR;
@@ -813,12 +741,7 @@ int aa_attr(struct aaprofile *active, st
 	sa.flags = 0;
 	sa.gfp_mask = GFP_KERNEL;
 
-	permerror = _aa_perm_dentry(active, dentry, MAY_WRITE, &sa.name);
-	aa_permerror2result(permerror, &sa);
-
-	error = aa_audit(active, &sa);
-
-	aa_put_name(sa.name);
+	error = _aa_perm_vfsmount(active, dentry, mnt, &sa, MAY_WRITE);
 
 	return error;
 }
@@ -831,15 +754,12 @@ int aa_attr(struct aaprofile *active, st
  * @xattroptype: type of xattr operation
  */
 int aa_xattr(struct aaprofile *active, struct dentry *dentry,
-	     const char *xattr, enum aa_xattroptype xattroptype)
+	     struct vfsmount *mnt, const char *xattr,
+	     enum aa_xattroptype xattroptype)
 {
-	int error = 0, permerror, mask = 0;
+	int error = 0, mask = 0;
 	struct aa_audit sa;
 
-	/* if not confined or empty mask permission granted */
-	if (!active)
-		goto out;
-
 	if (xattroptype == aa_xattr_get || xattroptype == aa_xattr_list)
 		mask = MAY_READ;
 	else if (xattroptype == aa_xattr_set || xattroptype == aa_xattr_remove)
@@ -851,14 +771,8 @@ int aa_xattr(struct aaprofile *active, s
 	sa.flags = 0;
 	sa.gfp_mask = GFP_KERNEL;
 
-	permerror = _aa_perm_dentry(active, dentry, mask, &sa.name);
-	aa_permerror2result(permerror, &sa);
-
-	error = aa_audit(active, &sa);
-
-	aa_put_name(sa.name);
+	error = _aa_perm_vfsmount(active, dentry, mnt, &sa, mask);
 
-out:
 	return error;
 }
 
@@ -875,71 +789,9 @@ out:
 int aa_perm(struct aaprofile *active, struct dentry *dentry,
 	    struct vfsmount *mnt, int mask)
 {
-	int error = 0, permerror;
-	struct aa_audit sa;
-
-	if (!active)
-		goto out;
-
-	if ((mask = aa_filter_mask(mask, dentry->d_inode)) == 0)
-		goto out;
-
-	sa.type = AA_AUDITTYPE_FILE;
-	sa.name = aa_get_name(dentry, mnt);
-	sa.ival = mask;
-	sa.flags = 0;
-	sa.gfp_mask = GFP_KERNEL;
-
-	if (IS_ERR(sa.name)) {
-		permerror = PTR_ERR(sa.name);
-		sa.name = NULL;
-	} else {
-		permerror = aa_file_perm(active, sa.name, mask);
-	}
-
-	aa_permerror2result(permerror, &sa);
-
-	error = aa_audit(active, &sa);
-
-	aa_put_name(sa.name);
-
-out:
-	return error;
-}
-
-/**
- * aa_perm_nameidata: interface to sd_perm accepting nameidata
- * @active: profile to check against
- * @nd: namespace data (for vfsmnt and dentry)
- * @mask: access mode requested
- */
-int aa_perm_nameidata(struct aaprofile *active, struct nameidata *nd, int mask)
-{
 	int error = 0;
-
-	if (nd)
-		error = aa_perm(active, nd->dentry, nd->mnt, mask);
-
-	return error;
-}
-
-/**
- * aa_perm_dentry - file permissions interface when no vfsmnt available
- * @active: profile to check against
- * @dentry: requested dentry
- * @mask: access mode requested
- *
- * Determine if access (mask) for dentry is authorized by active profile.
- * Result, %0 (success), -ve (error)
- */
-int aa_perm_dentry(struct aaprofile *active, struct dentry *dentry, int mask)
-{
-	int error = 0, permerror;
 	struct aa_audit sa;
 
-	if (!active)
-		goto out;
-
 	if ((mask = aa_filter_mask(mask, dentry->d_inode)) == 0)
 		goto out;
 
@@ -947,13 +799,7 @@ int aa_perm_dentry(struct aaprofile *act
 	sa.ival = mask;
 	sa.flags = 0;
 	sa.gfp_mask = GFP_KERNEL;
-
-	permerror = _aa_perm_dentry(active, dentry, mask, &sa.name);
-	aa_permerror2result(permerror, &sa);
-
-	error = aa_audit(active, &sa);
-
-	aa_put_name(sa.name);
+	error = _aa_perm_vfsmount(active, dentry, mnt, &sa, mask);
 
 out:
 	return error;
@@ -964,22 +810,20 @@ out:
  * @active: profile to check against
  * @dentry: requested dentry
  * @diroptype: aa_dir_mkdir or aa_dir_rmdir
+ * @mnt: vfsmount
  *
  * Determine if directory operation (make/remove) for dentry is authorized
  * by @active profile.
  * Result, %0 (success), -ve (error)
  */
 int aa_perm_dir(struct aaprofile *active, struct dentry *dentry,
-		enum aa_diroptype diroptype)
+		struct vfsmount *mnt, enum aa_diroptype diroptype)
 {
-	int error = 0, permerror, mask;
+	int error = 0, mask;
 	struct aa_audit sa;
 
 	WARN_ON(diroptype != aa_dir_mkdir && diroptype != aa_dir_rmdir);
 
-	if (!active)
-		goto out;
-
 	mask = MAY_WRITE;
 
 	sa.type = AA_AUDITTYPE_DIR;
@@ -987,14 +831,8 @@ int aa_perm_dir(struct aaprofile *active
 	sa.flags = 0;
 	sa.gfp_mask = GFP_KERNEL;
 
-	permerror = _aa_perm_dentry(active, dentry, mask, &sa.name);
-	aa_permerror2result(permerror, &sa);
-
-	error = aa_audit(active, &sa);
+	error = _aa_perm_vfsmount(active, dentry, mnt, &sa, MAY_WRITE);
 
-	aa_put_name(sa.name);
-
-out:
 	return error;
 }
 
@@ -1009,7 +847,6 @@ out:
 int aa_capability(struct aaprofile *active, int cap)
 {
 	int error = 0;
-
 	struct aa_audit sa;
 
 	sa.type = AA_AUDITTYPE_CAP;
@@ -1030,124 +867,42 @@ int aa_capability(struct aaprofile *acti
  * @active: profile to check against
  * @link: dentry for link being created
  * @target: dentry for link target
- *
- * Checks link permissions for all possible name combinations.  This is
- * particularly ugly.  Returns %0 on sucess, error otherwise.
+ * @mnt: vfsmount (-EXDEV is link and target are not on same vfsmount)
  */
-int aa_link(struct aaprofile *active, struct dentry *link,
-	    struct dentry *target)
+int aa_link(struct aaprofile *active,
+	    struct dentry *link, struct vfsmount *link_mnt,
+	    struct dentry *target, struct vfsmount *target_mnt)
 {
-	char *iname = NULL, *oname = NULL,
-	     *failed_iname = NULL, *failed_oname = NULL;
-	unsigned int result = 0;
-	int error, path_error, error_code = 0, match = 0,
-	    complain = PROFILE_COMPLAIN(active);
-	struct aa_path_data idata, odata;
+	int permerror = -EPERM, error;
 	struct aa_audit sa;
 
-	if (!active)
-		return 0;
-
-	/* Perform nested lookup for names.
-	 * This is necessary in the case where /dev/block is mounted
-	 * multiple times,  i.e /dev/block->/a and /dev/block->/b
-	 * This allows us to detect links where src/dest are on different
-	 * mounts.   N.B no support yet for links across bind mounts of
-	 * the form mount -bind /mnt/subpath /mnt2
-	 *
-	 * Getting direct access to vfsmounts (via nameidata) for link and
-	 * target would allow all this uglyness to go away.
-	 *
- 	 * If more than one mountpoint matches but none satisfy the profile,
-	 * only the first pathname (mountpoint) is logged.
-	 */
-
-	__aa_path_begin(target, link, &odata);
-	do {
-		oname = aa_path_getname(&odata);
-		if (oname) {
-			aa_path_begin(target, &idata);
-			do {
-				iname = aa_path_getname(&idata);
-				if (iname) {
-					result = aa_link_perm(active, oname,
-							      iname);
-
-					/* access via any path is enough */
-					if (result || complain) {
-						match = 1;
-						break;
-					}
-
-					/* Already have an path that failed? */
-					if (failed_iname) {
-						aa_put_name(iname);
-					} else {
-						failed_iname = iname;
-						failed_oname = oname;
-					}
-				}
-			} while (iname && !match);
-
-			/* should not be possible if we matched */
-			if ((path_error = aa_path_end(&idata)) != 0) {
-				dentry_xlate_error(target, path_error,
-						   "inner dentry [link]");
-
-				/* name should not be set if error */
-				WARN_ON(iname);
-
-				error_code = path_error;
-			}
-
-			/* don't release if we're saving it */
-			if (!match && failed_oname != oname)
-				aa_put_name(oname);
-		}
-	} while (oname && !match);
+	sa.name = aa_get_name(link, link_mnt);
+	sa.pval = aa_get_name(target, target_mnt);
 
-	if (error_code != 0) {
-		/* inner error */
-		(void)aa_path_end(&odata);
-	} else if ((path_error = aa_path_end(&odata)) != 0) {
-		dentry_xlate_error(link, path_error, "outer dentry [link]");
-		error_code = path_error;
+	if (IS_ERR(sa.name)) {
+		permerror = PTR_ERR(sa.name);
+		sa.name = NULL;
 	}
-
-	if (error_code != 0) {
-		/* inner or outer error */
-		result = 0;
-	} else if (match) {
-		result = 1;
-	} else {
-		/* failed to match */
-		WARN_ON(iname);
-		WARN_ON(oname);
-
-		result = 0;
-		iname = failed_iname;
-		oname = failed_oname;
+	if (IS_ERR(sa.pval)) {
+		permerror = PTR_ERR(sa.pval);
+		sa.pval = NULL;
 	}
 
+	if (sa.name && sa.pval)
+		permerror = aa_link_perm(active, sa.name, sa.pval);
+
+	aa_permerror2result(permerror, &sa);
+
 	sa.type = AA_AUDITTYPE_LINK;
-	sa.name = oname;	/* link */
-	sa.pval = iname;	/* target */
 	sa.flags = 0;
-	sa.error_code = error_code;
-	sa.result = result;
 	sa.gfp_mask = GFP_KERNEL;
 
 	error = aa_audit(active, &sa);
 
-	if (failed_oname != oname)
-		aa_put_name(failed_oname);
-	if (failed_iname != iname)
-		aa_put_name(failed_iname);
-
-	aa_put_name(oname);
-	aa_put_name(iname);
+	aa_put_name(sa.name);
+	aa_put_name(sa.pval);
 
-	return error;
+	return error;
 }
 
 /*******************************
