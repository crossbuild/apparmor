With the lkml patches currently in svn, there is a dentry refcounting
bug somewhere. Unloading the apparmor module ends up leaving around the
/sys/kernel/security/apparmor/ directory and files in place. Followup
attempts to reload the module fail because because the securityfs files
exist which causes the apparmorfs registration attempt to fail[1].
Attempts to read from the leftover files (e.g. by the rcapparmor script
looking to see if profiles are already loaded) would of course cause an
oops because the backing operations no longer exist.

Closer examination showed that the reference count on each dentry/file
in the apparmor/ directory was at 2 *after* securityfs_remove() had been
called. The apparmor/ directory itself could not be removed because all
of its member entries still existed. Diagnostic printk()s also showed that
the reference count on the dentries is also 2 immediately after
creation.

I'm not quite sure where the extra references come from, or why things
worked before (and they definitely do work in a 2.6.18 era kernel). The
following patch adjusts the reference counts in such a way that they go
to zero on unloading, but I'm not sure they're the *right* fixes, it may
just be papering over a refcounting bug elsewhere.

Any comments? (This patch is checked in to subversion.)

[1] There's also a *really* annoying bug with modprobe exposed here;
    when module_init(1) fails with -EEXIST returned, modprobe silently
    ignores it and returns success. We end up propogating the -EEXIST
    error from the apparmorfs creation, so it looks initially like module
    reloading succeeded when it didn't.

---
 security/apparmor/apparmorfs.c |    4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

--- a/security/apparmor/apparmorfs.c
+++ b/security/apparmor/apparmorfs.c
@@ -179,8 +179,10 @@ static void aafs_remove(const char *name
 	struct dentry *dentry;
 
 	dentry = lookup_one_len(name, apparmor_dentry, strlen(name));
-	if (dentry && !IS_ERR(dentry))
+	if (!IS_ERR(dentry)) {
 		securityfs_remove(dentry);
+		dput(dentry);
+	}
 }
 
 static int aafs_create(const char *name, int mask, struct file_operations *fops)
