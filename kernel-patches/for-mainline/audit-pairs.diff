---
 security/apparmor/apparmor.h         |   44 +--
 security/apparmor/apparmorfs.c       |   20 -
 security/apparmor/lsm.c              |  116 +++++----
 security/apparmor/main.c             |  435 ++++++++++++++++-------------------
 security/apparmor/module_interface.c |   48 ++-
 security/apparmor/procattr.c         |   37 +-
 6 files changed, 358 insertions(+), 342 deletions(-)

--- a/security/apparmor/apparmor.h
+++ b/security/apparmor/apparmor.h
@@ -150,21 +150,18 @@ extern struct aa_profile *null_complain_
  */
 
 struct aa_audit {
-	unsigned short type;
+	const char *operation;
 	gfp_t gfp_mask;
+	const char *info;
 	const char *name;
 	char *buffer;
+	const char *name2;
+	char *buffer2;
 	int requested_mask, denied_mask;
+	struct iattr *iattr;
+	pid_t task, parent;
+	u64 magic_token;
 	int error_code;
-	union {
-		int capability;
-		struct {
-			const char *name2;
-			char *buffer2;
-		};
-		struct iattr *iattr;
-		va_list vaval;
-	};
 };
 
 /* audit types */
@@ -192,24 +189,29 @@ enum aa_lock_class {
 extern int alloc_null_complain_profile(void);
 extern void free_null_complain_profile(void);
 extern int attach_nullprofile(struct aa_profile *profile);
-extern void aa_audit_message(struct aa_profile *profile, gfp_t gfp,
-			    const char *, ...)
-	__attribute__ ((format (printf, 3, 4)));
+extern int aa_audit_message(struct aa_profile *profile, struct aa_audit *sa,
+			    int type);
+void aa_audit_hint(struct aa_profile *profile, struct aa_audit *sa);
+void aa_audit_status(struct aa_profile *profile, struct aa_audit *sa);
+int aa_audit_reject(struct aa_profile *profile, struct aa_audit *sa);
 extern int aa_audit_syscallreject(struct aa_profile *profile, gfp_t gfp,
 				  const char *);
 extern int aa_audit(struct aa_profile *profile, struct aa_audit *);
 
 extern int aa_attr(struct aa_profile *profile, struct dentry *dentry,
 		   struct vfsmount *mnt, struct iattr *iattr);
-extern int aa_perm_xattr(struct aa_profile *profile, struct dentry *dentry,
-			 struct vfsmount *mnt, const char *operation, int mask,
-			 int check);
+extern int aa_perm_xattr(struct aa_profile *profile, const char *operation,
+			 struct dentry *dentry, struct vfsmount *mnt,
+			 int mask, int check);
 extern int aa_capability(struct aa_task_context *cxt, int cap);
-extern int aa_perm(struct aa_profile *profile, struct dentry *dentry,
-		   struct vfsmount *mnt, int mask, int check);
-extern int aa_perm_dir(struct aa_profile *profile, struct dentry *dentry,
-		       struct vfsmount *mnt, const char *operation, int mask);
-extern int aa_perm_path(struct aa_profile *, const char *, int);
+extern int aa_perm(struct aa_profile *profile, const char *operation,
+		   struct dentry *dentry, struct vfsmount *mnt, int mask,
+		   int check);
+extern int aa_perm_dir(struct aa_profile *profile, const char *operation,
+		       struct dentry *dentry, struct vfsmount *mnt,
+		       int mask);
+extern int aa_perm_path(struct aa_profile *, const char *operation,
+			const char *name, int);
 extern int aa_link(struct aa_profile *profile,
 		   struct dentry *link, struct vfsmount *link_mnt,
 		   struct dentry *target, struct vfsmount *target_mnt);
--- a/security/apparmor/apparmorfs.c
+++ b/security/apparmor/apparmorfs.c
@@ -38,13 +38,13 @@ static char *aa_simple_write_to_buffer(c
 	 */
 	profile = aa_get_profile(current);
 	if (profile) {
-		aa_audit_message(NULL, GFP_KERNEL, "REJECTING access to "
-				 "profile %s (%d profile %s active %s)",
-				 msg, current->pid, profile->parent->name,
-				 profile->name);
+		struct aa_audit sa;
+		memset(&sa, 0, sizeof(sa));
+		sa.operation = msg;
+		sa.gfp_mask = GFP_KERNEL;
+		sa.error_code = -EACCES;
+		data = ERR_PTR(aa_audit_reject(profile, &sa));
 		aa_put_profile(profile);
-
-		data = ERR_PTR(-EPERM);
 		goto out;
 	}
 
@@ -106,7 +106,7 @@ static ssize_t aa_profile_load(struct fi
 	char *data;
 	ssize_t error;
 
-	data = aa_simple_write_to_buffer(buf, size, size, pos, "load");
+	data = aa_simple_write_to_buffer(buf, size, size, pos, "profile_load");
 
 	error = PTR_ERR(data);
 	if (!IS_ERR(data)) {
@@ -129,7 +129,8 @@ static ssize_t aa_profile_replace(struct
 	char *data;
 	ssize_t error;
 
-	data = aa_simple_write_to_buffer(buf, size, size, pos, "replacement");
+	data = aa_simple_write_to_buffer(buf, size, size, pos,
+					 "profile_replace");
 
 	error = PTR_ERR(data);
 	if (!IS_ERR(data)) {
@@ -156,7 +157,8 @@ static ssize_t aa_profile_remove(struct 
 	 * aa_remove_profile needs a null terminated string so 1 extra
 	 * byte is allocated and the copied data is null terminated.
 	 */
-	data = aa_simple_write_to_buffer(buf, size + 1, size, pos, "removal");
+	data = aa_simple_write_to_buffer(buf, size + 1, size, pos,
+					 "profile_remove");
 
 	error = PTR_ERR(data);
 	if (!IS_ERR(data)) {
--- a/security/apparmor/lsm.c
+++ b/security/apparmor/lsm.c
@@ -17,6 +17,7 @@
 #include <linux/namei.h>
 #include <linux/ctype.h>
 #include <linux/sysctl.h>
+#include <linux/audit.h>
 
 #include "apparmor.h"
 #include "inline.h"
@@ -123,10 +124,14 @@ static int apparmor_ptrace(struct task_s
 	cxt = aa_task_context(parent);
 	if (cxt) {
 		if (parent->nsproxy != child->nsproxy) {
-			aa_audit_message(cxt->profile, GFP_ATOMIC,
-					 "REJECTING ptrace across "
-					 "namespace of %d by %d",
-					 parent->pid, child->pid);
+			struct aa_audit sa;
+			memset(&sa, 0, sizeof(sa));
+			sa.operation = "ptrace";
+			sa.gfp_mask = GFP_ATOMIC;
+			sa.parent = parent->pid;
+			sa.task = child->pid;
+			sa.info = "different namespaces";
+			aa_audit_reject(cxt->profile, &sa);
 			error = -EPERM;
 		} else {
 			struct aa_task_context *child_cxt =
@@ -135,12 +140,13 @@ static int apparmor_ptrace(struct task_s
 			error = aa_may_ptrace(cxt, child_cxt ?
 						   child_cxt->profile : NULL);
 			if (PROFILE_COMPLAIN(cxt->profile)) {
-				aa_audit_message(cxt->profile, GFP_ATOMIC,
-					"LOGPROF-HINT ptrace pid=%d child=%d "
-					"(%d profile %s active %s)",
-					current->pid, child->pid, current->pid,
-					cxt->profile->parent->name,
-					cxt->profile->name);
+				struct aa_audit sa;
+				memset(&sa, 0, sizeof(sa));
+				sa.operation = "ptrace";
+				sa.gfp_mask = GFP_ATOMIC;
+				sa.parent = parent->pid;
+				sa.task = child->pid;
+				aa_audit_hint(cxt->profile, &sa);
 			}
 		}
 	}
@@ -192,7 +198,7 @@ static int apparmor_sysctl(struct ctl_ta
 		if (name && name - buffer >= 5) {
 			name -= 5;
 			memcpy(name, "/proc", 5);
-			error = aa_perm_path(profile, name, mask);
+			error = aa_perm_path(profile, "sysctl", name, mask);
 		}
 		free_page((unsigned long)buffer);
 	}
@@ -247,7 +253,8 @@ static int apparmor_inode_mkdir(struct i
 	profile = aa_get_profile(current);
 
 	if (profile)
-		error = aa_perm_dir(profile, dentry, mnt, "mkdir", MAY_WRITE);
+		error = aa_perm_dir(profile, "inode_mkdir", dentry, mnt,
+				    MAY_WRITE);
 
 	aa_put_profile(profile);
 
@@ -267,7 +274,8 @@ static int apparmor_inode_rmdir(struct i
 	profile = aa_get_profile(current);
 
 	if (profile)
-		error = aa_perm_dir(profile, dentry, mnt, "rmdir", MAY_WRITE);
+		error = aa_perm_dir(profile, "inode_rmdir", dentry, mnt,
+				    MAY_WRITE);
 
 	aa_put_profile(profile);
 
@@ -275,8 +283,9 @@ out:
 	return error;
 }
 
-static int aa_permission(struct inode *inode, struct dentry *dentry,
-			 struct vfsmount *mnt, int mask, int check)
+static int aa_permission(struct inode *inode, const char *operation,
+			 struct dentry *dentry, struct vfsmount *mnt,
+			 int mask, int check)
 {
 	int error = 0;
 
@@ -285,7 +294,8 @@ static int aa_permission(struct inode *i
 
 		profile = aa_get_profile(current);
 		if (profile)
-			error = aa_perm(profile, dentry, mnt, mask, check);
+			error = aa_perm(profile, operation, dentry, mnt, mask,
+					check);
 		aa_put_profile(profile);
 	}
 	return error;
@@ -294,7 +304,7 @@ static int aa_permission(struct inode *i
 static int apparmor_inode_create(struct inode *dir, struct dentry *dentry,
 				 struct vfsmount *mnt, int mask)
 {
-	return aa_permission(dir, dentry, mnt, MAY_WRITE, 0);
+	return aa_permission(dir, "inode_create", dentry, mnt, MAY_WRITE, 0);
 }
 
 static int apparmor_inode_link(struct dentry *old_dentry,
@@ -327,19 +337,20 @@ static int apparmor_inode_unlink(struct 
 
 	if (S_ISDIR(dentry->d_inode->i_mode))
 		check |= AA_CHECK_DIR;
-	return aa_permission(dir, dentry, mnt, MAY_WRITE, check);
+	return aa_permission(dir, "inode_unlink", dentry, mnt, MAY_WRITE,
+			     check);
 }
 
 static int apparmor_inode_symlink(struct inode *dir, struct dentry *dentry,
 				  struct vfsmount *mnt, const char *old_name)
 {
-	return aa_permission(dir, dentry, mnt, MAY_WRITE, 0);
+	return aa_permission(dir, "inode_symlink", dentry, mnt, MAY_WRITE, 0);
 }
 
 static int apparmor_inode_mknod(struct inode *dir, struct dentry *dentry,
 				struct vfsmount *mnt, int mode, dev_t dev)
 {
-	return aa_permission(dir, dentry, mnt, MAY_WRITE, 0);
+	return aa_permission(dir, "inode_mknod", dentry, mnt, MAY_WRITE, 0);
 }
 
 static int apparmor_inode_rename(struct inode *old_dir,
@@ -364,12 +375,12 @@ static int apparmor_inode_rename(struct 
 		if (inode && S_ISDIR(inode->i_mode))
 			check |= AA_CHECK_DIR;
 		if (old_mnt)
-			error = aa_perm(profile, old_dentry, old_mnt,
-					MAY_READ | MAY_WRITE, check);
+			error = aa_perm(profile, "inode_rename", old_dentry,
+					old_mnt, MAY_READ | MAY_WRITE, check);
 
 		if (!error && new_mnt) {
-			error = aa_perm(profile, new_dentry, new_mnt,
-					MAY_WRITE, check);
+			error = aa_perm(profile, "inode_rename", new_dentry,
+					new_mnt, MAY_WRITE, check);
 		}
 	}
 
@@ -392,7 +403,8 @@ static int apparmor_inode_permission(str
 		/* allow traverse accesses to directories */
 		mask &= ~MAY_EXEC;
 	}
-	return aa_permission(inode, nd->dentry, nd->mnt, mask, check);
+	return aa_permission(inode, "inode_permission", nd->dentry, nd->mnt,
+			     mask, check);
 }
 
 static int apparmor_inode_setattr(struct dentry *dentry, struct vfsmount *mnt,
@@ -432,7 +444,7 @@ static int aa_xattr_permission(struct de
 		int check = file ? AA_CHECK_FD : 0;
 
 		if (profile)
-			error = aa_perm_xattr(profile, dentry, mnt, operation,
+			error = aa_perm_xattr(profile, operation, dentry, mnt,
 					      mask, check);
 		aa_put_profile(profile);
 	}
@@ -494,7 +506,8 @@ static int apparmor_file_permission(stru
 		if (S_ISDIR(inode->i_mode))
 			check |= AA_CHECK_DIR;
 		mask &= (MAY_READ | MAY_WRITE | MAY_EXEC);
-		error = aa_permission(inode, dentry, mnt, mask, check);
+		error = aa_permission(inode, "file_permission", dentry, mnt,
+				      mask, check);
 	}
 	aa_put_profile(profile);
 
@@ -520,8 +533,8 @@ static void apparmor_file_free_security(
 	aa_put_profile(file_profile);
 }
 
-static inline int aa_mmap(struct file *file, unsigned long prot,
-			  unsigned long flags)
+static inline int aa_mmap(struct file *file, const char *operation,
+			  unsigned long prot, unsigned long flags)
 {
 	struct dentry *dentry;
 	int mask = 0;
@@ -539,20 +552,20 @@ static inline int aa_mmap(struct file *f
 		mask |= AA_EXEC_MMAP;
 
 	dentry = file->f_dentry;
-	return aa_permission(dentry->d_inode, dentry, file->f_vfsmnt, mask,
-			     AA_CHECK_FD);
+	return aa_permission(dentry->d_inode, operation, dentry,
+			     file->f_vfsmnt, mask, AA_CHECK_FD);
 }
 
 static int apparmor_file_mmap(struct file *file, unsigned long reqprot,
 			       unsigned long prot, unsigned long flags)
 {
-	return aa_mmap(file, prot, flags);
+	return aa_mmap(file, "file_mmap", prot, flags);
 }
 
 static int apparmor_file_mprotect(struct vm_area_struct *vma,
 				  unsigned long reqprot, unsigned long prot)
 {
-	return aa_mmap(vma->vm_file, prot,
+	return aa_mmap(vma->vm_file, "file_mprotect", prot,
 		       !(vma->vm_flags & VM_SHARED) ? MAP_PRIVATE : 0);
 }
 
@@ -628,24 +641,27 @@ static int apparmor_setprocattr(struct t
 
 		profile = aa_get_profile(current);
 		if (profile) {
+			struct aa_audit sa;
+			memset(&sa, 0, sizeof(sa));
+			sa.operation = "profile_set";
+			sa.gfp_mask = GFP_KERNEL;
+			sa.task = task->pid;
+			sa.info = "from confined process";
+			aa_audit_reject(profile, &sa);
 			aa_put_profile(profile);
-			aa_audit_message(NULL, GFP_KERNEL, "Attempt by "
-					 "confined task %d [user %d] to "
-					 "assign profile to task %d",
-					 current->pid, current->uid,
-					 task->pid);
 			return -EACCES;
 		}
 		error = aa_setprocattr_setprofile(task, args);
 	} else {
-		AA_ERROR("Unknown setprocattr command '%.*s' "
-			"by task %d [user %d] for task %d",
-			size < 16 ? (int)size : 16,
-			command,
-			current->pid,
-			current->uid,
-			task->pid);
-		error = -EINVAL;
+		struct aa_audit sa;
+		memset(&sa, 0, sizeof(sa));
+		sa.operation = "setprocattr";
+		sa.gfp_mask = GFP_KERNEL;
+		sa.info = "invalid command";
+		sa.name = command;
+		sa.task = task->pid;
+		aa_audit_reject(NULL, &sa);
+		return -EINVAL;
 	}
 
 	if (!error)
@@ -703,8 +719,12 @@ struct security_operations apparmor_ops 
 
 static void info_message(const char *str)
 {
+	struct aa_audit sa;
+	memset(&sa, 0, sizeof(sa));
+	sa.gfp_mask = GFP_KERNEL;
+	sa.info = str;
 	printk(KERN_INFO "AppArmor: %s", str);
-	aa_audit_message(NULL, GFP_KERNEL, "%s", str);
+	aa_audit_message(NULL, &sa, AUDIT_APPARMOR_STATUS);
 }
 
 static int __init apparmor_init(void)
@@ -722,7 +742,7 @@ static int __init apparmor_init(void)
 	}
 
 	if ((error = register_security(&apparmor_ops))) {
-		AA_ERROR("Unable to load AppArmor\n");
+		AA_ERROR("Unable to register AppArmor\n");
 		goto register_security_out;
 	}
 
--- a/security/apparmor/main.c
+++ b/security/apparmor/main.c
@@ -275,49 +275,134 @@ void free_null_complain_profile(void)
 }
 
 /**
- * aa_audit_message - Log a message to the audit subsystem
+ * aa_audit - Log an audit event to the audit subsystem
  * @profile: profile to check against
- * @gfp: allocation flags
- * @flags: audit flags
- * @fmt: varargs fmt
+ * @sa: audit event
+ * @audit_cxt: audit context to log message to
+ * @type: audit event number
  */
-void aa_audit_message(struct aa_profile *profile, gfp_t gfp, const char *fmt,
-		     ...)
+static int aa_audit_base(struct aa_profile *profile, struct aa_audit *sa,
+			 struct audit_context *audit_cxt, int type)
 {
-	struct aa_audit sa;
+	struct audit_buffer *ab = NULL;
 
-	sa.type = AA_AUDITTYPE_MSG;
-	sa.name = fmt;
-	va_start(sa.vaval, fmt);
-	sa.gfp_mask = gfp;
-	sa.requested_mask = 0;
-	sa.denied_mask = 0;
-	sa.error_code = -EAGAIN;  /* never reaches user space */
+	ab = audit_log_start(audit_cxt, sa->gfp_mask, type);
+
+	if (!ab) {
+		AA_ERROR("Unable to log event (%d) to audit subsys\n",
+			 type);
+		/* FIXME: do we want to keep old behavior - as below
+		 * don't fail operations in complain mode even if logging
+		 * fails */
+		return type == AUDIT_APPARMOR_COMPLAIN ? 0 : -ENOMEM;
+	}
+
+	if (sa->operation)
+		audit_log_format(ab, "operation=\"%s\"", sa->operation);
+
+	if (sa->info)
+		audit_log_format(ab, " info=\"%s\"", sa->info);
+
+	if (sa->requested_mask | sa->denied_mask) {
+		int mask = sa->denied_mask ? sa->denied_mask :
+			sa->requested_mask;
+
+		audit_log_format(ab, " mask=\"%s%s%s%s%s\"",
+				 mask & AA_EXEC_MMAP ? "m" : "",
+				 mask & MAY_READ  ? "r" : "",
+				 mask & MAY_WRITE ? "w" : "",
+				 mask & MAY_EXEC  ? "x" : "",
+				 mask & AA_MAY_LINK  ? "l" : "");
+	}
+
+	if (sa->iattr) {
+		struct iattr *iattr = sa->iattr;
+
+		audit_log_format(ab, " attribute=\"%s%s%s%s%s%s%s\"",
+			iattr->ia_valid & ATTR_MODE ? "mode," : "",
+			iattr->ia_valid & ATTR_UID ? "uid," : "",
+			iattr->ia_valid & ATTR_GID ? "gid," : "",
+			iattr->ia_valid & ATTR_SIZE ? "size," : "",
+			((iattr->ia_valid & ATTR_ATIME_SET) ||
+			 (iattr->ia_valid & ATTR_ATIME)) ? "atime," : "",
+			((iattr->ia_valid & ATTR_MTIME_SET) ||
+			 (iattr->ia_valid & ATTR_MTIME)) ? "mtime," : "",
+			iattr->ia_valid & ATTR_CTIME ? "ctime," : "");
+	}
+
+	if (sa->task)
+		audit_log_format(ab, " task=\"%d\"", sa->task);
+
+	if (sa->parent)
+		audit_log_format(ab, "parent=\"%d\"", sa->parent);
+
+	if (sa->name) {
+		audit_log_format(ab, " name=");
+		audit_log_untrustedstring(ab, sa->name);
+	}
+
+	if (sa->name2) {
+		audit_log_format(ab, " name2=");
+		audit_log_untrustedstring(ab, sa->name2);
+	}
+
+	if (sa->magic_token)
+		audit_log_format(ab, " magic_token=\"%llu\"", sa->magic_token);
+
+	audit_log_format(ab, "pid=\"%d\"", current->pid);
 
-	(void)aa_audit(profile, &sa);
+	if (profile) {
+		audit_log_format(ab, " profile=");
+		audit_log_untrustedstring(ab, profile->parent->name);
+	}
+
+	audit_log_end(ab);
 
-	va_end(sa.vaval);
+	return type == AUDIT_APPARMOR_COMPLAIN ? 0 : sa->error_code;
 }
 
 /**
  * aa_audit_syscallreject - Log a syscall rejection to the audit subsystem
  * @profile: profile to check against
- * @msg: string describing syscall being rejected
  * @gfp: memory allocation flags
+ * @msg: string describing syscall being rejected
  */
 int aa_audit_syscallreject(struct aa_profile *profile, gfp_t gfp,
 			   const char *msg)
 {
 	struct aa_audit sa;
-
-	sa.type = AA_AUDITTYPE_SYSCALL;
+	memset(&sa, 0, sizeof(sa));
+	sa.operation = "syscall";
 	sa.name = msg;
 	sa.gfp_mask = gfp;
-	sa.requested_mask = 0;
-	sa.denied_mask = 0;
 	sa.error_code = -EPERM;
 
-	return aa_audit(profile, &sa);
+	return aa_audit_base(profile, &sa, current->audit_context,
+			     AUDIT_APPARMOR_REJECT);
+}
+
+int aa_audit_message(struct aa_profile *profile, struct aa_audit *sa,
+		      int type)
+{
+	struct audit_context *audit_cxt;
+
+	audit_cxt = apparmor_logsyscall ? current->audit_context : NULL;
+	return aa_audit_base(profile, sa, audit_cxt, type);
+}
+
+void aa_audit_hint(struct aa_profile *profile, struct aa_audit *sa)
+{
+	aa_audit_message(profile, sa, AUDIT_APPARMOR_HINT);
+}
+
+void aa_audit_status(struct aa_profile *profile, struct aa_audit *sa)
+{
+	aa_audit_message(profile, sa, AUDIT_APPARMOR_STATUS);
+}
+
+int aa_audit_reject(struct aa_profile *profile, struct aa_audit *sa)
+{
+	return aa_audit_message(profile, sa, AUDIT_APPARMOR_REJECT);
 }
 
 /**
@@ -327,121 +412,21 @@ int aa_audit_syscallreject(struct aa_pro
  */
 int aa_audit(struct aa_profile *profile, struct aa_audit *sa)
 {
-	struct audit_buffer *ab = NULL;
+	int type = AUDIT_APPARMOR_REJECT;
 	struct audit_context *audit_cxt;
 
-	const char *logcls;
-	int complain = 0;
-
-	const gfp_t gfp_mask = sa->gfp_mask;
-
 	if (likely(!sa->error_code)) {
-		if (likely(!PROFILE_AUDIT(profile))) {
+		if (likely(!PROFILE_AUDIT(profile)))
 			/* nothing to log */
 			return 0;
-		} else
-			logcls = "AUDITING";
-	} else if (sa->type == AA_AUDITTYPE_SYSCALL) {
-		/* Currently AA_AUDITTYPE_SYSCALL is for rejects only.
-		 * Values set by aa_audit_syscallreject will get us here.
-		 */
-		logcls = "REJECTING";
-	} else {
-		complain = PROFILE_COMPLAIN(profile);
-		logcls = complain ? "PERMITTING" : "REJECTING";
+		else
+			type = AUDIT_APPARMOR_AUDIT;
+	} else if (PROFILE_COMPLAIN(profile)) {
+		type = AUDIT_APPARMOR_COMPLAIN;
 	}
 
-	/* Force full audit syscall logging regardless of global setting if
-	 * we are rejecting a syscall
-	 */
-	if (sa->type == AA_AUDITTYPE_SYSCALL) {
-		audit_cxt = current->audit_context;
-	} else {
-		audit_cxt = apparmor_logsyscall ?
-			current->audit_context : NULL;
-	}
-
-	ab = audit_log_start(audit_cxt, gfp_mask, AUDIT_APPARMOR);
-
-	if (!ab) {
-		AA_ERROR("Unable to log event (%d) to audit subsys\n",
-			sa->type);
-		return -ENOMEM;  /* FIXME: was -EINVAL if !complain: ??? */
-	}
-
-	/* messages get special handling */
-	if (sa->type == AA_AUDITTYPE_MSG) {
-		audit_log_vformat(ab, sa->name, sa->vaval);
-		audit_log_end(ab);
-		goto out;
-	}
-
-	/* log operation */
-
-	audit_log_format(ab, "%s ", logcls);	/* REJECTING/ALLOWING/etc */
-
-	switch(sa->type) {
-	case AA_AUDITTYPE_FILE: {
-		int mask = PROFILE_AUDIT(profile) ?
-				sa->requested_mask : sa->denied_mask;
-
-		audit_log_format(ab, "%s%s%s%s%s access to %s ",
-				 mask & AA_EXEC_MMAP ? "m" : "",
-				 mask & MAY_READ  ? "r" : "",
-				 mask & MAY_WRITE ? "w" : "",
-				 mask & MAY_EXEC  ? "x" : "",
-				 mask & AA_MAY_LINK  ? "l" : "",
-				 sa->name);
-		break;
-	}
-	case AA_AUDITTYPE_DIR:
-		audit_log_format(ab, "%s on %s ", sa->name2, sa->name);
-		break;
-	case AA_AUDITTYPE_ATTR: {
-		struct iattr *iattr = sa->iattr;
-
-		audit_log_format(ab,
-			"attribute (%s%s%s%s%s%s%s) change to %s ",
-			iattr->ia_valid & ATTR_MODE ? "mode," : "",
-			iattr->ia_valid & ATTR_UID ? "uid," : "",
-			iattr->ia_valid & ATTR_GID ? "gid," : "",
-			iattr->ia_valid & ATTR_SIZE ? "size," : "",
-			((iattr->ia_valid & ATTR_ATIME_SET) ||
-			 (iattr->ia_valid & ATTR_ATIME)) ? "atime," : "",
-			((iattr->ia_valid & ATTR_MTIME_SET) ||
-			 (iattr->ia_valid & ATTR_MTIME)) ? "mtime," : "",
-			iattr->ia_valid & ATTR_CTIME ? "ctime," : "",
-			sa->name);
-		break;
-	}
-	case AA_AUDITTYPE_XATTR:
-		audit_log_format(ab, "%s on %s ", sa->name2, sa->name);
-		break;
-	case AA_AUDITTYPE_LINK:
-		audit_log_format(ab, "link access from %s to %s ", sa->name,
-				 sa->name2);
-		break;
-	case AA_AUDITTYPE_CAP:
-		audit_log_format(ab, "access to capability '%s' ",
-			capability_names[sa->capability]);
-		break;
-	case AA_AUDITTYPE_SYSCALL:
-		audit_log_format(ab, "access to syscall '%s' ", sa->name);
-		break;
-	default:
-		WARN_ON(1);
-		return -EINVAL;
-	}
-
-#undef NOFLAGS
-
-	audit_log_format(ab, "(%d profile %s active %s)",
-			 current->pid, profile->parent->name, profile->name);
-
-	audit_log_end(ab);
-
-out:
-	return complain ? 0 : sa->error_code;
+	audit_cxt = apparmor_logsyscall ? current->audit_context : NULL;
+	return aa_audit_base(profile, sa, audit_cxt, type);
 }
 
 /**
@@ -458,9 +443,10 @@ int aa_attr(struct aa_profile *profile, 
 	int error, check;
 	struct aa_audit sa;
 
-	sa.type = AA_AUDITTYPE_ATTR;
-	sa.iattr = iattr;
+	memset(&sa, 0, sizeof(sa));
+	sa.operation = "setattr";
 	sa.gfp_mask = GFP_KERNEL;
+	sa.iattr = iattr;
 	sa.requested_mask = MAY_WRITE;
 	sa.error_code = -EACCES;
 
@@ -484,16 +470,16 @@ int aa_attr(struct aa_profile *profile, 
  * @mask: access mode requested
  * @check: kind of check to perform
  */
-int aa_perm_xattr(struct aa_profile *profile, struct dentry *dentry,
-		  struct vfsmount *mnt, const char *operation,
-		  int mask, int check)
+int aa_perm_xattr(struct aa_profile *profile, const char *operation,
+		  struct dentry *dentry, struct vfsmount *mnt, int mask,
+		  int check)
 {
 	struct inode *inode = dentry->d_inode;
 	int error;
 	struct aa_audit sa;
 
-	sa.type = AA_AUDITTYPE_XATTR;
-	sa.name2 = operation;
+	memset(&sa, 0, sizeof(sa));
+	sa.operation = operation;
 	sa.gfp_mask = GFP_KERNEL;
 	sa.requested_mask = mask;
 	sa.error_code = -EACCES;
@@ -517,8 +503,8 @@ int aa_perm_xattr(struct aa_profile *pro
  * Determine if access @mask for the file is authorized by @profile.
  * Returns 0 on success, or else an error code.
  */
-int aa_perm(struct aa_profile *profile, struct dentry *dentry,
-	    struct vfsmount *mnt, int mask, int check)
+int aa_perm(struct aa_profile *profile, const char *operation,
+	    struct dentry *dentry, struct vfsmount *mnt, int mask, int check)
 {
 	struct aa_audit sa;
 	int error = 0;
@@ -526,10 +512,12 @@ int aa_perm(struct aa_profile *profile, 
 	if (mask == 0)
 		goto out;
 
-	sa.type = AA_AUDITTYPE_FILE;
+	memset(&sa, 0, sizeof(sa));
+	sa.operation = operation;
 	sa.gfp_mask = GFP_KERNEL;
 	sa.requested_mask = mask;
-	sa.error_code = -EACCES;  /* FIXME: was -EPERM before: ??? */
+	sa.error_code = -EACCES;
+
 	error = aa_perm_dentry(profile, dentry, mnt, &sa, check);
 
 out:
@@ -548,13 +536,13 @@ out:
  * by @profile.
  * Returns 0 on success, or else an error code.
  */
-int aa_perm_dir(struct aa_profile *profile, struct dentry *dentry,
-		struct vfsmount *mnt, const char *operation, int mask)
+int aa_perm_dir(struct aa_profile *profile, const char *operation,
+		struct dentry *dentry, struct vfsmount *mnt, int mask)
 {
 	struct aa_audit sa;
 
-	sa.type = AA_AUDITTYPE_DIR;
-	sa.name2 = operation;
+	memset(&sa, 0, sizeof(sa));
+	sa.operation = operation;
 	sa.gfp_mask = GFP_KERNEL;
 	sa.requested_mask = mask;
 	sa.error_code = -EACCES;
@@ -562,13 +550,15 @@ int aa_perm_dir(struct aa_profile *profi
 	return aa_perm_dentry(profile, dentry, mnt, &sa, AA_CHECK_DIR);
 }
 
-int aa_perm_path(struct aa_profile *profile, const char *name, int mask)
+int aa_perm_path(struct aa_profile *profile, const char *operation,
+		 const char *name, int mask)
 {
 	struct aa_audit sa;
 
-	sa.type = AA_AUDITTYPE_FILE;
-	sa.requested_mask = mask;
+	memset(&sa, 0, sizeof(sa));
+	sa.operation = operation;
 	sa.gfp_mask = GFP_KERNEL;
+	sa.requested_mask = mask;
 	sa.name = name;
 
 	sa.denied_mask = aa_file_denied(profile, name, mask);
@@ -604,11 +594,11 @@ int aa_capability(struct aa_task_context
 		 */
 		cap_raise(cxt->caps_logged, cap);
 
-	sa.type = AA_AUDITTYPE_CAP;
-	sa.name = NULL;
-	sa.capability = cap;
-	sa.error_code = error;
+	memset(&sa, 0, sizeof(sa));
+	sa.operation = "capable";
 	sa.gfp_mask = GFP_ATOMIC;
+	sa.name = capability_names[cap];
+	sa.error_code = error;
 
 	error = aa_audit(cxt->profile, &sa);
 
@@ -640,6 +630,9 @@ int aa_link(struct aa_profile *profile,
 	int error, check = 0;
 	struct aa_audit sa;
 
+	memset(&sa, 0, sizeof(sa));
+	sa.operation = "inode_link";
+	sa.gfp_mask = GFP_KERNEL;
 	sa.buffer = NULL;
 	sa.name = aa_get_name(link, link_mnt, &sa.buffer, check);
 	sa.buffer2 = NULL;
@@ -661,12 +654,9 @@ int aa_link(struct aa_profile *profile,
 	if (sa.name && sa.name2) {
 		sa.requested_mask = AA_MAY_LINK;
 		sa.denied_mask = aa_link_denied(profile, sa.name, sa.name2);
-		sa.error_code = sa.denied_mask ? -EPERM : 0;
+		sa.error_code = sa.denied_mask ? -EACCES : 0;
 	}
 
-	sa.type = AA_AUDITTYPE_LINK;
-	sa.gfp_mask = GFP_KERNEL;
-
 	error = aa_audit(profile, &sa);
 
 	aa_put_name_buffer(sa.buffer);
@@ -718,12 +708,14 @@ repeat:
 		unlock_profile(profile);
 
 		if (APPARMOR_COMPLAIN(child_cxt) &&
-		    profile == null_complain_profile)
-			aa_audit_message(profile, GFP_KERNEL,
-					 "LOGPROF-HINT fork child=%d "
-					 "(%d profile %s active %s)",
-					 child->pid, current->pid,
-					 profile->parent->name, profile->name);
+		    profile == null_complain_profile) {
+			struct aa_audit sa;
+			memset(&sa, 0, sizeof(sa));
+			sa.operation = "clone";
+			sa.gfp_mask = GFP_KERNEL;
+			sa.task = child->pid;
+			aa_audit_hint(profile, &sa);
+		}
 		aa_put_profile(profile);
 	} else
 		aa_free_task_context(child_cxt);
@@ -732,8 +724,8 @@ repeat:
 }
 
 static struct aa_profile *
-aa_register_find(struct aa_profile *profile, const char *name, char *buffer,
-		 int mandatory, int complain)
+aa_register_find(struct aa_profile *profile, const char *name, int mandatory,
+		 int complain, struct aa_audit *sa)
 {
 	struct aa_profile *new_profile;
 
@@ -743,21 +735,14 @@ aa_register_find(struct aa_profile *prof
 		AA_DEBUG("%s: setting profile %s\n",
 			 __FUNCTION__, new_profile->name);
 	} else if (mandatory && profile) {
+		sa->info = "mandatory profile missing";
+		sa->denied_mask = MAY_EXEC;
 		if (complain) {
-			aa_audit_message(profile, GFP_KERNEL, "LOGPROF-HINT "
-					 "missing_mandatory_profile image '%s' "
-					 "(%d profile %s active %s)",
-					 name, current->pid,
-					 profile->parent->name, profile->name);
+			aa_audit_hint(profile, sa);
 			profile = aa_dup_profile(null_complain_profile);
 		} else {
-			aa_audit_message(profile, GFP_KERNEL, "REJECTING "
-					 "exec(2) of image '%s'. Profile "
-					 "mandatory and not found. "
-					 "(%d profile %s active %s)",
-					 name, current->pid,
-					 profile->parent->name, profile->name);
-			return ERR_PTR(-EPERM);
+			aa_audit_reject(profile, sa);
+			return ERR_PTR(-EACCES);  /* was -EPERM */
 		}
 	} else {
 		/* Only way we can get into this code is if task
@@ -784,6 +769,7 @@ int aa_register(struct linux_binprm *bpr
 	struct file *filp = bprm->file;
 	struct aa_profile *profile, *old_profile, *new_profile = NULL;
 	int exec_mode = AA_EXEC_UNSAFE, complain = 0;
+	struct aa_audit sa;
 
 	AA_DEBUG("%s\n", __FUNCTION__);
 
@@ -793,6 +779,12 @@ int aa_register(struct linux_binprm *bpr
 		return -ENOENT;
 	}
 
+	memset(&sa, 0, sizeof(sa));
+	sa.operation = "exec";
+	sa.gfp_mask = GFP_KERNEL;
+	sa.name = filename;
+	sa.requested_mask = MAY_EXEC;
+
 repeat:
 	profile = aa_get_profile(current);
 	if (profile) {
@@ -827,8 +819,8 @@ repeat:
 					 filename);
 				new_profile = aa_register_find(profile,
 							       filename,
-							       buffer, 1,
-							       complain);
+							       1, complain,
+							       &sa);
 				break;
 			}
 
@@ -840,17 +832,13 @@ repeat:
 			new_profile = aa_dup_profile(null_complain_profile);
 			exec_mode |= AA_EXEC_UNSAFE;
 		} else {
-			aa_audit_message(profile, GFP_KERNEL, "REJECTING "
-					 "exec(2) of image '%s'. Unable to "
-					 "determine exec qualifier. "
-					 "(%d profile %s active %s)",
-					 filename, current->pid,
-					 profile->parent->name, profile->name);
+			sa.denied_mask = MAY_EXEC;
+			aa_audit_reject(profile, &sa);
 			new_profile = ERR_PTR(-EPERM);
 		}
 	} else {
 		/* Unconfined task, load profile if it exists */
-		new_profile = aa_register_find(NULL, filename, buffer, 0, 0);
+		new_profile = aa_register_find(NULL, filename, 0, 0, &sa);
 		if (new_profile == NULL)
 			goto cleanup;
 	}
@@ -865,13 +853,10 @@ repeat:
 		if (PTR_ERR(old_profile) == -ESTALE)
 			goto repeat;
 		if (PTR_ERR(old_profile) == -EPERM) {
-			aa_audit_message(profile, GFP_KERNEL,
-					 "REJECTING exec(2) of image '%s'. "
-					 "Unable to change profile, ptraced by "
-					 "%d. (%d profile %s active %s)",
-					 filename, current->parent->pid,
-					 current->pid,
-					 profile->parent->name, profile->name);
+			sa.denied_mask = MAY_EXEC;
+			sa.info = "Unable to set profile due to ptrace";
+			sa.task = current->parent->pid;
+			aa_audit_reject(profile, &sa);
 		}
 		new_profile = old_profile;
 		goto cleanup;
@@ -896,12 +881,12 @@ repeat:
 			((unsigned long)bprm->security | bprm_flags);
 	}
 
-	if (complain && new_profile == null_complain_profile)
-		aa_audit_message(new_profile, GFP_ATOMIC,
-				 "LOGPROF-HINT changing_profile "
-				 "(%d profile %s active %s)",
-				 current->pid,
-				 new_profile->parent->name, new_profile->name);
+	if (complain && new_profile == null_complain_profile) {
+		sa.requested_mask = 0;
+		sa.name = NULL;
+		sa.info = "set profile";
+		aa_audit_hint(new_profile, &sa);
+	}
 cleanup:
 	aa_put_name_buffer(buffer);
 	if (IS_ERR(new_profile))
@@ -964,8 +949,8 @@ repeat:
  *
  * Switch to a new hat.  Returns %0 on success, error otherwise.
  */
-static int do_change_hat(const char *hat_name,
-			 struct aa_task_context *new_cxt, u64 hat_magic)
+static int do_change_hat(const char *hat_name, struct aa_task_context *new_cxt,
+			 u64 hat_magic, struct aa_audit *sa)
 {
 	struct aa_task_context *cxt = aa_task_context(current);
 	struct aa_profile *sub;
@@ -978,7 +963,7 @@ static int do_change_hat(const char *hat
 	sub = __aa_find_profile(hat_name, &cxt->profile->parent->sub);
 
 	if ((current->ptrace & PT_PTRACED) && aa_may_ptrace(cxt, sub))
-		return -EPERM;
+		return -EACCES;
 
 	if (sub) {
 		/* change hat */
@@ -987,11 +972,8 @@ static int do_change_hat(const char *hat
 		struct aa_profile *profile = cxt->profile;
 
 		if (APPARMOR_COMPLAIN(cxt)) {
-			aa_audit_message(profile, GFP_ATOMIC,
-					 "LOGPROF-HINT unknown_hat %s "
-					 "(%d profile %s active %s)",
-					 hat_name, current->pid,
-					 profile->parent->name, profile->name);
+			sa->info = "unknown hat";
+			aa_audit_hint(profile, sa);
 		} else {
 			AA_DEBUG("%s: Unknown hatname '%s'. "
 				"Changing to NULL profile "
@@ -1032,15 +1014,13 @@ int aa_change_hat(const char *hat_name, 
 {
 	struct aa_task_context *cxt, *new_cxt;
 	struct aa_profile *profile = NULL;
+	struct aa_audit sa;
 	int error = 0;
 
-	/* Dump out above debugging in WARN mode if we are in AUDIT mode */
-	if (APPARMOR_AUDIT(aa_task_context(current))) {
-		aa_audit_message(NULL, GFP_KERNEL, "change_hat %s, 0x%llx "
-				 "(pid %d)",
-				 hat_name ? hat_name : "NULL", hat_magic,
-				 current->pid);
-	}
+	memset(&sa, 0, sizeof(sa));
+	sa.gfp_mask = GFP_ATOMIC;
+	sa.magic_token = hat_magic;
+	sa.name = hat_name;
 
 	new_cxt = aa_alloc_task_context(GFP_KERNEL);
 	if (!new_cxt)
@@ -1049,6 +1029,8 @@ int aa_change_hat(const char *hat_name, 
 	cxt = lock_task_and_profiles(current, NULL);
 	if (!cxt) {
 		/* An unconfined process cannot change_hat(). */
+		if (APPARMOR_AUDIT(cxt))
+			aa_audit_message(NULL, &sa, AUDIT_APPARMOR_AUDIT);
 		error = -EPERM;
 		goto out;
 	}
@@ -1056,6 +1038,9 @@ int aa_change_hat(const char *hat_name, 
 	/* No need to get reference count: we do not sleep. */
 	profile = cxt->profile;
 
+	if (APPARMOR_AUDIT(cxt))
+		aa_audit_message(profile, &sa, AUDIT_APPARMOR_AUDIT);
+
 	/* check to see if the confined process has any hats. */
 	if (list_empty(&profile->parent->sub) && !PROFILE_COMPLAIN(profile)) {
 		error = -ECHILD;
@@ -1069,7 +1054,8 @@ int aa_change_hat(const char *hat_name, 
 				 __FUNCTION__,
 				 hat_name,
 				 hat_magic);
-			error = do_change_hat(hat_name, new_cxt, hat_magic);
+			error = do_change_hat(hat_name, new_cxt, hat_magic,
+					      &sa);
 		}
 	} else {
 		/*
@@ -1091,27 +1077,16 @@ int aa_change_hat(const char *hat_name, 
 				 * stick with the same hat_magic.
 				 */
 				error = do_change_hat(hat_name, new_cxt,
-						      cxt->hat_magic);
+						      cxt->hat_magic, &sa);
 			}
 		} else if (cxt->hat_magic) {
-			AA_ERROR("KILLING process %d "
-				 "Invalid change_hat() magic# 0x%llx "
-				 "(hatname %s profile %s active %s)\n",
-				 current->pid, hat_magic,
-				 hat_name ? hat_name : "NULL",
-				 profile->parent->name,
-				 profile->name);
-
+			sa.info = "killing process";
+			aa_audit_status(profile, &sa);
 			/* terminate current process */
 			(void)send_sig_info(SIGKILL, NULL, current);
 		} else {	/* cxt->hat_magic == 0 */
-			AA_ERROR("KILLING process %d "
-				 "Task was confined to current subprofile "
-				 "(profile %s active %s)\n",
-				 current->pid,
-				 profile->parent->name,
-				 profile->name);
-
+			sa.info = "killing process confined to current hat";
+			aa_audit_status(profile, &sa);
 			/* terminate current process */
 			(void)send_sig_info(SIGKILL, NULL, current);
 		}
--- a/security/apparmor/module_interface.c
+++ b/security/apparmor/module_interface.c
@@ -241,11 +241,14 @@ struct aa_dfa *aa_unpack_dfa(struct aa_e
 /**
  * aa_unpack_profile - unpack a serialized profile
  * @e: serialized data extent information
- * @error: error code returned if unpacking fails
+ * @depth: recursion depth of unpack
+ * @op: operation profile is being unpacked for
  */
-static struct aa_profile *aa_unpack_profile(struct aa_ext *e, int depth)
+static struct aa_profile *aa_unpack_profile(struct aa_ext *e, int depth,
+					    const char *op)
 {
 	struct aa_profile *profile = NULL;
+	struct aa_audit sa;
 
 	int error = -EPROTO;
 
@@ -288,7 +291,7 @@ static struct aa_profile *aa_unpack_prof
 			goto fail;
 		while (!aa_is_nameX(e, AA_LISTEND, NULL)) {
 			struct aa_profile *subprofile;
-			subprofile = aa_unpack_profile(e, depth + 1);
+			subprofile = aa_unpack_profile(e, depth + 1, op);
 			if (IS_ERR(subprofile)) {
 				error = PTR_ERR(subprofile);
 				goto fail;
@@ -304,8 +307,12 @@ static struct aa_profile *aa_unpack_prof
 	return profile;
 
 fail:
-	aa_audit_message(NULL, GFP_KERNEL, "Invalid profile %s",
-			 profile && profile->name ? profile->name : "unknown");
+	memset(&sa, 0, sizeof(sa));
+	sa.operation = op;
+	sa.gfp_mask = GFP_KERNEL;
+	sa.name = profile && profile->name ? profile->name : "unknown";
+	sa.info = "failed to unpack profile";
+	aa_audit_status(NULL, &sa);
 
 	if (profile)
 		free_aa_profile(profile);
@@ -320,9 +327,10 @@ fail:
  * check interface version unpack a profile and all its hats and patch
  * in any extra information that the profile needs.
  */
-static struct aa_profile *aa_unpack_profile_wrapper(struct aa_ext *e)
+static struct aa_profile *aa_unpack_profile_wrapper(struct aa_ext *e,
+						    const char *op)
 {
-	struct aa_profile *profile = aa_unpack_profile(e, 0);
+	struct aa_profile *profile = aa_unpack_profile(e, 0, op);
 	if (!IS_ERR(profile) &&
 	    (!list_empty(&profile->sub) || profile->flags.complain)) {
 		int error;
@@ -338,21 +346,31 @@ static struct aa_profile *aa_unpack_prof
 /**
  * aa_verify_head - unpack serialized stream header
  * @e: serialized data read head
+ * @op: operation header is being verified for
  *
  * returns error or 0 if header is good
  */
-static int aa_verify_header(struct aa_ext *e)
+static int aa_verify_header(struct aa_ext *e, const char *op)
 {
 	/* get the interface version */
 	if (!aa_is_u32(e, &e->version, "version")) {
-		aa_audit_message(NULL, GFP_KERNEL, "Interface version missing");
+		struct aa_audit sa;
+		memset(&sa, 0, sizeof(sa));
+		sa.operation = op;
+		sa.gfp_mask = GFP_KERNEL;
+		sa.info = "invalid profile format";
+		aa_audit_status(NULL, &sa);
 		return -EPROTONOSUPPORT;
 	}
 
 	/* check that the interface version is currently supported */
 	if (e->version != 3) {
-		aa_audit_message(NULL, GFP_KERNEL, "Unsupported interface "
-				 "version (%d)", e->version);
+		struct aa_audit sa;
+		memset(&sa, 0, sizeof(sa));
+		sa.operation = op;
+		sa.gfp_mask = GFP_KERNEL;
+		sa.info = "unsupported interface version";
+		aa_audit_status(NULL, &sa);
 		return -EPROTONOSUPPORT;
 	}
 	return 0;
@@ -371,11 +389,11 @@ ssize_t aa_add_profile(void *data, size_
 		.end = data + size,
 		.pos = data
 	};
-	ssize_t error = aa_verify_header(&e);
+	ssize_t error = aa_verify_header(&e, "profile_load");
 	if (error)
 		return error;
 
-	profile = aa_unpack_profile_wrapper(&e);
+	profile = aa_unpack_profile_wrapper(&e, "profile_load");
 	if (IS_ERR(profile))
 		return PTR_ERR(profile);
 
@@ -451,11 +469,11 @@ ssize_t aa_replace_profile(void *udata, 
 		.end = udata + size,
 		.pos = udata
 	};
-	ssize_t error = aa_verify_header(&e);
+	ssize_t error = aa_verify_header(&e, "profile_replace");
 	if (error)
 		return error;
 
-	new_profile = aa_unpack_profile_wrapper(&e);
+	new_profile = aa_unpack_profile_wrapper(&e, "profile_replace");
 	if (IS_ERR(new_profile))
 		return PTR_ERR(new_profile);
 
--- a/security/apparmor/procattr.c
+++ b/security/apparmor/procattr.c
@@ -81,6 +81,12 @@ int aa_setprocattr_changehat(char *args)
 int aa_setprocattr_setprofile(struct task_struct *task, char *args)
 {
 	struct aa_profile *old_profile, *new_profile;
+	struct aa_audit sa;
+
+	memset(&sa, 0, sizeof(sa));
+	sa.operation = "profile_set";
+	sa.gfp_mask = GFP_KERNEL;
+	sa.task = task->pid;
 
 	AA_DEBUG("%s: current %d\n",
 		 __FUNCTION__, current->pid);
@@ -91,11 +97,9 @@ repeat:
 	else {
 		new_profile = aa_find_profile(args);
 		if (!new_profile) {
-			aa_audit_message(NULL, GFP_KERNEL, "Unable to switch "
-					 "task %d to profile '%s'. No such "
-					 "profile.",
-					 task->pid, args);
-
+			sa.name = args;
+			sa.info = "unknown profile";
+			aa_audit_reject(NULL, &sa);
 			return -EINVAL;
 		}
 	}
@@ -112,25 +116,20 @@ repeat:
 	}
 
 	if (new_profile) {
-		aa_audit_message(NULL, GFP_KERNEL, "Switching task %d profile "
-				 "%s active %s to new profile %s",
-				 task->pid, old_profile ?
-				 old_profile->parent->name : "unconfined",
-				 old_profile ? old_profile->name : "unconfined",
-				 args);
+		sa.name = args;
+		sa.name2 = old_profile ? old_profile->parent->name :
+			"unconfined";
+		aa_audit_status(NULL, &sa);
 	} else {
 		if (old_profile) {
-			aa_audit_message(NULL, GFP_KERNEL, "Unconfining task "
-					 "%d profile %s active %s",
-					 task->pid, old_profile->parent->name,
-					 old_profile->name);
+			sa.name = "unconfined";
+			sa.name2 = old_profile->parent->name;
+			aa_audit_status(NULL, &sa);
 		} else {
-			aa_audit_message(NULL, GFP_KERNEL, "task %d is already "
-					 "unconfined",
-					 task->pid);
+			sa.info = "task is unconfined";
+			aa_audit_status(NULL, &sa);
 		}
 	}
-
 	aa_put_profile(old_profile);
 	aa_put_profile(new_profile);
 
