---
 security/apparmor/main.c     |  251 +++++++++++++++++--------------------------
 security/apparmor/procattr.c |    5 
 2 files changed, 102 insertions(+), 154 deletions(-)

--- a/security/apparmor/main.c
+++ b/security/apparmor/main.c
@@ -934,72 +934,52 @@ repeat:
 	}
 }
 
-static int do_change_profile(struct task_struct *task, const char *name,
-			     const char *hat, u64 cookie, struct aa_audit *sa)
+static int do_change_profile(struct aa_profile *expected, const char *name,
+			     u64 cookie, int restore, struct aa_audit *sa)
 {
-	struct aa_profile *profile = NULL, *previous_profile = NULL,
-		*name_profile = NULL;
-	struct aa_task_context *new_cxt, *cxt, *old_cxt = NULL;
+	struct aa_profile *profile = NULL, *old_profile = NULL,
+		*previous_profile = NULL;
+	struct aa_task_context *new_cxt, *cxt;
 	int error = 0;
 
+	sa->name = name;
+
 	new_cxt = aa_alloc_task_context(GFP_KERNEL);
 	if (!new_cxt)
 		return -ENOMEM;
 
-repeat:
-	if (name) {
-		if (hat)
-			profile = aa_find_profile2(name, hat);
-		else
-			profile = aa_find_profile(name);
-		if (!profile)
-		    /* if we name_profile is set then returning
-		     * and return profile has been removed, so go
-		     * unconfined.
-		     */
-		    profile = aa_dup_profile(null_complain_profile);
-	}
-	cxt = lock_task_and_profiles(task, profile);
+	profile = aa_find_profile(name);
+	if (!profile && !restore)
+		profile = aa_dup_profile(null_complain_profile);
+
+	cxt = lock_task_and_profiles(current, profile);
 	if (!cxt) {
 		error = -EPERM;
 		goto out;
 	}
+	old_profile = cxt->profile;
 
-	if (!name || (hat && old_cxt && old_cxt != cxt)) {
-		/* need to find the change_hat name */
-		aa_put_profile(name_profile);
-		if (cxt->previous_profile)
-			name_profile = aa_dup_profile(cxt->previous_profile);
-		else
-			name_profile = aa_dup_profile(cxt->profile);
-		name = name_profile->name;
-		unlock_task_and_profiles(task, cxt, profile);
-		aa_put_profile(profile);
-		goto repeat;
-	}
-
-	if (unlikely(profile && profile->isstale)) {
-		unlock_task_and_profiles(task, cxt, profile);
-		aa_put_profile(profile);
-		goto repeat;
+	if (cxt->profile != expected || (profile && profile->isstale)) {
+		error = -ESTALE;
+		goto out;
 	}
 
 	if (cxt->previous_profile) {
 		if (cxt->cookie != cookie) {
 			error = -EACCES;
 			sa->info = "killing process";
-			aa_audit_reject(profile, sa);
+			aa_audit_reject(cxt->profile, sa);
 			/* terminate process */
-			(void)send_sig_info(SIGKILL, NULL, task);
+			(void)send_sig_info(SIGKILL, NULL, current);
 			goto out;
 		}
 
-		previous_profile = cxt->previous_profile;
-	} else {
+		if (!restore)
+			previous_profile = cxt->previous_profile;
+	} else
 		previous_profile = cxt->profile;
-	}
 
-	if ((task->ptrace & PT_PTRACED) && aa_may_ptrace(cxt, profile)) {
+	if ((current->ptrace & PT_PTRACED) && aa_may_ptrace(cxt, profile)) {
 		error = -EACCES;
 		goto out;
 	}
@@ -1015,79 +995,19 @@ repeat:
 
 	if (APPARMOR_AUDIT(cxt))
 		aa_audit_message(cxt->profile, sa, AUDIT_APPARMOR_AUDIT);
-	aa_change_task_context(task, new_cxt, profile, cookie,
-			       previous_profile);
-
-out:
-	if (aa_task_context(task) != new_cxt)
-		aa_free_task_context(new_cxt);
-	unlock_task_and_profiles(task, cxt, profile);
-	aa_put_profile(profile);
-	aa_put_profile(name_profile);
-	return error;
-}
-
-static int do_restore_profile(struct task_struct *task, u64 cookie,
-			      struct aa_audit *sa)
-{
-	struct aa_profile *profile = NULL;
-	struct aa_task_context *cxt, *new_cxt, *old_cxt = NULL;
-	int error = 0;
-
-	new_cxt = aa_alloc_task_context(GFP_KERNEL);
-	if (!new_cxt)
-		return -ENOMEM;
-
-repeat:
-	cxt = lock_task_and_profiles(task, profile);
-	if (!cxt) {
-		error = -EPERM;
-		goto out;
-	}
-
-	/* ignore returning to stored profile when there isn't one */
-	if (!cxt->previous_profile)
-		goto out;
-
-	if (!profile)
-		/* setting profile with previous_profile is locking safe */
-		profile = aa_dup_profile(cxt->previous_profile);
-
-	if (profile->isstale || (old_cxt && old_cxt != cxt)) {
-		struct aa_profile *previous_profile;
-
-		previous_profile = aa_dup_profile(cxt->previous_profile);
-		old_cxt = cxt;
-		unlock_task_and_profiles(task, cxt, profile);
-		aa_put_profile(profile);
-		profile = aa_find_profile(previous_profile->name);
-		aa_put_profile(previous_profile);
-		goto repeat;
-	}
 
-	if (cxt->cookie != cookie) {
-		error = -EACCES;
-		sa->info = "killing process";
-		aa_audit_reject(profile, sa);
-		/* terminate process */
-		(void)send_sig_info(SIGKILL, NULL, task);
-		goto out;
-	}
+	if (!restore && cookie)
+		aa_change_task_context(current, new_cxt, profile, cookie,
+				       previous_profile);
+	else
+		/* either return to previous_profile, or a permanent change */
+		aa_change_task_context(current, new_cxt, profile, 0, NULL);
 
-	if ((task->ptrace & PT_PTRACED) && aa_may_ptrace(cxt, profile))
-		error = -EACCES;
-	else {
-		if (APPARMOR_AUDIT(cxt)) {
-			sa->name = profile->name;
-			aa_audit_message(cxt->profile, sa,
-					 AUDIT_APPARMOR_AUDIT);
-		}
-		aa_change_task_context(task, new_cxt, profile, 0, NULL);
-	}
 out:
-	if (aa_task_context(task) != new_cxt)
+	if (aa_task_context(current) != new_cxt)
 		aa_free_task_context(new_cxt);
-	unlock_task_and_profiles(task, cxt, profile);
+	task_unlock(current);
+	unlock_both_profiles(old_profile, profile);
 	aa_put_profile(profile);
 	return error;
 }
@@ -1106,35 +1026,46 @@ out:
  */
 int aa_change_profile(const char *name, u64 cookie)
 {
-	struct aa_profile *profile;
+	struct aa_task_context *cxt;
+	struct aa_profile *profile, *previous_profile;
 	struct aa_audit sa;
 	int error = 0;
 
 	memset(&sa, 0, sizeof(sa));
 	sa.gfp_mask = GFP_ATOMIC;
 	sa.cookie = cookie;
-	sa.name = name;
 	sa.operation = "change_profile";
 
-	profile = aa_get_profile(current);
-	if (!profile)
-		/* an unconfined process can not change_profile */
+repeat:
+	task_lock(current);
+	cxt = aa_task_context(current);
+	if (!cxt) {
+		task_unlock(current);
 		return -EPERM;
+	}
+	profile = aa_dup_profile(cxt->profile);
+	previous_profile = aa_dup_profile(cxt->previous_profile);
+	task_unlock(current);
 
 	if (name) {
 		if (profile != null_complain_profile &&
-		    !aa_match(profile->file_rules, name) & AA_CHANGE_PROFILE) {
+		    !(aa_match(profile->file_rules, name) &
+		      AA_CHANGE_PROFILE)) {
 			/* no permission to transition to profile @name */
 			aa_put_profile(profile);
 			return -EACCES;
 		}
+		error = do_change_profile(profile, name, cookie, 0, &sa);
+	} else if (previous_profile)
+		error = do_change_profile(profile, previous_profile->name,
+					  cookie, 1, &sa);
+	/* else ignore restores when there is no saved profile */
 
-		error = do_change_profile(current, name, NULL, cookie, &sa);
-	} else {
-		error = do_restore_profile(current, cookie, &sa);
-	}
-
+	aa_put_profile(previous_profile);
 	aa_put_profile(profile);
+	if (error == -ESTALE)
+		goto repeat;
+
 	return error;
 }
 
@@ -1151,22 +1082,53 @@ int aa_change_profile(const char *name, 
  */
 int aa_change_hat(const char *hat_name, u64 cookie)
 {
+	struct aa_task_context *cxt;
+	struct aa_profile *profile, *previous_profile;
 	struct aa_audit sa;
 	int error = 0;
 
 	memset(&sa, 0, sizeof(sa));
 	sa.gfp_mask = GFP_ATOMIC;
 	sa.cookie = cookie;
-	sa.name = hat_name;
 	sa.operation = "change_hat";
 
-	/* FIXME: there is currently no way to tell if a profile doesn't have
-	 * hats so that we can return -ECHILD
-	 */
-	if (hat_name)
-		error = do_change_profile(current, NULL, hat_name, cookie, &sa);
-	else
-		error = do_restore_profile(current, cookie, &sa);
+repeat:
+	task_lock(current);
+	cxt = aa_task_context(current);
+	if (!cxt) {
+		task_unlock(current);
+		return -EPERM;
+	}
+	profile = aa_dup_profile(cxt->profile);
+	previous_profile = aa_dup_profile(cxt->previous_profile);
+	task_unlock(current);
+
+	if (hat_name) {
+		char *name, *profile_name;
+		if (previous_profile)
+			profile_name = previous_profile->name;
+		else
+			profile_name = profile->name;
+
+		name = kmalloc(strlen(hat_name) + 3 + strlen(profile_name),
+			       GFP_KERNEL);
+		if (!name) {
+			error = -ENOMEM;
+			goto out;
+		}
+		sprintf(name, "%s//%s", profile_name, hat_name);
+		error = do_change_profile(profile, name, cookie, 0, &sa);
+		kfree(name);
+	} else if (previous_profile)
+		error = do_change_profile(profile, previous_profile->name,
+					  cookie, 1, &sa);
+	/* else ignore restores when there is no saved profile */
+
+out:
+	aa_put_profile(previous_profile);
+	aa_put_profile(profile);
+	if (error == -ESTALE)
+		goto repeat;
 
 	return error;
 }
@@ -1193,13 +1155,15 @@ struct aa_profile *__aa_replace_profile(
 
 	cxt = lock_task_and_profiles(task, profile);
 	if (unlikely(profile && profile->isstale)) {
-		unlock_task_and_profiles(task, cxt, profile);
+		task_unlock(task);
+		unlock_both_profiles(profile, cxt ? cxt->profile : NULL);
 		aa_free_task_context(new_cxt);
 		return ERR_PTR(-ESTALE);
 	}
 
 	if ((current->ptrace & PT_PTRACED) && aa_may_ptrace(cxt, profile)) {
-		unlock_task_and_profiles(task, cxt, profile);
+		task_unlock(task);
+		unlock_both_profiles(profile, cxt ? cxt->profile : NULL);
 		aa_free_task_context(new_cxt);
 		return ERR_PTR(-EPERM);
 	}
@@ -1208,7 +1172,8 @@ struct aa_profile *__aa_replace_profile(
 		old_profile = aa_dup_profile(cxt->profile);
 	aa_change_task_context(task, new_cxt, profile, 0, NULL);
 
-	unlock_task_and_profiles(task, cxt, profile);
+	task_unlock(task);
+	unlock_both_profiles(profile, old_profile);
 	return old_profile;
 }
 
@@ -1228,16 +1193,13 @@ lock_task_and_profiles(struct task_struc
 {
 	struct aa_task_context *cxt;
 	struct aa_profile *old_profile = NULL;
-	int lock_token = !profile;
 
 	rcu_read_lock();
 repeat:
 	cxt = aa_task_context(task);
-	if (cxt) {
+	if (cxt)
 		old_profile = cxt->profile;
-		if (lock_token)
-			profile = cxt->previous_profile;
-	}
+
 	lock_both_profiles(profile, old_profile);
 	task_lock(task);
 
@@ -1246,25 +1208,12 @@ repeat:
 		task_unlock(task);
 		unlock_both_profiles(profile, old_profile);
 		old_profile = NULL;
-		if (lock_token)
-			profile = NULL;
 		goto repeat;
 	}
 	rcu_read_unlock();
 	return cxt;
 }
 
-void unlock_task_and_profiles(struct task_struct *task,
-			      struct aa_task_context *cxt,
-			      struct aa_profile *profile)
-{
-	task_unlock(task);
-	if (cxt && !profile)
-		profile = cxt->previous_profile;
-	unlock_both_profiles(profile, cxt ? cxt->profile : NULL);
-}
-
-
 static void free_aa_task_context_rcu_callback(struct rcu_head *head)
 {
 	struct aa_task_context *cxt;
--- a/security/apparmor/procattr.c
+++ b/security/apparmor/procattr.c
@@ -27,7 +27,6 @@ int aa_getprocattr(struct aa_profile *pr
 		str = kmalloc(*len, GFP_ATOMIC);
 		if (!str)
 			return -ENOMEM;
-		/* FIXME: do we want to report ^ instead of // for hatnames */
 
 		memcpy(str, profile->name, name_len);
 		str += name_len;
@@ -55,10 +54,11 @@ static char *split_token_from_name(const
 	char *name;
 
 	*cookie = simple_strtoull(args, &name, 16);
-	if (name == args || *name != '^') {
+	if ((name == args) || *name != '^') {
 		AA_ERROR("%s: Invalid input '%s'", op, args);
 		return ERR_PTR(-EINVAL);
 	}
+
 	name++;  /* skip ^ */
 	if (!*name)
 		name = NULL;
@@ -151,6 +151,5 @@ repeat:
 	}
 	aa_put_profile(old_profile);
 	aa_put_profile(new_profile);
-
 	return 0;
 }
