Index: b/security/apparmor/main.c
===================================================================
--- a/security/apparmor/main.c
+++ b/security/apparmor/main.c
@@ -1048,6 +1048,14 @@ static inline int do_change_hat(const ch
 	if (sub) {
 		/* change hat */
 		aa_change_profile(cxt, sub, hat_magic);
+		/*
+		 * aa_change_profile switches profile lists but we don't
+		 * want this for change_hat.  Switch back to the parents
+		 * list.
+		 * FIXME: update to a full profile change mechanism
+		 * to get rid of this special casing
+		 */
+		list_move(&cxt->list, &sub->parent->task_contexts);
 	} else {
 		struct aa_profile *profile = cxt->profile;
 
@@ -1078,6 +1086,14 @@ static inline int do_change_hat(const ch
 		 * In learning mode, this allows us to learn about new hats.
 		 */
 		aa_change_profile(cxt, cxt->profile->null_profile, hat_magic);
+		/*
+		 * aa_change_profile switches profile lists but we don't
+		 * want this for change_hat.  Switch back to the parents
+		 * list.
+		 * FIXME: update to a full profile change mechanism
+		 * to get rid of this special casing
+		 */
+		list_move(&cxt->list, &cxt->profile->parent->task_contexts);
 	}
 
 	return error;
@@ -1157,6 +1173,11 @@ repeat:
 			if (!hat_name) {
 				/* Return from subprofile back to parent. */
 				aa_change_profile(cxt, cxt->profile->parent, 0);
+				/*
+				 * switching lists is not needed here because
+				 * aa_change_profile list move will leave the
+				 * cxt on the correct list
+				 */
 			} else {
 				/*
 				 * Change to another (sibling) profile, and
Index: b/security/apparmor/module_interface.c
===================================================================
--- a/security/apparmor/module_interface.c
+++ b/security/apparmor/module_interface.c
@@ -57,6 +57,14 @@ static inline void task_replace(struct a
 			hat = aa_dup_profile(new_profile->null_profile);
 
 		aa_change_profile(cxt, hat, cxt->hat_magic);
+		/*
+		 * aa_change_profile switches profile lists but we don't
+		 * want this for change_hat.  Switch back to the parents
+		 * list.
+		 * FIXME: update to a full profile change mechanism
+		 * to get rid of this special casing
+		 */
+		list_move(&cxt->list, &hat->parent->task_contexts);
 		aa_put_profile(hat);
 	} else
 		aa_change_profile(cxt, new_profile, cxt->hat_magic);
@@ -451,7 +459,14 @@ ssize_t aa_file_prof_replace(void *udata
 	write_lock(&profile_list_lock);
 	old_profile = __aa_find_profile(new_profile->name, &profile_list);
 	if (old_profile) {
-		lock_profile(old_profile);
+		/*
+		 * new_profile needs to be locked in the case that there
+		 * are multiple tasks on old_profiles list, this avoids
+		 * a race between an already replaced task changing its
+		 * profile (updating the list) and replacement updating
+		 * the list
+		 */
+		lock_both_profiles(old_profile, new_profile);
 		old_profile->isstale = 1;
 		while (!list_empty(&old_profile->task_contexts)) {
 			struct aa_task_context *cxt =
@@ -461,7 +476,7 @@ ssize_t aa_file_prof_replace(void *udata
 			task_replace(cxt, new_profile);
 			task_unlock(cxt->task);
 		}
-		unlock_profile(old_profile);
+		unlock_both_profiles(old_profile, new_profile);
 
 		list_del_init(&old_profile->list);
 		aa_put_profile(old_profile);
