---
 security/apparmor/apparmor.h         |   18 +++----
 security/apparmor/inline.h           |    2 
 security/apparmor/main.c             |   88 +++++++++++++++++------------------
 security/apparmor/module_interface.c |    4 -
 security/apparmor/procattr.c         |   20 +++----
 5 files changed, 67 insertions(+), 65 deletions(-)

--- a/security/apparmor/apparmor.h
+++ b/security/apparmor/apparmor.h
@@ -120,8 +120,8 @@ extern struct mutex aa_interface_lock;
 /**
  * struct aa_task_context - primary label for confined tasks
  * @profile: the current profile
- * @token_profile: previous profile that may be returned to by matching @token
- * @token: the token controling the ability to return to previous profile
+ * @previous_profile: profile the task may return to
+ * @cookie: magic value the task must know for returning to @previous_profile
  * @list: list this aa_task_context is on
  * @task: task that the aa_task_context confines
  * @rcu: rcu head used when freeing the aa_task_context
@@ -131,9 +131,9 @@ extern struct mutex aa_interface_lock;
  * change_hat).  Plus the hat_magic needed during change_hat.
  */
 struct aa_task_context {
-	struct aa_profile *profile;	/* The current profile */
-	struct aa_profile *token_profile;
-	u64 token;			/* used with change_profile */
+	struct aa_profile *profile;
+	struct aa_profile *previous_profile;
+	u64 cookie;
 	struct list_head list;
 	struct task_struct *task;
 	struct rcu_head rcu;
@@ -156,7 +156,7 @@ struct aa_audit {
 	int requested_mask, denied_mask;
 	struct iattr *iattr;
 	pid_t task, parent;
-	u64 token;
+	u64 cookie;
 	int error_code;
 };
 
@@ -215,7 +215,7 @@ extern int aa_clone(struct task_struct *
 extern int aa_register(struct linux_binprm *bprm);
 extern void aa_release(struct task_struct *task);
 extern int aa_change_hat(const char *id, u64 hat_magic);
-extern int aa_change_profile(const char *name, u64 token);
+extern int aa_change_profile(const char *name, u64 cookie);
 extern struct aa_profile *__aa_find_profile(const char *name,
 					    struct list_head *list);
 extern struct aa_profile *__aa_find_profile2(const char *name,
@@ -230,8 +230,8 @@ extern void unlock_task_and_profiles(str
 				     struct aa_profile *profile);
 extern void aa_change_task_context(struct task_struct *task,
 				   struct aa_task_context *new_cxt,
-				   struct aa_profile *profile, u64 token,
-				   struct aa_profile *token_profile);
+				   struct aa_profile *profile, u64 cookie,
+				   struct aa_profile *previous_profile);
 extern int aa_may_ptrace(struct aa_task_context *cxt,
 			 struct aa_profile *tracee);
 
--- a/security/apparmor/inline.h
+++ b/security/apparmor/inline.h
@@ -101,7 +101,7 @@ static inline void aa_free_task_context(
 {
 	if (cxt) {
 		aa_put_profile(cxt->profile);
-		aa_put_profile(cxt->token_profile);
+		aa_put_profile(cxt->previous_profile);
 		kfree(cxt);
 	}
 }
--- a/security/apparmor/main.c
+++ b/security/apparmor/main.c
@@ -343,8 +343,8 @@ static int aa_audit_base(struct aa_profi
 		audit_log_untrustedstring(ab, sa->name2);
 	}
 
-	if (sa->token)
-		audit_log_format(ab, " token=%llu", sa->token);
+	if (sa->cookie)
+		audit_log_format(ab, " cookie=%llu", sa->cookie);
 
 	audit_log_format(ab, " pid=%d", current->pid);
 
@@ -697,7 +697,7 @@ repeat:
 
 		/* No need to grab the child's task lock here. */
 		aa_change_task_context(child, child_cxt, profile,
-				       cxt->token, cxt->token_profile);
+				       cxt->cookie, cxt->previous_profile);
 		unlock_profile(profile);
 
 		if (APPARMOR_COMPLAIN(child_cxt) &&
@@ -935,9 +935,9 @@ repeat:
 }
 
 static int do_change_profile(struct task_struct *task, const char *name,
-			     const char *hat, u64 token, struct aa_audit *sa)
+			     const char *hat, u64 cookie, struct aa_audit *sa)
 {
-	struct aa_profile *profile = NULL, *token_profile = NULL,
+	struct aa_profile *profile = NULL, *previous_profile = NULL,
 		*name_profile = NULL;
 	struct aa_task_context *new_cxt, *cxt, *old_cxt = NULL;
 	int error = 0;
@@ -968,8 +968,8 @@ repeat:
 	if (!name || (hat && old_cxt && old_cxt != cxt)) {
 		/* need to find the change_hat name */
 		aa_put_profile(name_profile);
-		if (cxt->token_profile)
-			name_profile = aa_dup_profile(cxt->token_profile);
+		if (cxt->previous_profile)
+			name_profile = aa_dup_profile(cxt->previous_profile);
 		else
 			name_profile = aa_dup_profile(cxt->profile);
 		name = name_profile->name;
@@ -984,8 +984,8 @@ repeat:
 		goto repeat;
 	}
 
-	if (cxt->token_profile) {
-		if (cxt->token != token) {
+	if (cxt->previous_profile) {
+		if (cxt->cookie != cookie) {
 			error = -EACCES;
 			sa->info = "killing process";
 			aa_audit_reject(profile, sa);
@@ -994,9 +994,9 @@ repeat:
 			goto out;
 		}
 
-		token_profile = cxt->token_profile;
+		previous_profile = cxt->previous_profile;
 	} else {
-		token_profile = cxt->profile;
+		previous_profile = cxt->profile;
 	}
 
 	if ((task->ptrace & PT_PTRACED) && aa_may_ptrace(cxt, profile)) {
@@ -1015,7 +1015,8 @@ repeat:
 
 	if (APPARMOR_AUDIT(cxt))
 		aa_audit_message(cxt->profile, sa, AUDIT_APPARMOR_AUDIT);
-	aa_change_task_context(task, new_cxt, profile, token, token_profile);
+	aa_change_task_context(task, new_cxt, profile, cookie,
+			       previous_profile);
 
 out:
 	if (aa_task_context(task) != new_cxt)
@@ -1026,7 +1027,7 @@ out:
 	return error;
 }
 
-static int do_restore_profile(struct task_struct *task, u64 token,
+static int do_restore_profile(struct task_struct *task, u64 cookie,
 			      struct aa_audit *sa)
 {
 	struct aa_profile *profile = NULL;
@@ -1045,25 +1046,26 @@ repeat:
 	}
 
 	/* ignore returning to stored profile when there isn't one */
-	if (!cxt->token_profile)
+	if (!cxt->previous_profile)
 		goto out;
 
 	if (!profile)
-		/* setting profile with token_profile is locking safe */
-		profile = aa_dup_profile(cxt->token_profile);
+		/* setting profile with previous_profile is locking safe */
+		profile = aa_dup_profile(cxt->previous_profile);
 
 	if (profile->isstale || (old_cxt && old_cxt != cxt)) {
-		struct aa_profile *token_profile;
-		token_profile = aa_dup_profile(cxt->token_profile);
+		struct aa_profile *previous_profile;
+
+		previous_profile = aa_dup_profile(cxt->previous_profile);
 		old_cxt = cxt;
 		unlock_task_and_profiles(task, cxt, profile);
 		aa_put_profile(profile);
-		profile = aa_find_profile(token_profile->name);
-		aa_put_profile(token_profile);
+		profile = aa_find_profile(previous_profile->name);
+		aa_put_profile(previous_profile);
 		goto repeat;
 	}
 
-	if (cxt->token != token) {
+	if (cxt->cookie != cookie) {
 		error = -EACCES;
 		sa->info = "killing process";
 		aa_audit_reject(profile, sa);
@@ -1094,15 +1096,15 @@ out:
 /**
  * aa_change_profile - change profile to/from previous stored profile
  * @name: name of profile to change to
- * @token: token to validate the profile change
+ * @cookie: magic value to validate the profile change
  *
- * Change to new profile @name, and store the @token in the current task
- * context.  If the new @name is %NULL and the @token matches that
- * stored in the current task context, return to the stored token_profile.
+ * Change to new profile @name, and store the @cookie in the current task
+ * context.  If the new @name is %NULL and the @cookie matches that
+ * stored in the current task context, return to the previous profile.
  *
  * Returns %0 on success, error otherwise.
  */
-int aa_change_profile(const char *name, u64 token)
+int aa_change_profile(const char *name, u64 cookie)
 {
 	struct aa_profile *profile;
 	struct aa_audit sa;
@@ -1110,7 +1112,7 @@ int aa_change_profile(const char *name, 
 
 	memset(&sa, 0, sizeof(sa));
 	sa.gfp_mask = GFP_ATOMIC;
-	sa.token = token;
+	sa.cookie = cookie;
 	sa.name = name;
 	sa.operation = "change_profile";
 
@@ -1127,9 +1129,9 @@ int aa_change_profile(const char *name, 
 			return -EACCES;
 		}
 
-		error = do_change_profile(current, name, NULL, token, &sa);
+		error = do_change_profile(current, name, NULL, cookie, &sa);
 	} else {
-		error = do_restore_profile(current, token, &sa);
+		error = do_restore_profile(current, cookie, &sa);
 	}
 
 	aa_put_profile(profile);
@@ -1139,22 +1141,22 @@ int aa_change_profile(const char *name, 
 /**
  * aa_change_hat - change hat to/from subprofile
  * @hat_name: hat to change to
- * @token: token to validate the hat change
+ * @cookie: magic value to validate the hat change
  *
  * Change to new @hat_name, and store the @hat_magic in the current task
- * context.  If the new @hat_name is %NULL and the @token matches that
+ * context.  If the new @hat_name is %NULL and the @cookie matches that
  * stored in the current task context and is not 0, return to the top level
  * profile.
  * Returns %0 on success, error otherwise.
  */
-int aa_change_hat(const char *hat_name, u64 token)
+int aa_change_hat(const char *hat_name, u64 cookie)
 {
 	struct aa_audit sa;
 	int error = 0;
 
 	memset(&sa, 0, sizeof(sa));
 	sa.gfp_mask = GFP_ATOMIC;
-	sa.token = token;
+	sa.cookie = cookie;
 	sa.name = hat_name;
 	sa.operation = "change_hat";
 
@@ -1162,9 +1164,9 @@ int aa_change_hat(const char *hat_name, 
 	 * hats so that we can return -ECHILD
 	 */
 	if (hat_name)
-		error = do_change_profile(current, NULL, hat_name, token, &sa);
+		error = do_change_profile(current, NULL, hat_name, cookie, &sa);
 	else
-		error = do_restore_profile(current, token, &sa);
+		error = do_restore_profile(current, cookie, &sa);
 
 	return error;
 }
@@ -1234,7 +1236,7 @@ repeat:
 	if (cxt) {
 		old_profile = cxt->profile;
 		if (lock_token)
-			profile = cxt->token_profile;
+			profile = cxt->previous_profile;
 	}
 	lock_both_profiles(profile, old_profile);
 	task_lock(task);
@@ -1258,7 +1260,7 @@ void unlock_task_and_profiles(struct tas
 {
 	task_unlock(task);
 	if (cxt && !profile)
-		profile = cxt->token_profile;
+		profile = cxt->previous_profile;
 	unlock_both_profiles(profile, cxt ? cxt->profile : NULL);
 }
 
@@ -1276,13 +1278,13 @@ static void free_aa_task_context_rcu_cal
  * @task: task that is having its task context changed
  * @new_cxt: new task context to use after the switch
  * @profile: new profile to use after the switch
- * @token: token value to switch to
- * @token_profile: profile that can be returned to
+ * @cookie: magic value to switch to
+ * @previous_profile: profile the task can return to
  */
 void aa_change_task_context(struct task_struct *task,
 			    struct aa_task_context *new_cxt,
-			    struct aa_profile *profile, u64 token,
-			    struct aa_profile *token_profile)
+			    struct aa_profile *profile, u64 cookie,
+			    struct aa_profile *previous_profile)
 {
 	struct aa_task_context *old_cxt = aa_task_context(task);
 
@@ -1294,10 +1296,10 @@ void aa_change_task_context(struct task_
 		/* clear the caps_logged cache, so that new profile/hat has
 		 * chance to emit its own set of cap messages */
 		new_cxt->caps_logged = CAP_EMPTY_SET;
-		new_cxt->token = token;
+		new_cxt->cookie = cookie;
 		new_cxt->task = task;
 		new_cxt->profile = aa_dup_profile(profile);
-		new_cxt->token_profile = aa_dup_profile(token_profile);
+		new_cxt->previous_profile = aa_dup_profile(previous_profile);
 		list_move(&new_cxt->list, &profile->task_contexts);
 	}
 	rcu_assign_pointer(task->security, new_cxt);
--- a/security/apparmor/module_interface.c
+++ b/security/apparmor/module_interface.c
@@ -391,8 +391,8 @@ static inline void task_replace(struct t
 		 cxt->task->pid,
 		 cxt->profile->name, cxt->profile);
 
-	aa_change_task_context(task, new_cxt, new_profile, cxt->token,
-			       cxt->token_profile);
+	aa_change_task_context(task, new_cxt, new_profile, cxt->cookie,
+			       cxt->previous_profile);
 }
 
 /**
--- a/security/apparmor/procattr.c
+++ b/security/apparmor/procattr.c
@@ -50,11 +50,11 @@ int aa_getprocattr(struct aa_profile *pr
 	return 0;
 }
 
-static char *split_token_from_name(const char *op, char *args, u64 *token)
+static char *split_token_from_name(const char *op, char *args, u64 *cookie)
 {
 	char *name;
 
-	*token = simple_strtoull(args, &name, 16);
+	*cookie = simple_strtoull(args, &name, 16);
 	if (name == args || *name != '^') {
 		AA_ERROR("%s: Invalid input '%s'", op, args);
 		return ERR_PTR(-EINVAL);
@@ -68,33 +68,33 @@ static char *split_token_from_name(const
 int aa_setprocattr_changehat(char *args)
 {
 	char *hat;
-	u64 token;
+	u64 cookie;
 
-	hat = split_token_from_name("change_hat", args, &token);
+	hat = split_token_from_name("change_hat", args, &cookie);
 	if (IS_ERR(hat))
 		return PTR_ERR(hat);
 
-	if (!hat && !token) {
+	if (!hat && !cookie) {
 		AA_ERROR("change_hat: Invalid input, NULL hat and NULL magic");
 		return -EINVAL;
 	}
 
 	AA_DEBUG("%s: Magic 0x%llx Hat '%s'\n",
-		 __FUNCTION__, token, hat ? hat : NULL);
+		 __FUNCTION__, cookie, hat ? hat : NULL);
 
-	return aa_change_hat(hat, token);
+	return aa_change_hat(hat, cookie);
 }
 
 int aa_setprocattr_changeprofile(char *args)
 {
 	char *name;
-	u64 token;
+	u64 cookie;
 
-	name = split_token_from_name("change_profile", args, &token);
+	name = split_token_from_name("change_profile", args, &cookie);
 	if (IS_ERR(name))
 		return PTR_ERR(name);
 
-	return aa_change_profile(name, token);
+	return aa_change_profile(name, cookie);
 }
 
 int aa_setprocattr_setprofile(struct task_struct *task, char *args)
