---
 security/apparmor/apparmor.h         |    9 -
 security/apparmor/inline.h           |   38 ++---
 security/apparmor/list.c             |   25 +++
 security/apparmor/main.c             |  240 +++++++----------------------------
 security/apparmor/module_interface.c |   86 +-----------
 security/apparmor/procattr.c         |   26 +--
 6 files changed, 111 insertions(+), 313 deletions(-)

--- a/security/apparmor/apparmor.h
+++ b/security/apparmor/apparmor.h
@@ -77,13 +77,10 @@ extern unsigned int apparmor_path_max;
 #define AA_ERROR(fmt, args...)	printk(KERN_ERR "AppArmor: " fmt, ##args)
 
 /* struct aa_profile - basic confinement data
- * @parent: non refcounted pointer to parent profile
  * @name: the profiles name
  * @file_rules: dfa containing the profiles file rules
  * @list: list this profile is on
- * @sub: profiles list of subprofiles (HATS)
  * @flags: flags controlling profile behavior
- * @null_profile: if needed per profile learning and null confinement profile
  * @isstale: flag indicating if profile is stale
  * @capabilities: capabilities granted by the process
  * @count: reference count of the profile
@@ -100,16 +97,13 @@ extern unsigned int apparmor_path_max;
  * way.
  */
 struct aa_profile {
-	struct aa_profile *parent;
 	char *name;
 	struct aa_dfa *file_rules;
 	struct list_head list;
-	struct list_head sub;
 	struct {
 		int complain;
 		int audit;
 	} flags;
-	struct aa_profile *null_profile;
 	int isstale;
 
 	kernel_cap_t capabilities;
@@ -224,6 +218,9 @@ extern int aa_change_hat(const char *id,
 extern int aa_change_profile(const char *name, u64 token);
 extern struct aa_profile *__aa_find_profile(const char *name,
 					    struct list_head *list);
+extern struct aa_profile *__aa_find_profile2(const char *name,
+					     const char *name2,
+					     struct list_head *list);
 extern struct aa_profile *__aa_replace_profile(struct task_struct *task,
 					       struct aa_profile *profile);
 extern struct aa_task_context *lock_task_and_profiles(struct task_struct *task,
--- a/security/apparmor/inline.h
+++ b/security/apparmor/inline.h
@@ -29,7 +29,7 @@ static inline struct aa_task_context *aa
 static inline struct aa_profile *aa_dup_profile(struct aa_profile *p)
 {
 	if (p)
-		kref_get(&(p->parent->count));
+		kref_get(&(p->count));
 
 	return p;
 }
@@ -41,7 +41,7 @@ static inline struct aa_profile *aa_dup_
 static inline void aa_put_profile(struct aa_profile *p)
 {
 	if (p)
-		kref_put(&p->parent->count, free_aa_profile_kref);
+		kref_put(&p->count, free_aa_profile_kref);
 }
 
 static inline struct aa_profile *aa_get_profile(struct task_struct *task)
@@ -71,6 +71,19 @@ static inline struct aa_profile *aa_find
 	return profile;
 }
 
+static inline struct aa_profile *aa_find_profile2(const char *name,
+						  const char *name2)
+{
+	struct aa_profile *profile = NULL;
+
+	read_lock(&profile_list_lock);
+	profile = aa_dup_profile(__aa_find_profile2(name, name2,
+						    &profile_list));
+	read_unlock(&profile_list_lock);
+
+	return profile;
+}
+
 static inline struct aa_task_context *aa_alloc_task_context(gfp_t flags)
 {
 	struct aa_task_context *cxt;
@@ -88,6 +101,7 @@ static inline void aa_free_task_context(
 {
 	if (cxt) {
 		aa_put_profile(cxt->profile);
+		aa_put_profile(cxt->token_profile);
 		kfree(cxt);
 	}
 }
@@ -102,10 +116,6 @@ static inline void aa_free_task_context(
 static inline void lock_profile_nested(struct aa_profile *profile,
 				       enum aa_lock_class lock_class)
 {
-	/* We always lock top-level profiles instead of children. */
-	if (profile)
-		profile = profile->parent;
-
 	/*
 	 * Lock the profile.
 	 *
@@ -128,10 +138,6 @@ static inline void lock_profile(struct a
  */
 static inline void unlock_profile(struct aa_profile *profile)
 {
-	/* We always lock top-level profiles instead of children. */
-	if (profile)
-		profile = profile->parent;
-
 	/* Unlock the profile. */
 	if (profile)
 		spin_unlock_irqrestore(&profile->lock, profile->int_flags);
@@ -150,12 +156,6 @@ static inline void unlock_profile(struct
 static inline void lock_both_profiles(struct aa_profile *profile1,
 				      struct aa_profile *profile2)
 {
-	/* We always lock top-level profiles instead of children. */
-	if (profile1)
-		profile1 = profile1->parent;
-	if (profile2)
-		profile2 = profile2->parent;
-
 	/*
 	 * Lock the two profiles.
 	 *
@@ -199,12 +199,6 @@ static inline void lock_both_profiles(st
 static inline void unlock_both_profiles(struct aa_profile *profile1,
 				        struct aa_profile *profile2)
 {
-	/* We always lock top-level profiles instead of children. */
-	if (profile1)
-		profile1 = profile1->parent;
-	if (profile2)
-		profile2 = profile2->parent;
-
 	/* Unlock the two profiles. */
 	if (!profile1 || profile1 == profile2) {
 		if (profile2)
--- a/security/apparmor/list.c
+++ b/security/apparmor/list.c
@@ -38,6 +38,31 @@ struct aa_profile *__aa_find_profile(con
 }
 
 /**
+ * __aa_find_profile2  -  look up a profile using a name split with //
+ * @name: name before //
+ * @name2: name after //
+ * @head: list to search
+ *
+ * Returns a pointer to the profile on the list, or NULL if no profile
+ * called @name exists. The caller must hold the profile_list_lock.
+ */
+struct aa_profile *__aa_find_profile2(const char *name, const char *name2,
+				      struct list_head *head)
+{
+	struct aa_profile *profile;
+	int len = strlen(name);
+
+	list_for_each_entry(profile, head, list) {
+		if (!strncmp(profile->name, name, len) &&
+		    !strncmp(profile->name + len, "//", 2) &&
+		    !strcmp(profile->name + len + 2, name2))
+			return profile;
+	}
+
+	return NULL;
+}
+
+/**
  * aa_profilelist_release - Remove all profiles from profile_list
  */
 void aa_profilelist_release(void)
--- a/security/apparmor/main.c
+++ b/security/apparmor/main.c
@@ -205,42 +205,6 @@ static int aa_perm_dentry(struct aa_prof
 }
 
 /**
- * attach_nullprofile - allocate and attach a null_profile hat to profile
- * @profile: profile to attach a null_profile hat to.
- *
- * Return %0 (success) or error (-%ENOMEM)
- */
-int attach_nullprofile(struct aa_profile *profile)
-{
-	struct aa_profile *hat = NULL;
-	char *hatname = NULL;
-
-	hat = alloc_aa_profile();
-	if (!hat)
-		goto fail;
-	if (profile->flags.complain)
-		hatname = kstrdup("null-complain-profile", GFP_KERNEL);
-	else
-		hatname = kstrdup("null-profile", GFP_KERNEL);
-	if (!hatname)
-		goto fail;
-
-	hat->flags.complain = profile->flags.complain;
-	hat->name = hatname;
-	hat->parent = profile;
-
-	profile->null_profile = hat;
-
-	return 0;
-
-fail:
-	kfree(hatname);
-	free_aa_profile(hat);
-
-	return -ENOMEM;
-}
-
-/**
  * alloc_null_complain_profile - Allocate the global null_complain_profile.
  *
  * Return %0 (success) or error (-%ENOMEM)
@@ -258,8 +222,6 @@ int alloc_null_complain_profile(void)
 		goto fail;
 
 	null_complain_profile->flags.complain = 1;
-	if (attach_nullprofile(null_complain_profile))
-		goto fail;
 
 	return 0;
 
@@ -361,14 +323,14 @@ static int aa_audit_base(struct aa_profi
 		audit_log_untrustedstring(ab, sa->name2);
 	}
 
-	if (sa->magic_token)
-		audit_log_format(ab, " magic_token=%llu", sa->magic_token);
+	if (sa->token)
+		audit_log_format(ab, " token=%llu", sa->token);
 
 	audit_log_format(ab, " pid=%d", current->pid);
 
 	if (profile) {
 		audit_log_format(ab, " profile=");
-		audit_log_untrustedstring(ab, profile->parent->name);
+		audit_log_untrustedstring(ab, profile->name);
 	}
 
 	audit_log_end(ab);
@@ -857,7 +819,7 @@ repeat:
 	if (IS_ERR(new_profile))
 		goto cleanup;
 
-	old_profile = __aa_replace_profile(current, new_profile, 0);
+	old_profile = __aa_replace_profile(current, new_profile);
 	if (IS_ERR(old_profile)) {
 		aa_put_profile(new_profile);
 		aa_put_profile(profile);
@@ -953,10 +915,11 @@ repeat:
 }
 
 static int do_change_profile(struct task_struct *task, const char *name,
-			     u64 token, struct aa_audit *sa)
+			     const char *hat, u64 token, struct aa_audit *sa)
 {
-	struct aa_profile *profile = NULL, *token_profile = NULL;
-	struct aa_task_context *new_cxt, *cxt;
+	struct aa_profile *profile = NULL, *token_profile = NULL,
+		*name_profile = NULL;
+	struct aa_task_context *new_cxt, *cxt, *old_cxt = NULL;
 	int error = 0;
 
 	new_cxt = aa_alloc_task_context(GFP_KERNEL);
@@ -964,21 +927,38 @@ static int do_change_profile(struct task
 		return -ENOMEM;
 
 repeat:
-	profile = aa_find_profile(name);
-	if (!profile)
-		/* if we name_profile is set then returning
-		 * and return profile has been removed, so go
-		 * unconfined.
-		 */
-		profile = aa_dup_profile(null_complain_profile);
-
+	if (name) {
+		if (hat)
+			profile = aa_find_profile2(name, hat);
+		else
+			profile = aa_find_profile(name);
+		if (!profile)
+		    /* if we name_profile is set then returning
+		     * and return profile has been removed, so go
+		     * unconfined.
+		     */
+		    profile = aa_dup_profile(null_complain_profile);
+	}
 	cxt = lock_task_and_profiles(task, profile);
 	if (!cxt) {
 		error = -EPERM;
 		goto out;
 	}
 
-	if (unlikely(profile->isstale)) {
+	if (!name || (hat && old_cxt && old_cxt != cxt)) {
+		/* need to find the change_hat name */
+		aa_put_profile(name_profile);
+		if (cxt->token_profile)
+			name_profile = aa_dup_profile(cxt->token_profile);
+		else
+			name_profile = aa_dup_profile(cxt->profile);
+		name = name_profile->name;
+		unlock_task_and_profiles(task, cxt, profile);
+		aa_put_profile(profile);
+		goto repeat;
+	}
+
+	if (unlikely(profile && profile->isstale)) {
 		unlock_task_and_profiles(task, cxt, profile);
 		aa_put_profile(profile);
 		goto repeat;
@@ -1022,6 +1002,7 @@ out:
 		aa_free_task_context(new_cxt);
 	unlock_task_and_profiles(task, cxt, profile);
 	aa_put_profile(profile);
+	aa_put_profile(name_profile);
 	return error;
 }
 
@@ -1126,7 +1107,7 @@ int aa_change_profile(const char *name, 
 			return -EACCES;
 		}
 
-		error = do_change_profile(current, name, token, &sa);
+		error = do_change_profile(current, name, NULL, token, &sa);
 	} else {
 		error = do_restore_profile(current, token, &sa);
 	}
@@ -1135,159 +1116,36 @@ int aa_change_profile(const char *name, 
 	return error;
 }
 
-
-/**
- * do_change_hat - actually switch hats
- * @hat_name: name of hat to switch to
- * @new_cxt: new aa_task_context to use on profile change
- * @hat_magic: new magic value to use
- *
- * Switch to a new hat.  Returns %0 on success, error otherwise.
- */
-static int do_change_hat(const char *hat_name, struct aa_task_context *new_cxt,
-			 u64 hat_magic, struct aa_audit *sa)
-{
-	struct aa_task_context *cxt = aa_task_context(current);
-	struct aa_profile *sub;
-	int error = 0;
-
-	/*
-	 * Note: the profile and sub-profiles cannot go away under us here;
-	 * no need to grab an additional reference count.
-	 */
-	sub = __aa_find_profile(hat_name, &cxt->profile->parent->sub);
-
-	if ((current->ptrace & PT_PTRACED) && aa_may_ptrace(cxt, sub))
-		return -EACCES;
-
-	if (sub) {
-		/* change hat */
-		aa_change_task_context(current, new_cxt, sub, hat_magic);
-	} else {
-		struct aa_profile *profile = cxt->profile;
-
-		if (APPARMOR_COMPLAIN(cxt)) {
-			sa->info = "unknown hat";
-			aa_audit_hint(profile, sa);
-		} else {
-			AA_DEBUG("%s: Unknown hatname '%s'. "
-				"Changing to NULL profile "
-				"(%d profile %s active %s)\n",
-				 __FUNCTION__,
-				 hat_name,
-				 current->pid,
-				 profile->parent->name,
-				 profile->name);
-			error = -EACCES;
-		}
-		/*
-		 * Switch to the NULL profile: it grants no accesses, so in
-		 * learning mode all accesses will get logged, and in enforce
-		 * mode all accesses will be denied.
-		 *
-		 * In learning mode, this allows us to learn about new hats.
-		 */
-		aa_change_task_context(current, new_cxt,
-				       cxt->profile->null_profile, hat_magic);
-	}
-
-	return error;
-}
-
 /**
  * aa_change_hat - change hat to/from subprofile
  * @hat_name: hat to change to
- * @hat_magic: magic cookie to validate the hat change
+ * @token: token to validate the hat change
  *
  * Change to new @hat_name, and store the @hat_magic in the current task
- * context.  If the new @hat_name is %NULL and the @hat_magic matches that
+ * context.  If the new @hat_name is %NULL and the @token matches that
  * stored in the current task context and is not 0, return to the top level
  * profile.
  * Returns %0 on success, error otherwise.
  */
-int aa_change_hat(const char *hat_name, u64 hat_magic)
+int aa_change_hat(const char *hat_name, u64 token)
 {
-	struct aa_task_context *cxt, *new_cxt;
-	struct aa_profile *profile = NULL;
 	struct aa_audit sa;
 	int error = 0;
 
 	memset(&sa, 0, sizeof(sa));
 	sa.gfp_mask = GFP_ATOMIC;
-	sa.magic_token = hat_magic;
+	sa.token = token;
 	sa.name = hat_name;
+	sa.operation = "change_hat";
 
-	new_cxt = aa_alloc_task_context(GFP_KERNEL);
-	if (!new_cxt)
-		return -ENOMEM;
-
-	cxt = lock_task_and_profiles(current, NULL);
-	if (!cxt) {
-		/* An unconfined process cannot change_hat(). */
-		if (APPARMOR_AUDIT(cxt))
-			aa_audit_message(NULL, &sa, AUDIT_APPARMOR_AUDIT);
-		error = -EPERM;
-		goto out;
-	}
-
-	/* No need to get reference count: we do not sleep. */
-	profile = cxt->profile;
-
-	if (APPARMOR_AUDIT(cxt))
-		aa_audit_message(profile, &sa, AUDIT_APPARMOR_AUDIT);
-
-	/* check to see if the confined process has any hats. */
-	if (list_empty(&profile->parent->sub) && !PROFILE_COMPLAIN(profile)) {
-		error = -ECHILD;
-		goto out;
-	}
-
-	if (profile == profile->parent) {
-		/* We are in the parent profile. */
-		if (hat_name) {
-			AA_DEBUG("%s: switching to %s, 0x%llx\n",
-				 __FUNCTION__,
-				 hat_name,
-				 hat_magic);
-			error = do_change_hat(hat_name, new_cxt, hat_magic,
-					      &sa);
-		}
-	} else {
-		/*
-		 * We are in a child profile.
-		 *
-		 * Check to make sure magic is same as what was passed when
-		 * we switched into this profile.  Handle special casing of
-		 * NULL magic which confines task to subprofile and prohibits
-		 * further change_hats.
-		 */
-		if (hat_magic && hat_magic == cxt->hat_magic) {
-			if (!hat_name) {
-				/* Return from subprofile back to parent. */
-				aa_change_task_context(current, new_cxt,
-						       profile->parent, 0);
-			} else {
-				/*
-				 * Change to another (sibling) profile, and
-				 * stick with the same hat_magic.
-				 */
-				error = do_change_hat(hat_name, new_cxt,
-						      cxt->hat_magic, &sa);
-			}
-		} else if (cxt->hat_magic) {
-		} else {	/* cxt->hat_magic == 0 */
-			sa.info = "killing process confined to current hat";
-			aa_audit_status(profile, &sa);
-			/* terminate current process */
-			(void)send_sig_info(SIGKILL, NULL, current);
-		}
-
-	}
+	/* FIXME: there is currently no way to tell if a profile doesn't have
+	 * hats so that we can return -ECHILD
+	 */
+	if (hat_name)
+		error = do_change_profile(current, NULL, hat_name, token, &sa);
+	else
+		error = do_restore_profile(current, token, &sa);
 
-out:
-	if (aa_task_context(current) != new_cxt)
-		aa_free_task_context(new_cxt);
-	unlock_task_and_profiles(current, cxt, NULL);
 	return error;
 }
 
@@ -1420,7 +1278,7 @@ void aa_change_task_context(struct task_
 		new_cxt->task = task;
 		new_cxt->profile = aa_dup_profile(profile);
 		new_cxt->token_profile = aa_dup_profile(token_profile);
-		list_move(&new_cxt->list, &profile->parent->task_contexts);
+		list_move(&new_cxt->list, &profile->task_contexts);
 	}
 	rcu_assign_pointer(task->security, new_cxt);
 }
--- a/security/apparmor/module_interface.c
+++ b/security/apparmor/module_interface.c
@@ -241,10 +241,9 @@ struct aa_dfa *aa_unpack_dfa(struct aa_e
 /**
  * aa_unpack_profile - unpack a serialized profile
  * @e: serialized data extent information
- * @depth: recursion depth of unpack
  * @operation: operation profile is being unpacked for
  */
-static struct aa_profile *aa_unpack_profile(struct aa_ext *e, int depth,
+static struct aa_profile *aa_unpack_profile(struct aa_ext *e,
 					    const char *operation)
 {
 	struct aa_profile *profile = NULL;
@@ -285,22 +284,6 @@ static struct aa_profile *aa_unpack_prof
 		goto fail;
 	}
 
-	/* get optional subprofiles */
-	if (aa_is_nameX(e, AA_LIST, "hats")) {
-		if (depth > 0)
-			goto fail;
-		while (!aa_is_nameX(e, AA_LISTEND, NULL)) {
-			struct aa_profile *subprofile;
-			subprofile = aa_unpack_profile(e, depth + 1, operation);
-			if (IS_ERR(subprofile)) {
-				error = PTR_ERR(subprofile);
-				goto fail;
-			}
-			subprofile->parent = profile;
-			list_add(&subprofile->list, &profile->sub);
-		}
-	}
-
 	if (!aa_is_nameX(e, AA_STRUCTEND, NULL))
 		goto fail;
 
@@ -321,29 +304,6 @@ fail:
 }
 
 /**
- * aa_unpack_profile_wrapper - unpack a serialized base profile
- * @e: serialized data extent information
- *
- * check interface version unpack a profile and all its hats and patch
- * in any extra information that the profile needs.
- */
-static struct aa_profile *aa_unpack_profile_wrapper(struct aa_ext *e,
-						    const char *operation)
-{
-	struct aa_profile *profile = aa_unpack_profile(e, 0, operation);
-	if (!IS_ERR(profile) &&
-	    (!list_empty(&profile->sub) || profile->flags.complain)) {
-		int error;
-		if ((error = attach_nullprofile(profile))) {
-			aa_put_profile(profile);
-			return ERR_PTR(error);
-		}
-	}
-
-	return profile;
-}
-
-/**
  * aa_verify_head - unpack serialized stream header
  * @e: serialized data read head
  * @operation: operation header is being verified for
@@ -393,7 +353,7 @@ ssize_t aa_add_profile(void *data, size_
 	if (error)
 		return error;
 
-	profile = aa_unpack_profile_wrapper(&e, "profile_load");
+	profile = aa_unpack_profile(&e, "profile_load");
 	if (IS_ERR(profile))
 		return PTR_ERR(profile);
 
@@ -426,29 +386,13 @@ static inline void task_replace(struct t
 	struct aa_task_context *cxt = aa_task_context(task);
 
 	AA_DEBUG("%s: replacing profile for task %d "
-		 "profile=%s (%p) hat=%s (%p)\n",
+		 "profile=%s (%p)\n",
 		 __FUNCTION__,
 		 cxt->task->pid,
-		 cxt->profile->parent->name, cxt->profile->parent,
 		 cxt->profile->name, cxt->profile);
 
-	if (cxt->profile != cxt->profile->parent) {
-		struct aa_profile *hat;
-
-		/*
-		 * The old profile was in a hat, check to see if the new
-		 * profile has an equivalent hat.
-		 */
-		hat = __aa_find_profile(cxt->profile->name, &new_profile->sub);
-
-		if (!hat)
-			hat = aa_dup_profile(new_profile->null_profile);
-
-		aa_change_task_context(task, new_cxt, hat, cxt->hat_magic);
-		aa_put_profile(hat);
-	} else
-		aa_change_task_context(task, new_cxt, new_profile,
-				       cxt->hat_magic);
+	aa_change_task_context(task, new_cxt, new_profile, cxt->token,
+			       cxt->token_profile);
 }
 
 /**
@@ -473,7 +417,7 @@ ssize_t aa_replace_profile(void *udata, 
 	if (error)
 		return error;
 
-	new_profile = aa_unpack_profile_wrapper(&e, "profile_replace");
+	new_profile = aa_unpack_profile(&e, "profile_replace");
 	if (IS_ERR(new_profile))
 		return PTR_ERR(new_profile);
 
@@ -582,9 +526,7 @@ struct aa_profile *alloc_aa_profile(void
 	profile = kzalloc(sizeof(*profile), GFP_KERNEL);
 	AA_DEBUG("%s(%p)\n", __FUNCTION__, profile);
 	if (profile) {
-		profile->parent = profile;
 		INIT_LIST_HEAD(&profile->list);
-		INIT_LIST_HEAD(&profile->sub);
 		kref_init(&profile->count);
 		INIT_LIST_HEAD(&profile->task_contexts);
 		spin_lock_init(&profile->lock);
@@ -604,8 +546,6 @@ struct aa_profile *alloc_aa_profile(void
  */
 void free_aa_profile(struct aa_profile *profile)
 {
-	struct aa_profile *p, *ptmp;
-
 	AA_DEBUG("%s(%p)\n", __FUNCTION__, profile);
 
 	if (!profile)
@@ -622,18 +562,6 @@ void free_aa_profile(struct aa_profile *
 
 	aa_match_free(profile->file_rules);
 
-	/*
-	 * Use free_aa_profile instead of aa_put_profile to destroy the
-	 * null_profile, because the null_profile use the same reference
-	 * counting as hats, ie. the count goes to the base profile.
-	 */
-	free_aa_profile(profile->null_profile);
-	list_for_each_entry_safe(p, ptmp, &profile->sub, list) {
-		list_del_init(&p->list);
-		p->parent = p;
-		aa_put_profile(p);
-	}
-
 	if (profile->name) {
 		AA_DEBUG("%s: %s\n", __FUNCTION__, profile->name);
 		kfree(profile->name);
@@ -655,7 +583,7 @@ void aa_unconfine_tasks(struct aa_profil
 			list_entry(profile->task_contexts.next,
 				   struct aa_task_context, list)->task;
 		task_lock(task);
-		aa_change_task_context(task, NULL, NULL, 0);
+		aa_change_task_context(task, NULL, NULL, 0, NULL);
 		task_unlock(task);
 	}
 }
--- a/security/apparmor/procattr.c
+++ b/security/apparmor/procattr.c
@@ -19,24 +19,20 @@ int aa_getprocattr(struct aa_profile *pr
 	if (profile) {
 		const char *mode_str = PROFILE_COMPLAIN(profile) ?
 			" (complain)" : " (enforce)";
+		int mode_len, name_len;
 
-		*len = ((profile != profile->parent) ?
-		           strlen(profile->parent->name) + 1 : 0) +
-		       strlen(mode_str) + strlen(profile->name) + 1;
+		mode_len = strlen(mode_str);
+		name_len = strlen(profile->name);
+		*len = mode_len + name_len + 1;
 		str = kmalloc(*len, GFP_ATOMIC);
 		if (!str)
 			return -ENOMEM;
+		/* FIXME: do we want to report ^ instead of // for hatnames */
 
-		if (profile != profile->parent) {
-			memcpy(str, profile->parent->name,
-			       strlen(profile->parent->name));
-			str += strlen(profile->parent->name);
-			*str++ = '^';
-		}
-		memcpy(str, profile->name, strlen(profile->name));
-		str += strlen(profile->name);
-		memcpy(str, mode_str, strlen(mode_str));
-		str += strlen(mode_str);
+		memcpy(str, profile->name, name_len);
+		str += name_len;
+		memcpy(str, mode_str, mode_len);
+		str += mode_len;
 		*str++ = '\n';
 		str -= *len;
 	} else {
@@ -140,13 +136,13 @@ repeat:
 
 	if (new_profile) {
 		sa.name = args;
-		sa.name2 = old_profile ? old_profile->parent->name :
+		sa.name2 = old_profile ? old_profile->name :
 			"unconfined";
 		aa_audit_status(NULL, &sa);
 	} else {
 		if (old_profile) {
 			sa.name = "unconfined";
-			sa.name2 = old_profile->parent->name;
+			sa.name2 = old_profile->name;
 			aa_audit_status(NULL, &sa);
 		} else {
 			sa.info = "task is unconfined";
