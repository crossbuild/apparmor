---
 fs/namei.c                   |    6 ++++++
 security/apparmor/apparmor.h |    7 +++----
 security/apparmor/lsm.c      |   17 ++++++++---------
 security/apparmor/main.c     |   14 +-------------
 4 files changed, 18 insertions(+), 26 deletions(-)

Index: b/fs/namei.c
===================================================================
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -1428,6 +1428,10 @@ static int may_delete(struct inode *dir,
 	BUG_ON(victim->d_parent->d_inode != dir);
 	audit_inode_child(victim->d_name.name, victim->d_inode, dir);
 
+#if 0
+	if (nd)
+		nd->flags |= LOOKUP_CONTINUE;
+#endif
 	error = permission(dir,MAY_WRITE | MAY_EXEC, NULL);
 	if (error)
 		return error;
@@ -1465,6 +1469,8 @@ static inline int may_create(struct inod
 		return -EEXIST;
 	if (IS_DEADDIR(dir))
 		return -ENOENT;
+	if (nd)
+		nd->flags |= LOOKUP_CONTINUE;
 	return permission(dir,MAY_WRITE | MAY_EXEC, nd);
 }
 
Index: b/security/apparmor/apparmor.h
===================================================================
--- a/security/apparmor/apparmor.h
+++ b/security/apparmor/apparmor.h
@@ -181,10 +181,9 @@ struct aa_audit {
 					   non permission errors  */
 
 /* Flags for the permission check functions */
-#define AA_CHECK_LEAF	1  /* this is the leaf lookup component */
-#define AA_CHECK_FD	2  /* coming from a file descriptor */
-#define AA_CHECK_DIR	4  /* file type is directory */
-#define AA_CHECK_MANGLE	8  /* leave extra room for name mangling */
+#define AA_CHECK_FD	1  /* coming from a file descriptor */
+#define AA_CHECK_DIR	2  /* file type is directory */
+#define AA_CHECK_MANGLE	4  /* leave extra room for name mangling */
 
 /* main.c */
 extern int alloc_null_complain_profile(void);
Index: b/security/apparmor/lsm.c
===================================================================
--- a/security/apparmor/lsm.c
+++ b/security/apparmor/lsm.c
@@ -291,7 +291,7 @@ static int aa_permission(struct inode *i
 static int apparmor_inode_create(struct inode *dir, struct dentry *dentry,
 				 struct vfsmount *mnt, int mask)
 {
-	return aa_permission(dir, dentry, mnt, MAY_WRITE, AA_CHECK_LEAF);
+	return aa_permission(dir, dentry, mnt, MAY_WRITE, 0);
 }
 
 static int apparmor_inode_link(struct dentry *old_dentry,
@@ -320,7 +320,7 @@ out:
 static int apparmor_inode_unlink(struct inode *dir, struct dentry *dentry,
 				 struct vfsmount *mnt)
 {
-	int check = AA_CHECK_LEAF;
+	int check = 0;
 
 	if (S_ISDIR(dentry->d_inode->i_mode))
 		check |= AA_CHECK_DIR;
@@ -330,13 +330,13 @@ static int apparmor_inode_unlink(struct 
 static int apparmor_inode_symlink(struct inode *dir, struct dentry *dentry,
 				  struct vfsmount *mnt, const char *old_name)
 {
-	return aa_permission(dir, dentry, mnt, MAY_WRITE, AA_CHECK_LEAF);
+	return aa_permission(dir, dentry, mnt, MAY_WRITE, 0);
 }
 
 static int apparmor_inode_mknod(struct inode *dir, struct dentry *dentry,
 				struct vfsmount *mnt, int mode, dev_t dev)
 {
-	return aa_permission(dir, dentry, mnt, MAY_WRITE, AA_CHECK_LEAF);
+	return aa_permission(dir, dentry, mnt, MAY_WRITE, 0);
 }
 
 static int apparmor_inode_rename(struct inode *old_dir,
@@ -356,7 +356,7 @@ static int apparmor_inode_rename(struct 
 
 	if (profile) {
 		struct inode *inode = old_dentry->d_inode;
-		int check = AA_CHECK_LEAF;
+		int check = 0;
 
 		if (inode && S_ISDIR(inode->i_mode))
 			check |= AA_CHECK_DIR;
@@ -381,13 +381,12 @@ static int apparmor_inode_permission(str
 {
 	int check = 0;
 
-	if (!nd)
+	if (!nd || nd->flags & (LOOKUP_PARENT | LOOKUP_CONTINUE))
 		return 0;
 	if (S_ISDIR(inode->i_mode))
 		check |= AA_CHECK_DIR;
 	mask &= (MAY_READ | MAY_WRITE | MAY_EXEC);
 
-	/* Assume we are not checking a leaf directory. */
 	return aa_permission(inode, nd->dentry, nd->mnt, mask, check);
 }
 
@@ -481,7 +480,7 @@ static int apparmor_file_permission(stru
 		struct dentry *dentry = file->f_dentry;
 		struct vfsmount *mnt = file->f_vfsmnt;
 		struct inode *inode = dentry->d_inode;
-		int check = AA_CHECK_LEAF | AA_CHECK_FD;
+		int check = AA_CHECK_FD;
 
 		/*
 		 * FIXME: We should remember which profiles we revalidated
@@ -536,7 +535,7 @@ static inline int aa_mmap(struct file *f
 
 	dentry = file->f_dentry;
 	return aa_permission(dentry->d_inode, dentry, file->f_vfsmnt, mask,
-			     AA_CHECK_LEAF | AA_CHECK_FD);
+			     AA_CHECK_FD);
 }
 
 static int apparmor_file_mmap(struct file *file, unsigned long reqprot,
Index: b/security/apparmor/main.c
===================================================================
--- a/security/apparmor/main.c
+++ b/security/apparmor/main.c
@@ -656,17 +656,6 @@ int aa_perm(struct aa_profile *profile, 
 	struct aa_audit sa;
 	int error = 0;
 
-	if ((check & (AA_CHECK_DIR | AA_CHECK_LEAF)) == AA_CHECK_DIR) {
-		/*
-		 * If checking a non-leaf directory, allow traverse and
-		 * write access: we do not require profile access to
-		 * non-leaf directories in order to traverse them,
-		 * create or remove files in them. We do require
-		 * MAY_WRITE profile access on the actual file or
-		 * directory being created or removed, though.
-		 */
-		mask &= ~(MAY_EXEC | MAY_WRITE);
-	}
 	if (mask == 0)
 		goto out;
 
@@ -702,8 +691,7 @@ int aa_perm_dir(struct aa_profile *profi
 	sa.flags = 0;
 	sa.gfp_mask = GFP_KERNEL;
 
-	return aa_perm_dentry(profile, dentry, mnt, &sa, mask,
-			      AA_CHECK_DIR | AA_CHECK_LEAF);
+	return aa_perm_dentry(profile, dentry, mnt, &sa, mask, AA_CHECK_DIR);
 }
 
 int aa_perm_path(struct aa_profile *profile, const char *name, int mask)
