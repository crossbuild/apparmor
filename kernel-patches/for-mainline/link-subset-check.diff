Index: linux-2.6-apparmor/security/apparmor/main.c
===================================================================
--- linux-2.6-apparmor.orig/security/apparmor/main.c
+++ linux-2.6-apparmor/security/apparmor/main.c
@@ -62,32 +62,6 @@ static inline int aa_taskattr_access(con
 	return strcmp(end, "/attr/current") == 0;
 }
 
-/**
- * aa_file_mode - get full mode for file entry from profile
- * @profile: profile
- * @name: filename
- */
-static inline int aa_file_mode(struct aa_profile *profile, const char *name)
-{
-	int perms = 0;
-
-	AA_DEBUG("%s: %s\n", __FUNCTION__, name);
-	if (!name) {
-		AA_DEBUG("%s: no name\n", __FUNCTION__);
-		goto out;
-	}
-
-	if (!profile) {
-		AA_DEBUG("%s: no profile\n", __FUNCTION__);
-		goto out;
-	}
-
-	perms = aa_match(profile->file_rules, name);
-
-out:
-	return perms;
-}
-
 static inline void aa_permerror2result(int perm_result, struct aa_audit *sa)
 {
 	if (perm_result == 0) {	/* success */
@@ -132,27 +106,35 @@ static int aa_file_denied(struct aa_prof
  * @link: name of link being created
  * @target: name of target to be linked to
  *
- * Return %0 on success, or else the permissions in @mask that the
- * profile denies.
+ * Return %0 on success, or else the permissions that the profile denies.
  */
 static int aa_link_denied(struct aa_profile *profile, const char *link,
 			  const char *target)
 {
-	int l_mode, t_mode, ret = -EPERM;
-
-	l_mode = aa_file_mode(profile, link);
-	if (l_mode & AA_MAY_LINK) {
-		/* mask off link bit */
-		l_mode &= ~AA_MAY_LINK;
+	int l_mode, t_mode;
 
-		t_mode = aa_file_mode(profile, target);
-		t_mode &= ~AA_MAY_LINK;
+	l_mode = aa_match(profile->file_rules, link);
+	t_mode = aa_match(profile->file_rules, target);
 
-		if (l_mode == t_mode)
-			ret = 0;
-	}
+	/**
+	 * Link always requires 'l' on the link, a subset of the
+	 * target's 'r', 'w', 'x', and 'm' permissions on the link, and
+	 * if the link has 'x', an exact match of all flags except
+	 * 'r', 'w', 'x', 'm'.
+	 */
+#define RWXM (MAY_READ | MAY_WRITE | MAY_EXEC | AA_EXEC_MMAP)
+	if ((l_mode & AA_MAY_LINK) &&
+	    !(l_mode & ~t_mode & RWXM) &&
+	    (!(t_mode & MAY_EXEC) || (l_mode & ~RWXM) == (t_mode & ~RWXM)))
+		return 0;
+#undef RWXM
 
-	return ret;
+	/**
+	 * FIXME: There currenly is no way to report which permissions
+	 * we expect in t_mode, so linking could fail even after learning
+	 * the required l_mode.
+	 */
+	return 0;
 }
 
 static char *aa_get_name(struct dentry *dentry, struct vfsmount *mnt,
