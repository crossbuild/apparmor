Index: b/security/apparmor/main.c
===================================================================
--- a/security/apparmor/main.c
+++ b/security/apparmor/main.c
@@ -138,21 +138,31 @@ static int aa_file_denied(struct aa_prof
 static int aa_link_denied(struct aa_profile *profile, const char *link,
 			  const char *target)
 {
-	int l_mode, t_mode, ret = -EPERM;
+	int l_mode, t_mode;
 
 	l_mode = aa_file_mode(profile, link);
-	if (l_mode & AA_MAY_LINK) {
-		/* mask off link bit */
-		l_mode &= ~AA_MAY_LINK;
+	t_mode = aa_file_mode(profile, target);
 
-		t_mode = aa_file_mode(profile, target);
-		t_mode &= ~AA_MAY_LINK;
+	/**
+	 * If the process does not have the link permission for the link, or
+	 * the read, write, and execute permissions of the link are not a
+	 * subset of those of the target, or any of the remaining permissions
+	 * (which are all execute related) differ between the link and the
+	 * target, deny the access.
+	 *
+	 * FIXME: There currenly is no way to report which other permissions
+	 * the process would need to have in l_mode, or which permissions in
+	 * l_mode would have to be removed in order for the operation to
+	 * succeed.
+	 */
 
-		if (l_mode == t_mode)
-			ret = 0;
-	}
+	if (!(l_mode & AA_MAY_LINK) ||
+	    (~t_mode & l_mode & (MAY_READ | MAY_WRITE | MAY_EXEC)) ||
+	    ((l_mode & ~(MAY_READ | MAY_WRITE | MAY_EXEC | AA_MAY_LINK)) !=
+	     (t_mode & ~(MAY_READ | MAY_WRITE | MAY_EXEC | AA_MAY_LINK))))
+	        return AA_MAY_LINK;
 
-	return ret;
+	return 0;
 }
 
 static char *aa_get_name(struct dentry *dentry, struct vfsmount *mnt,
