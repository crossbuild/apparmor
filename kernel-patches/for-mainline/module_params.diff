---
 security/apparmor/apparmor.h   |    2 
 security/apparmor/apparmorfs.c |  249 +++++++----------------------------------
 security/apparmor/lsm.c        |   57 +++++++--
 3 files changed, 89 insertions(+), 219 deletions(-)

--- a/security/apparmor/apparmor.h
+++ b/security/apparmor/apparmor.h
@@ -40,7 +40,7 @@ extern int apparmor_complain;
 extern int apparmor_debug;
 extern int apparmor_audit;
 extern int apparmor_logsyscall;
-extern int apparmor_path_max;
+extern unsigned int apparmor_path_max;
 
 #define PROFILE_COMPLAIN(_profile) \
 	(apparmor_complain == 1 || ((_profile) && (_profile)->flags.complain))
--- a/security/apparmor/apparmorfs.c
+++ b/security/apparmor/apparmorfs.c
@@ -172,230 +172,67 @@ static struct file_operations apparmorfs
 	.write = aa_profile_remove
 };
 
-/* apparmor/control/ */
-static u64 aa_control_get(void *data)
-{
-	return *(int *)data;
-}
-
-static void aa_control_set(void *data, u64 val)
-{
-	if (val > 1)
-		val = 1;
-
-	*(int*)data = (int)val;
-}
-
-DEFINE_SIMPLE_ATTRIBUTE(apparmorfs_control_fops, aa_control_get,
-			aa_control_set, "%lld\n");
-
-static struct root_entry {
-	const char *name;
-	int mode;
-	int access;
-	struct file_operations *fops;
-	void *data;
-
-	/* internal fields */
-	struct dentry *dentry;
-	int parent_index;
-} root_entries[] = {
-	/* our root, normally /sys/kernel/security/apparmor */
-	{"apparmor", 	S_IFDIR, 0555},	/* DO NOT EDIT/MOVE */
-
-	/* interface for obtaining list of profiles currently loaded */
-	{"profiles", 	S_IFREG, 0440, &apparmorfs_profiles_fops,
-				       NULL},
-
-	/* interface for obtaining matching features supported */
-	{"matching",  	S_IFREG, 0444, &apparmorfs_matching_fops,
-				       NULL},
-
-	/* interface for loading/removing/replacing profiles */
-	{".load",    	S_IFREG, 0640, &apparmorfs_profile_load,
-				       NULL},
-	{".replace", 	S_IFREG, 0640, &apparmorfs_profile_replace,
-				       NULL},
-	{".remove",  	S_IFREG, 0640, &apparmorfs_profile_remove,
-				       NULL},
-
-	/* interface for setting binary config values */
-	{"control",  	S_IFDIR, 0550},
-	{"complain", 	S_IFREG, 0640, &apparmorfs_control_fops,
-				       &apparmor_complain},
-	{"audit",    	S_IFREG, 0640, &apparmorfs_control_fops,
-				       &apparmor_audit},
-	{"debug",    	S_IFREG, 0640, &apparmorfs_control_fops,
-				       &apparmor_debug},
-	{"logsyscall", 	S_IFREG, 0640, &apparmorfs_control_fops,
-				       &apparmor_logsyscall},
-	{NULL,       	S_IFDIR, 0},
-
-	/* root end */
-	{NULL,       	S_IFDIR, 0}
-};
+#define NO_FS_ENTRIES 6
+static struct dentry *fs_entries[NO_FS_ENTRIES];
 
-static void clear_apparmorfs(void)
+void destroy_apparmorfs(void)
 {
 	unsigned int i;
 
-	for (i=0; i < ARRAY_SIZE(root_entries); i++) {
-		unsigned int index;
-
-		if (root_entries[i].mode == S_IFDIR) {
-			if (root_entries[i].name)
-				/* defer dir free till all sub-entries freed */
-				continue;
-			else
-				/* cleanup parent */
-				index = root_entries[i].parent_index;
-		} else
-			index = i;
-
-		if (root_entries[index].dentry) {
-			securityfs_remove(root_entries[index].dentry);
-
-			AA_DEBUG("%s: deleted apparmorfs entry name=%s "
-				 "dentry=%p\n",
-				__FUNCTION__,
-				root_entries[index].name,
-				root_entries[index].dentry);
-
-			root_entries[index].dentry = NULL;
-			root_entries[index].parent_index = 0;
-		}
+	for (i=NO_FS_ENTRIES-1; i >= 0; i--) {
+		if (!IS_ERR(fs_entries[i]))
+			securityfs_remove(fs_entries[i]);
+		fs_entries[i] = NULL;
 	}
 }
 
-static int populate_apparmorfs(void)
+int create_apparmorfs(void)
 {
-	unsigned int i, parent_index, depth;
-
-	for (i = 0; i < ARRAY_SIZE(root_entries); i++) {
-		root_entries[i].dentry = NULL;
-		root_entries[i].parent_index = 0;
-	}
+	int i, error = 0;
 
-	/* 1. Verify entry 0 is valid [sanity check] */
-	if (ARRAY_SIZE(root_entries) == 0 ||
-	    !root_entries[0].name ||
-	    strcmp(root_entries[0].name, "apparmor") != 0 ||
-	    root_entries[0].mode != S_IFDIR) {
-		AA_ERROR("%s: root entry 0 is not apparmor/dir\n",
+	if (fs_entries[0]) {
+		AA_ERROR("%s: AppArmor securityfs already exists\n",
 			__FUNCTION__);
-		goto error;
+		return -EEXIST;
 	}
 
-	/* 2. Build back pointers */
-	parent_index = 0;
-	depth = 1;
-
-	for (i = 1; i < ARRAY_SIZE(root_entries); i++) {
-		root_entries[i].parent_index = parent_index;
-
-		if (root_entries[i].name &&
-		    root_entries[i].mode == S_IFDIR) {
-			depth++;
-			parent_index = i;
-		} else if (!root_entries[i].name) {
-			if (root_entries[i].mode != S_IFDIR || depth == 0) {
-				AA_ERROR("%s: root_entry %d invalid (%u %d)",
-					 __FUNCTION__, i,
-					 root_entries[i].mode,
-					 root_entries[i].parent_index);
-				goto error;
-			}
-
-			depth--;
-			parent_index = root_entries[parent_index].parent_index;
-		}
-	}
-
-	if (depth != 0) {
-		AA_ERROR("%s: root_entry table not correctly terminated\n",
-			__FUNCTION__);
+	if (IS_ERR(fs_entries[0] = securityfs_create_dir("apparmor", NULL)))
+		goto error;
+	if (IS_ERR(fs_entries[1] = securityfs_create_file("profiles",
+						S_IFREG | 0440,
+						fs_entries[0], NULL,
+						&apparmorfs_profiles_fops)))
+		goto error;
+	if (IS_ERR(fs_entries[2] = securityfs_create_file("matching",
+						S_IFREG | 0444,
+						fs_entries[0], NULL,
+						&apparmorfs_matching_fops)))
+		goto error;
+	if (IS_ERR(fs_entries[3] = securityfs_create_file(".load",
+						S_IFREG | 0640,
+						fs_entries[0], NULL,
+						&apparmorfs_profile_load)))
+		goto error;
+	if (IS_ERR(fs_entries[4] = securityfs_create_file(".replace",
+						S_IFREG | 0640,
+						fs_entries[0], NULL,
+						&apparmorfs_profile_replace)))
+		goto error;
+	if (IS_ERR(fs_entries[5] = securityfs_create_file(".remove",
+						S_IFREG | 0640,
+						fs_entries[0], NULL,
+						&apparmorfs_profile_remove)))
 		goto error;
-	}
-
-	/* 3. Create root (parent=NULL) */
-	root_entries[0].dentry = securityfs_create_file(
-					root_entries[0].name,
-					root_entries[0].mode |
-						root_entries[0].access,
-					NULL, NULL, NULL);
-
-	if (IS_ERR(root_entries[0].dentry))
-		goto error;
-	else
-		AA_DEBUG("%s: created securityfs/apparmor [dentry=%p]\n",
-			__FUNCTION__, root_entries[0].dentry);
-
-
-	/* 4. create remaining nodes */
-	for (i = 1; i < ARRAY_SIZE(root_entries); i++) {
-		struct dentry *parent;
-		void *data = NULL;
-		struct file_operations *fops = NULL;
-
-		/* end of directory ? */
-		if (!root_entries[i].name)
-			continue;
-
-		parent = root_entries[root_entries[i].parent_index].dentry;
-
-		if (root_entries[i].mode != S_IFDIR) {
-			data = root_entries[i].data;
-			fops = root_entries[i].fops;
-		}
-
-		root_entries[i].dentry = securityfs_create_file(
-						root_entries[i].name,
-						root_entries[i].mode |
-							root_entries[i].access,
-						parent,
-						data,
-						fops);
-
-		if (IS_ERR(root_entries[i].dentry))
-			goto cleanup_error;
-
-		AA_DEBUG("%s: added apparmorfs entry "
-			 "name=%s mode=%x dentry=%p [parent %p]\n",
-			__FUNCTION__, root_entries[i].name,
-			root_entries[i].mode|root_entries[i].access,
-			root_entries[i].dentry, parent);
-	}
 
 	return 0;
 
-cleanup_error:
-	clear_apparmorfs();
-
 error:
-	return -EINVAL;
-}
-
-int create_apparmorfs(void)
-{
-	int error = 0;
-
-	if (root_entries[0].dentry) {
-		error = -EEXIST;
-		AA_ERROR("%s: AppArmor securityfs already exists\n",
-			__FUNCTION__);
-	} else {
-		error = populate_apparmorfs();
-		if (error != 0) {
-			AA_ERROR("%s: Error populating AppArmor securityfs\n",
-				__FUNCTION__);
-		}
+	destroy_apparmorfs();
+	AA_ERROR("Error creating AppArmor securityfs\n");
+	for (i=0; i < NO_FS_ENTRIES; i++) {
+		if (IS_ERR(fs_entries[i]))
+			return PTR_ERR(fs_entries[i]);
 	}
-
 	return error;
 }
 
-void destroy_apparmorfs(void)
-{
-	if (root_entries[0].dentry)
-		clear_apparmorfs();
-}
--- a/security/apparmor/lsm.c
+++ b/security/apparmor/lsm.c
@@ -20,41 +20,74 @@
 #include "apparmor.h"
 #include "inline.h"
 
-/* Flag values, also controllable via apparmorfs/control.
- * We explicitly do not allow these to be modifiable when exported via
- * /sys/modules/parameters, as we want to do additional mediation and
- * don't want to add special path code. */
-
-/* Complain mode -- in complain mode access failures result in auditing only
+static int param_set_aabool(const char *val, struct kernel_param *kp);
+static int param_get_aabool(char *buffer, struct kernel_param *kp);
+#define param_check_aabool(name, p) __param_check(name, p, int)
+
+static int param_set_aapathuint(const char *val, struct kernel_param *kp);
+static int param_get_aapathuint(char *buffer, struct kernel_param *kp);
+#define param_check_aapathuint(name, p) __param_check(name, p, int)
+
+/* Flag values, also controllable via /sys/module/apparmor/parameters
+ * We define special types as we want to do additional mediation.
+ *
+ * Complain mode -- in complain mode access failures result in auditing only
  * and task is allowed access.  audit events are processed by userspace to
  * generate policy.  Default is 'enforce' (0).
  * Value is also togglable per profile and referenced when global value is
  * enforce.
  */
 int apparmor_complain = 0;
-module_param_named(complain, apparmor_complain, int, S_IRUSR);
+module_param_named(complain, apparmor_complain, aabool, S_IRUSR | S_IWUSR);
 MODULE_PARM_DESC(apparmor_complain, "Toggle AppArmor complain mode");
 
 /* Debug mode */
 int apparmor_debug = 0;
-module_param_named(debug, apparmor_debug, int, S_IRUSR);
+module_param_named(debug, apparmor_debug, aabool, S_IRUSR | S_IWUSR);
 MODULE_PARM_DESC(apparmor_debug, "Toggle AppArmor debug mode");
 
 /* Audit mode */
 int apparmor_audit = 0;
-module_param_named(audit, apparmor_audit, int, S_IRUSR);
+module_param_named(audit, apparmor_audit, aabool, S_IRUSR | S_IWUSR);
 MODULE_PARM_DESC(apparmor_audit, "Toggle AppArmor audit mode");
 
 /* Syscall logging mode */
 int apparmor_logsyscall = 0;
-module_param_named(logsyscall, apparmor_logsyscall, int, S_IRUSR);
+module_param_named(logsyscall, apparmor_logsyscall, aabool, S_IRUSR | S_IWUSR);
 MODULE_PARM_DESC(apparmor_logsyscall, "Toggle AppArmor logsyscall mode");
 
 /* Maximum pathname length before accesses will start getting rejected */
-int apparmor_path_max = 2 * PATH_MAX;
-module_param_named(path_max, apparmor_path_max, int, S_IRUSR);
+unsigned int apparmor_path_max = 2 * PATH_MAX;
+module_param_named(path_max, apparmor_path_max, aapathuint, S_IRUSR | S_IWUSR);
 MODULE_PARM_DESC(apparmor_path_max, "Maximum pathname length allowed");
 
+static int param_set_aabool(const char *val, struct kernel_param *kp)
+{
+	if (aa_task_context(current))
+		return -EPERM;
+	return param_set_bool(val, kp);
+}
+
+static int param_get_aabool(char *buffer, struct kernel_param *kp)
+{
+	if (aa_task_context(current))
+		return -EPERM;
+	return param_get_bool(buffer, kp);
+}
+
+static int param_set_aapathuint(const char *val, struct kernel_param *kp)
+{
+	if (aa_task_context(current))
+		return -EPERM;
+	return param_set_uint(val, kp);
+}
+
+static int param_get_aapathuint(char *buffer, struct kernel_param *kp)
+{
+	if (aa_task_context(current))
+		return -EPERM;
+	return param_get_int(buffer, kp);
+}
 
 static int aa_reject_syscall(struct task_struct *task, gfp_t flags,
 			     const char *name)
