---
 security/apparmor/apparmor.h         |    2 
 security/apparmor/module_interface.c |  177 +++++++++++++++++++++++------------
 2 files changed, 122 insertions(+), 57 deletions(-)

--- a/security/apparmor/apparmor.h
+++ b/security/apparmor/apparmor.h
@@ -83,6 +83,7 @@ extern unsigned int apparmor_path_max;
  * @flags: flags controlling profile behavior
  * @null_profile: if needed per profile learning and null confinement profile
  * @isstale: flag indicating if profile is stale
+ * @replacement: profile replacing this profile
  * @capabilities: capabilities granted by the process
  * @count: reference count of the profile
  *
@@ -109,6 +110,7 @@ struct aa_profile {
 	} flags;
 	struct aa_profile *null_profile;
 	int isstale;
+	struct aa_profile *replacement;
 
 	kernel_cap_t capabilities;
 	struct kref count;
--- a/security/apparmor/module_interface.c
+++ b/security/apparmor/module_interface.c
@@ -346,14 +346,15 @@ static struct aa_profile *aa_unpack_prof
 /**
  * aa_verify_head - unpack serialized stream header
  * @e: serialized data read head
+ * @log: log a message on failure
  * @operation: operation header is being verified for
  *
  * returns error or 0 if header is good
  */
-static int aa_verify_header(struct aa_ext *e, const char *operation)
+static int aa_verify_header(struct aa_ext *e, int log, const char *operation)
 {
 	/* get the interface version */
-	if (!aa_is_u32(e, &e->version, "version")) {
+	if (!aa_is_u32(e, &e->version, "version") && log) {
 		struct aa_audit sa;
 		memset(&sa, 0, sizeof(sa));
 		sa.operation = operation;
@@ -364,7 +365,7 @@ static int aa_verify_header(struct aa_ex
 	}
 
 	/* check that the interface version is currently supported */
-	if (e->version != 3) {
+	if (e->version != 3 && log) {
 		struct aa_audit sa;
 		memset(&sa, 0, sizeof(sa));
 		sa.operation = operation;
@@ -376,37 +377,82 @@ static int aa_verify_header(struct aa_ex
 	return 0;
 }
 
+static void free_list_of_profiles(struct list_head *lh)
+{
+	struct aa_profile *profile, *tmp;
+	list_for_each_entry_safe(profile, tmp, lh, list) {
+		list_del_init(&profile->list);
+		aa_put_profile(profile);
+	}
+}
+
+/**
+ * aa_unpack_profile_set - unpack a set of profiles an place on @lh
+ * @e: serialized data read head
+ * @lh: list to place profiles on (preinit)
+ * @op: which interface operation is unpacking the profile set
+ *
+ * returns error or 0 if all profiles are good
+ */
+static int aa_unpack_profile_set(struct aa_ext *e, struct list_head *lh,
+				 const char *op)
+{
+	struct aa_profile *profile;
+	size_t error = aa_verify_header(e, 1, op);
+	if (error)
+		return error;
+
+	while (aa_inbounds(e, 1)) {
+		profile = aa_unpack_profile_wrapper(e, op);
+		if (IS_ERR(profile)) {
+			free_list_of_profiles(lh);
+			return PTR_ERR(profile);
+		}
+		list_add(&profile->list, lh);
+		aa_verify_header(e, 0, op);	/* skip header if present */
+	}
+	return 0;
+}
+
 /**
- * aa_add_profile - Unpack and add a new profile to the profile list
+ * aa_add_profile - Unpack and add a new profile(s) to the profile list
  * @data: serialized data stream
  * @size: size of the serialized data stream
+ *
+ * The profile load is an all or nothing operation.  If any of the
+ * profiles being loaded already exist the load will fail and
+ * non of the profiles will be loaded.
  */
 ssize_t aa_add_profile(void *data, size_t size)
 {
-	struct aa_profile *profile = NULL;
+	LIST_HEAD(add_set);
+	struct aa_profile *profile, *tmp = NULL;
 	struct aa_ext e = {
 		.start = data,
 		.end = data + size,
 		.pos = data
 	};
-	ssize_t error = aa_verify_header(&e, "profile_load");
+	ssize_t error = aa_unpack_profile_set(&e, &add_set, "profile_load");
 	if (error)
 		return error;
 
-	profile = aa_unpack_profile_wrapper(&e, "profile_load");
-	if (IS_ERR(profile))
-		return PTR_ERR(profile);
-
 	mutex_lock(&aa_interface_lock);
 	write_lock(&profile_list_lock);
-	if (__aa_find_profile(profile->name, &profile_list)) {
-		/* A profile with this name exists already. */
-		write_unlock(&profile_list_lock);
-		mutex_unlock(&aa_interface_lock);
-		aa_put_profile(profile);
-		return -EEXIST;
+	list_for_each_entry(profile, &add_set, list) {
+		if (__aa_find_profile(profile->name, &profile_list)) {
+			/* A profile with this name exists already.
+			 * It would be nice if we could return which profile
+			 * already exists
+			 */
+			write_unlock(&profile_list_lock);
+			mutex_unlock(&aa_interface_lock);
+			free_list_of_profiles(&add_set);
+			return -EEXIST;
+		}
 	}
-	list_add(&profile->list, &profile_list);
+	list_for_each_entry_safe(profile, tmp, &add_set, list) {
+		list_move(&profile->list, &profile_list);
+ 	}
 	write_unlock(&profile_list_lock);
 	mutex_unlock(&aa_interface_lock);
 
@@ -451,47 +497,10 @@ static inline void task_replace(struct t
 				       cxt->hat_magic);
 }
 
-/**
- * aa_replace_profile - replace a profile on the profile list
- * @udata: serialized data stream
- * @size: size of the serialized data stream
- *
- * unpack and replace a profile on the profile list and uses of that profile
- * by any aa_task_context.  If the profile does not exist on the profile list
- * it is added.  Return %0 or error.
- */
-ssize_t aa_replace_profile(void *udata, size_t size)
+static void replace_profiles_context_list(struct aa_profile *old_profile,
+					  struct aa_profile *new_profile)
 {
-	struct aa_profile *old_profile, *new_profile;
 	struct aa_task_context *new_cxt;
-	struct aa_ext e = {
-		.start = udata,
-		.end = udata + size,
-		.pos = udata
-	};
-	ssize_t error = aa_verify_header(&e, "profile_replace");
-	if (error)
-		return error;
-
-	new_profile = aa_unpack_profile_wrapper(&e, "profile_replace");
-	if (IS_ERR(new_profile))
-		return PTR_ERR(new_profile);
-
-	mutex_lock(&aa_interface_lock);
-	write_lock(&profile_list_lock);
-	old_profile = __aa_find_profile(new_profile->name, &profile_list);
-	if (old_profile) {
-		lock_profile(old_profile);
-		old_profile->isstale = 1;
-		unlock_profile(old_profile);
-		list_del_init(&old_profile->list);
-	}
-	list_add(&new_profile->list, &profile_list);
-	write_unlock(&profile_list_lock);
-
-	if (!old_profile)
-		goto out;
-
 	/*
 	 * Replacement needs to allocate a new aa_task_context for each
 	 * task confined by old_profile.  To do this the profile locks
@@ -517,13 +526,67 @@ ssize_t aa_replace_profile(void *udata, 
 		unlock_both_profiles(old_profile, new_profile);
 	} while (!new_cxt);
 	aa_free_task_context(new_cxt);
-	aa_put_profile(old_profile);
+}
+
+/**
+ * aa_replace_profile - replace a profile(s) on the profile list
+ * @udata: serialized data stream
+ * @size: size of the serialized data stream
+ *
+ * unpack and replace a profile(s) on the profile list and uses of that profile
+ * by any aa_task_context.  If the profile(s) does not exist on the profile
+ * list it is added.  Return %0 or error.
+ */
+ssize_t aa_replace_profile(void *udata, size_t size)
+{
+	LIST_HEAD(new_set);
+	LIST_HEAD(old_set);
+	struct aa_profile *old_profile, *new_profile, *tmp;
+	struct aa_ext e = {
+		.start = udata,
+		.end = udata + size,
+		.pos = udata
+	};
+	ssize_t error = aa_unpack_profile_set(&e, &new_set, "profile_replace");
+	if (error)
+		return error;
+
+	mutex_lock(&aa_interface_lock);
+	write_lock(&profile_list_lock);
+	list_for_each_entry_safe(new_profile, tmp, &new_set, list) {
+		old_profile = __aa_find_profile(new_profile->name,
+						&profile_list);
+		if (old_profile) {
+			lock_profile(old_profile);
+			old_profile->isstale = 1;
+			old_profile->replacement = aa_dup_profile(new_profile);
+			unlock_profile(old_profile);
+			list_move(&old_profile->list, &old_set);
+		}
+		list_move(&new_profile->list, &profile_list);
+	}
+	write_unlock(&profile_list_lock);
+
+	if (list_empty(&old_set))
+		goto out;
+
+	while(!list_empty(&old_set)) {
+		old_profile = list_entry(old_set.next, struct aa_profile,
+					 list);
+		list_del_init(&old_profile->list);
+		replace_profiles_context_list(old_profile,
+					      old_profile->replacement);
+		aa_put_profile(old_profile->replacement);
+		old_profile->replacement = NULL;
+		aa_put_profile(old_profile);
+	}
 
 out:
 	mutex_unlock(&aa_interface_lock);
 	return size;
 }
 
+
 /**
  * aa_remove_profile - remove a profile from the system
  * @name: name of the profile to remove
