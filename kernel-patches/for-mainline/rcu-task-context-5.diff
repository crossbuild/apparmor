Index: b/security/apparmor/lsm.c
===================================================================
--- a/security/apparmor/lsm.c
+++ b/security/apparmor/lsm.c
@@ -558,6 +558,9 @@ static int apparmor_task_alloc_security(
 	return aa_clone(task);
 }
 
+/*
+ * Called from IRQ context from RCU callback.
+ */
 static void apparmor_task_free_security(struct task_struct *task)
 {
 	aa_release(task);
Index: b/security/apparmor/inline.h
===================================================================
--- a/security/apparmor/inline.h
+++ b/security/apparmor/inline.h
@@ -61,11 +61,11 @@ static inline struct aa_profile *aa_find
 	return profile;
 }
 
-static inline struct aa_task_context *aa_alloc_task_context(void)
+static inline struct aa_task_context *aa_alloc_task_context(gfp_t mask)
 {
 	struct aa_task_context *cxt;
 
-	cxt = kzalloc(sizeof(*cxt), GFP_KERNEL);
+	cxt = kzalloc(sizeof(*cxt), mask);
 	if (cxt) {
 		INIT_LIST_HEAD(&cxt->list);
 		INIT_RCU_HEAD(&cxt->rcu);
Index: b/security/apparmor/main.c
===================================================================
--- a/security/apparmor/main.c
+++ b/security/apparmor/main.c
@@ -748,7 +748,7 @@ int aa_clone(struct task_struct *child)
 
 	if (!aa_task_context(current))
 		return 0;
-	child_cxt = aa_alloc_task_context();
+	child_cxt = aa_alloc_task_context(GFP_KERNEL);
 	if (!child_cxt)
 		return -ENOMEM;
 
@@ -765,6 +765,7 @@ repeat:
 			 */
 			unlock_profile(profile);
 			aa_put_profile(profile);
+			schedule();
 			goto repeat;
 		}
 
@@ -930,8 +931,10 @@ repeat:
 	if (IS_ERR(old_profile)) {
 		aa_put_profile(new_profile);
 		aa_put_profile(profile);
-		if (PTR_ERR(old_profile) == -ESTALE)
+		if (PTR_ERR(old_profile) == -ESTALE) {
+			schedule();
 			goto repeat;
+		}
 		new_profile = old_profile;
 		goto cleanup;
 	}
@@ -1099,7 +1102,7 @@ int aa_change_hat(const char *hat_name, 
 			hat_magic, current->pid);
 	}
 
-	new_cxt = aa_alloc_task_context();
+	new_cxt = aa_alloc_task_context(GFP_KERNEL);
 	if (!new_cxt)
 		return -ENOMEM;
 
@@ -1195,7 +1198,7 @@ struct aa_profile *aa_replace_profile(st
 	struct aa_profile *old_profile = NULL;
 
 	if (profile) {
-		new_cxt = aa_alloc_task_context();
+		new_cxt = aa_alloc_task_context(GFP_KERNEL);
 		if (!new_cxt)
 			return ERR_PTR(-ENOMEM);
 	}
Index: b/security/apparmor/module_interface.c
===================================================================
--- a/security/apparmor/module_interface.c
+++ b/security/apparmor/module_interface.c
@@ -14,8 +14,6 @@
 #include "apparmor.h"
 #include "inline.h"
 
-static DEFINE_MUTEX(aa_interface_lock);
-
 /* The AppArmor interface treats data as a type byte followed by the
  * actual data.  The interface has the notion of a a named entry
  * which has a name (AA_NAME typecode followed by name string) followed by
@@ -364,18 +362,15 @@ ssize_t aa_file_prof_add(void *data, siz
 	if (IS_ERR(profile))
 		return PTR_ERR(profile);
 
-	mutex_lock(&aa_interface_lock);
 	write_lock(&profile_list_lock);
 	if (__aa_find_profile(profile->name, &profile_list)) {
 		/* A profile with this name exists already. */
 		write_unlock(&profile_list_lock);
-		mutex_unlock(&aa_interface_lock);
 		aa_put_profile(profile);
 		return -EEXIST;
 	}
 	list_add(&profile->list, &profile_list);
 	write_unlock(&profile_list_lock);
-	mutex_unlock(&aa_interface_lock);
 
 	return size;
 }
@@ -446,57 +441,59 @@ ssize_t aa_file_prof_replace(void *udata
 	if (IS_ERR(new_profile))
 		return PTR_ERR(new_profile);
 
-	mutex_lock(&aa_interface_lock);
+repeat:
 	write_lock(&profile_list_lock);
 	old_profile = __aa_find_profile(new_profile->name, &profile_list);
 	if (old_profile) {
+		lock_profile(old_profile);
+		if (old_profile->isstale) {
+			unlock_profile(old_profile);
+			write_unlock(&profile_list_lock);
+			schedule();
+			goto repeat;
+		}
 		old_profile->isstale = 1;
-		list_del_init(&old_profile->list);
+		unlock_profile(old_profile);
 	}
-	list_add(&new_profile->list, &profile_list);
 	write_unlock(&profile_list_lock);
 
 	if (!old_profile)
-		goto out;
+		goto add_new_profile;
 
 	/*
-	 * FIXME: this loop is confusing. Can't we simply allocate the new
-	 * task context under the profile locks after checking that we
-	 * actually need it?
+	 * We marked the old profile stale, so no other task will modify its
+	 * task context list anymore.
+	 *
+	 * Note: the old profile is still on the profile list, so no
+	 * further replacements or removals will race with us.
 	 */
-	do {
-		new_cxt = aa_alloc_task_context();
-		/*
-		 * FIXME: what do we do when allocation fails --
-		 * I guess allocate in a way that cannot fail.
-		 */
-		if (!new_cxt)
-			break;
+
+	while (!list_empty(&old_profile->task_contexts)) {
+		struct task_struct *task =
+			list_entry(old_profile->task_contexts.next,
+				   struct aa_task_context, list)->task;
+
+		new_cxt = aa_alloc_task_context(GFP_KERNEL | __GFP_NOFAIL);
 
 		/*
-		 * new_profile needs to be locked in the case that there
-		 * are multiple tasks on old_profile->list, this avoids
-		 * a race between an already replaced task changing its
-		 * profile (updating the list) and replacement updating
-		 * the list
+		 * The new profile will immediately be used by the tasks it
+		 * is already attached to, so we need to lock it to keep the
+		 * task context list consistent.
 		 */
-		lock_both_profiles(old_profile, new_profile);
-		if (!list_empty(&old_profile->task_contexts)) {
-			struct task_struct *task =
-				list_entry(old_profile->task_contexts.next,
-					   struct aa_task_context, list)->task;
-			task_lock(task);
-			task_replace(task, new_cxt, new_profile);
-			task_unlock(task);
-			new_cxt = NULL;
-		}
-		unlock_both_profiles(old_profile, new_profile);
-	} while (!new_cxt);
-	aa_free_task_context(new_cxt);
-	aa_put_profile(old_profile);
 
-out:
-	mutex_unlock(&aa_interface_lock);
+		lock_profile(new_profile);
+		task_lock(task);
+		task_replace(task, new_cxt, new_profile);
+		task_unlock(task);
+		unlock_profile(new_profile);
+	}
+
+add_new_profile:
+	write_lock(&profile_list_lock);
+	list_del_init(&old_profile->list);
+	list_add(&new_profile->list, &profile_list);
+	write_unlock(&profile_list_lock);
+	aa_put_profile(old_profile);
 
 	return size;
 }
@@ -513,19 +510,32 @@ ssize_t aa_file_prof_remove(const char *
 {
 	struct aa_profile *profile;
 
-	mutex_lock(&aa_interface_lock);
+repeat:
 	write_lock(&profile_list_lock);
 	profile = __aa_find_profile(name, &profile_list);
 	if (!profile) {
 		write_unlock(&profile_list_lock);
-		mutex_unlock(&aa_interface_lock);
 		return -ENOENT;
 	}
+	lock_profile(profile);
+	if (profile->isstale) {
+		unlock_profile(profile);
+		write_unlock(&profile_list_lock);
+		schedule();
+		goto repeat;
+	}
 	profile->isstale = 1;
-	list_del_init(&profile->list);
 	write_unlock(&profile_list_lock);
+	unlock_profile(profile);
+
+	/*
+	 * We marked the profile stale, so no other task will modify its
+	 * task context list anymore.
+	 *
+	 * Note: the old profile is still on the profile list, so no
+	 * further replacements or removals will race with us.
+	 */
 
-	lock_profile(profile);
 	while (!list_empty(&profile->task_contexts)) {
 		struct task_struct *task =
 			list_entry(profile->task_contexts.next,
@@ -534,8 +544,10 @@ ssize_t aa_file_prof_remove(const char *
 		aa_change_task_context(task, NULL, NULL, 0);
 		task_unlock(task);
 	}
-	unlock_profile(profile);
-	mutex_unlock(&aa_interface_lock);
+
+	write_lock(&profile_list_lock);
+	list_del_init(&profile->list);
+	write_unlock(&profile_list_lock);
 	aa_put_profile(profile);
 
 	return size;
