Convert AppArmor to use rcu replacement for aa_task_contexts.  This fixes
two bugs in the current code.
- leaking of aa_task_contexts by tasks that are now unconfined when
  apparmor is shutdown
- the rcu free profile race

this patch also enables the capability path to be completely lockless
as well as not requiring it to obtain a reference count.


Index: b/security/apparmor/apparmor.h
===================================================================
--- a/security/apparmor/apparmor.h
+++ b/security/apparmor/apparmor.h
@@ -90,7 +90,6 @@ static inline int mediated_filesystem(st
  * @null_profile: if needed per profile learning and null confinement profile
  * @isstale: flag to indicate the profile is stale
  * @capabilities: capabilities granted by the process
- * @rcu: rcu head used when freeing the profile
  * @count: reference count of the profile
  *
  * The AppArmor profile contains the basic confinement data.  Each profile
@@ -118,7 +117,6 @@ struct aa_profile {
 	int isstale;
 
 	kernel_cap_t capabilities;
-	struct rcu_head rcu;
 	struct kref count;
 	struct list_head task_contexts;
 	spinlock_t lock;
@@ -134,6 +132,7 @@ extern rwlock_t profile_list_lock;
  * @hat_magic: the magic token controling the ability to leave a hat
  * @list: list this aa_task_context is on
  * @task: task that the aa_task_context confines
+ * @rcu: rcu head used when freeing the aa_task_context
  * @caps_logged: caps that have previously generated log entries
  *
  * Contains the task's current profile (which could change due to
@@ -144,6 +143,7 @@ struct aa_task_context {
 	u64 hat_magic;			/* used with change_hat */
 	struct list_head list;
 	struct task_struct *task;
+	struct rcu_head rcu;
 	kernel_cap_t caps_logged;
 };
 
@@ -210,6 +210,7 @@ struct aa_audit {
 #define AA_CHECK_DIR	4  /* file type is directory */
 
 /* main.c */
+extern void free_aa_task_context_rcu_callback(struct rcu_head *head);
 extern int alloc_null_complain_profile(void);
 extern void free_null_complain_profile(void);
 extern int attach_nullprofile(struct aa_profile *profile);
@@ -224,7 +225,7 @@ extern int aa_attr(struct aa_profile *pr
 extern int aa_perm_xattr(struct aa_profile *profile, struct dentry *dentry,
 			 struct vfsmount *mnt, const char *operation,
 			 const char *xattr_xattr, int mask, int check);
-extern int aa_capability(struct aa_profile *profile, int cap);
+extern int aa_capability(struct aa_task_context *cxt, int cap);
 extern int aa_perm(struct aa_profile *profile, struct dentry *dentry,
 		   struct vfsmount *mnt, int mask, int check);
 extern int aa_perm_dir(struct aa_profile *profile, struct dentry *dentry,
@@ -241,6 +242,8 @@ extern struct aa_profile *__aa_find_prof
 extern struct aa_profile *aa_replace_profile(struct task_struct *task,
 					     struct aa_profile *profile,
 					     u32 hat_magic);
+extern struct aa_task_context *lock_task_and_profiles(struct task_struct *task,
+						      struct aa_profile *profile);
 
 /* list.c */
 extern void aa_profilelist_release(void);
Index: b/security/apparmor/inline.h
===================================================================
--- a/security/apparmor/inline.h
+++ b/security/apparmor/inline.h
@@ -42,7 +42,7 @@ static inline struct aa_profile *aa_get_
 	rcu_read_lock();
 	cxt = aa_task_context(task);
 	if (cxt) {
-		profile = rcu_dereference(cxt->profile);
+		profile = cxt->profile;
 		aa_dup_profile(profile);
 	}
 	rcu_read_unlock();
@@ -62,25 +62,31 @@ static inline struct aa_profile *aa_find
 }
 
 /**
- * aa_change_profile - switch a task context to a new profile
- * @cxt: aa_task_context to switch the profile on
- * @profile: new profile (NULL for unconfined)
+ * aa_change_task_context - switch a tasks to use a new context and profile
+ * @task: task that is having its aa_task_context changed
+ * @new_cxt: new aa_task_context to use after the switch
+ * @profile: new profile to use after the switch
  * @hat_magic: hat value to switch to (0 for no hat)
  */
-static inline void aa_change_profile(struct aa_task_context *cxt,
-				     struct aa_profile *profile,
-				     u64 hat_magic)
-{
-	struct aa_profile *old_profile = cxt->profile;
-
-	cxt->caps_logged = CAP_EMPTY_SET;
-	cxt->hat_magic = hat_magic;
-	rcu_assign_pointer(cxt->profile, aa_dup_profile(profile));
-	if (profile)
-		list_move(&cxt->list, &profile->task_contexts);
-	else
-		list_del_init(&cxt->list);
-	aa_put_profile(old_profile);
+static inline void
+aa_change_task_context(struct task_struct *task,
+		       struct aa_task_context *new_cxt,
+		       struct aa_profile *profile, u64 hat_magic)
+{
+	struct aa_task_context *old_cxt = aa_task_context(task);
+
+	if (old_cxt)
+		list_del_init(&old_cxt->list);
+
+	if (new_cxt) {
+		new_cxt->caps_logged = CAP_EMPTY_SET;
+		new_cxt->hat_magic = hat_magic;
+		new_cxt->task = task;
+		new_cxt->profile = aa_dup_profile(profile);
+		list_move(&new_cxt->list, &profile->parent->task_contexts);
+	}
+
+	rcu_assign_pointer(task->security, new_cxt);
 }
 
 static inline struct aa_task_context *
@@ -91,6 +97,7 @@ aa_alloc_task_context(struct task_struct
 	cxt = kzalloc(sizeof(*cxt), GFP_KERNEL);
 	if (cxt) {
 		INIT_LIST_HEAD(&cxt->list);
+		INIT_RCU_HEAD(&cxt->rcu);
 		cxt->task = task;
 	}
 
@@ -99,7 +106,16 @@ aa_alloc_task_context(struct task_struct
 
 static inline void aa_free_task_context(struct aa_task_context *cxt)
 {
-	kfree(cxt);
+	if (cxt) {
+		aa_put_profile(cxt->profile);
+		kfree(cxt);
+	}
+}
+
+static inline void aa_free_task_context_rcu(struct aa_task_context *cxt)
+{
+	if (cxt)
+		call_rcu(&cxt->rcu, free_aa_task_context_rcu_callback);
 }
 
 /**
@@ -116,7 +132,6 @@ static inline struct aa_profile *alloc_a
 		profile->parent = profile;
 		INIT_LIST_HEAD(&profile->list);
 		INIT_LIST_HEAD(&profile->sub);
-		INIT_RCU_HEAD(&profile->rcu);
 		kref_init(&profile->count);
 		INIT_LIST_HEAD(&profile->task_contexts);
 		spin_lock_init(&profile->lock);
@@ -196,6 +211,7 @@ static inline void lock_both_profiles(st
 		spin_lock_irqsave(&profile1->lock, profile1->int_flags);
 		if (profile2)
 			spin_lock(&profile2->lock);
+
 	} else {
 		spin_lock_irqsave(&profile2->lock, profile2->int_flags);
 		spin_lock(&profile1->lock);
Index: b/security/apparmor/lsm.c
===================================================================
--- a/security/apparmor/lsm.c
+++ b/security/apparmor/lsm.c
@@ -88,13 +88,13 @@ static int apparmor_ptrace(struct task_s
 
 	error = cap_ptrace(parent, child);
 	if (!error) {
-		struct aa_profile *profile;
+		struct aa_task_context *cxt;
 
-		profile = aa_get_profile(parent);
-		if (profile) {
-			error = aa_capability(profile, CAP_SYS_PTRACE);
-		}
-		aa_put_profile(profile);
+		rcu_read_lock();
+		cxt = aa_task_context(parent);
+		if (cxt)
+			error = aa_capability(cxt, CAP_SYS_PTRACE);
+		rcu_read_unlock();
 	}
 
 	return error;
@@ -132,14 +132,13 @@ static int apparmor_capable(struct task_
 	error = cap_capable(task, cap);
 
 	if (!error) {
-		struct aa_profile *profile;
-
-		profile = aa_get_profile(task);
+		struct aa_task_context *cxt;
 
-		if (profile)
-			error = aa_capability(profile, cap);
-
-		aa_put_profile(profile);
+		rcu_read_lock();
+		cxt = aa_task_context(task);
+		if (cxt)
+			error = aa_capability(cxt, cap);
+		rcu_read_unlock();
 	}
 
 	return error;
@@ -801,8 +800,6 @@ createfs_out:
 
 static void __exit apparmor_exit(void)
 {
-	LIST_HEAD(task_contexts_bucket);
-
 	/* Remove and release all the profiles on the profile list. */
 	write_lock(&profile_list_lock);
 	while (!list_empty(&profile_list)) {
@@ -823,9 +820,9 @@ static void __exit apparmor_exit(void)
 			 */
 			task_lock(cxt->task);
 			rcu_assign_pointer(cxt->task->security, NULL);
-			aa_change_profile(cxt, NULL, 0);
-			list_add(&cxt->list, &task_contexts_bucket);
+			aa_change_task_context(cxt->task, NULL, NULL, 0);
 			task_unlock(cxt->task);
+			aa_free_task_context_rcu(cxt);
 		}
 		unlock_profile(profile);
 
@@ -844,16 +841,6 @@ static void __exit apparmor_exit(void)
 	 */
 	synchronize_rcu();
 
-	/* Now we can safely free all remaining task contexts. */
-	while (!list_empty(&task_contexts_bucket)) {
-		struct aa_task_context *cxt =
-			list_entry(task_contexts_bucket.next,
-				   struct aa_task_context, list);
-
-		list_del(&cxt->list);
-		kfree(cxt);
-	}
-
 	destroy_apparmorfs();
 
 	if (unregister_security(&apparmor_ops))
Index: b/security/apparmor/main.c
===================================================================
--- a/security/apparmor/main.c
+++ b/security/apparmor/main.c
@@ -651,24 +651,29 @@ int aa_perm_dir(struct aa_profile *profi
 
 /**
  * aa_capability - test permission to use capability
- * @profile: profile to check against
+ * @cxt: aa_task_context with profile to check against
  * @cap: capability to be tested
  *
  * Look up capability in profile capability set.
  * Return %0 (success), -%EPERM (error)
  */
-int aa_capability(struct aa_profile *profile, int cap)
+int aa_capability(struct aa_task_context *cxt, int cap)
 {
-	int error = cap_raised(profile->capabilities, cap) ? 0 : -EPERM;
+	int error = cap_raised(cxt->profile->capabilities, cap) ? 0 : -EPERM;
 	struct aa_audit sa;
-	struct aa_task_context *cxt = aa_task_context(current);
 
 	/* test if cap has alread been logged */
 	if (cap_raised(cxt->caps_logged, cap)) {
-		if (PROFILE_COMPLAIN(profile))
+		if (PROFILE_COMPLAIN(cxt->profile))
 			error = 0;
 		return error;
 	} else
+		/* don't worry about rcu replacement of the cxt here.
+		 * caps_logged is a cache to reduce the occurance of
+		 * duplicate messages in the log.  The worst that can
+		 * happen is duplicate capability messages show up in
+		 * the audit log
+		 */
 		cap_raise(cxt->caps_logged, cap);
 
 	sa.type = AA_AUDITTYPE_CAP;
@@ -679,7 +684,7 @@ int aa_capability(struct aa_profile *pro
 	sa.result = !error;
 	sa.gfp_mask = GFP_ATOMIC;
 
-	error = aa_audit(profile, &sa);
+	error = aa_audit(cxt->profile, &sa);
 
 	return error;
 }
@@ -764,8 +769,8 @@ repeat:
 		}
 
 		/* No need to grab the child's task lock here. */
-		rcu_assign_pointer(child->security, child_cxt);
-		aa_change_profile(child_cxt, profile, cxt->hat_magic);
+		aa_change_task_context(child, child_cxt, profile,
+				       cxt->hat_magic);
 		unlock_profile(profile);
 
 		if (APPARMOR_COMPLAIN(child_cxt) &&
@@ -972,49 +977,38 @@ cleanup:
  */
 void aa_release(struct task_struct *task)
 {
+	struct aa_task_context *cxt;
 	struct aa_profile *profile;
-
 	/*
 	 * While the task context is still on a profile's task context
 	 * list, another process could replace the profile under us,
 	 * leaving us with a locked profile that is no longer attached
-	 * to this task. So after locking the profile, we lock the task
-	 * to make sure that the profile is still attached. (We must
-	 * lock the profile first to avoid lock inversion.)
+	 * to this task. So after locking the profile, we check that
+	 * the profile is still attached.  If it is the profile lock
+	 * is sufficient to prevent the replacement race so we do not
+	 * lock the task.  We avoid taking the task_lock here because
+	 * lock_dep will report an inconsistent {softirq-on-W} potential
+	 * irq_lock inversion, this specific case is safe but we would
+	 * still like to avoid the message.
 	 *
 	 * If the task does not have a profile attached at this point,
 	 * we are safe.
 	 */
 
-repeat:
+ repeat:
 	profile = aa_get_profile(task);
 	if (profile) {
-		struct aa_task_context *cxt;
-
 		lock_profile(profile);
-		task_lock(task);
 		cxt = aa_task_context(task);
 		if (unlikely(!cxt || cxt->profile != profile)) {
-			task_unlock(task);
 			unlock_profile(profile);
 			aa_put_profile(profile);
 			goto repeat;
 		}
-		/*
-		 * There may still be other profile readers, so we must
-		 * put the profile reference safely.
-		 */
-		aa_change_profile(cxt, NULL, 0);
-		task_unlock(task);
-		list_del(&cxt->list);
+		aa_change_task_context(task, NULL, NULL, 0);
 		unlock_profile(profile);
 		aa_put_profile(profile);
-		/* it is safe to free the task_context here, it has been
-		 * removed from the context list it was on and
-		 * the task that could access this context is dead
-		 */
-		aa_free_task_context(cxt);
-		rcu_assign_pointer(task->security, NULL);
+		aa_free_task_context_rcu(cxt);
 	}
 }
 
@@ -1025,14 +1019,15 @@ repeat:
 /**
  * do_change_hat - actually switch hats
  * @hat_name: name of hat to switch to
- * @cxt: current aa_task_context
+ * @new_cxt: new aa_task_context to use on profile change
  *
  * Switch to a new hat.  Return %0 on success, error otherwise.
  */
 static inline int do_change_hat(const char *hat_name,
-				struct aa_task_context *cxt,
+				struct aa_task_context *new_cxt,
 				u64 hat_magic)
 {
+	struct aa_task_context *cxt = aa_task_context(current);
 	struct aa_profile *sub;
 	int error = 0;
 
@@ -1043,15 +1038,7 @@ static inline int do_change_hat(const ch
 	sub = __aa_find_profile(hat_name, &cxt->profile->parent->sub);
 	if (sub) {
 		/* change hat */
-		aa_change_profile(cxt, sub, hat_magic);
-		/*
-		 * aa_change_profile switches profile lists but we don't
-		 * want this for change_hat.  Switch back to the parents
-		 * list.
-		 * FIXME: update to a full profile change mechanism
-		 * to get rid of this special casing
-		 */
-		list_move(&cxt->list, &sub->parent->task_contexts);
+		aa_change_task_context(current, new_cxt, sub, hat_magic);
 	} else {
 		struct aa_profile *profile = cxt->profile;
 
@@ -1081,16 +1068,10 @@ static inline int do_change_hat(const ch
 		 *
 		 * In learning mode, this allows us to learn about new hats.
 		 */
-		aa_change_profile(cxt, cxt->profile->null_profile, hat_magic);
-		/*
-		 * aa_change_profile switches profile lists but we don't
-		 * want this for change_hat.  Switch back to the parents
-		 * list.
-		 * FIXME: update to a full profile change mechanism
-		 * to get rid of this special casing
-		 */
-		list_move(&cxt->list, &cxt->profile->parent->task_contexts);
+		aa_change_task_context(current, new_cxt,
+				       cxt->profile->null_profile, hat_magic);
 	}
+	aa_free_task_context_rcu(cxt);
 
 	return error;
 }
@@ -1108,7 +1089,7 @@ static inline int do_change_hat(const ch
  */
 int aa_change_hat(const char *hat_name, u64 hat_magic)
 {
-	struct aa_task_context *cxt;
+	struct aa_task_context *cxt, *new_cxt;
 	struct aa_profile *profile;
 	int error = 0;
 
@@ -1119,22 +1100,21 @@ int aa_change_hat(const char *hat_name, 
 			hat_magic, current->pid);
 	}
 
-repeat:
-	profile = aa_get_profile(current);
-	if (!profile) {
+	new_cxt = aa_alloc_task_context(current);
+	if (!new_cxt)
+		return -ENOMEM;
+
+	cxt = lock_task_and_profiles(current, NULL);
+	if (!cxt) {
 		/* An unconfined process cannot change_hat(). */
-		return -EPERM;
-	}
-	lock_profile(profile);
-	task_lock(current);
-	cxt = aa_task_context(current);
-	if (unlikely(profile->isstale || !cxt || cxt->profile != profile)) {
 		task_unlock(current);
-		unlock_profile(profile);
-		aa_put_profile(profile);
-		goto repeat;
+		aa_free_task_context(new_cxt);
+		return -EPERM;
 	}
 
+	/* no need to get reference count */
+	profile = cxt->profile;
+
 	/* check to see if the confined process has any hats. */
 	if (list_empty(&profile->parent->sub) && !PROFILE_COMPLAIN(profile)) {
 		error = -ECHILD;
@@ -1148,13 +1128,14 @@ repeat:
 				 __FUNCTION__,
 				 hat_name,
 				 hat_magic);
-			error = do_change_hat(hat_name, cxt, hat_magic);
+			error = do_change_hat(hat_name, new_cxt, hat_magic);
 		} else {
 			/* Got here via change_hat(NULL, magic)
 			 *
 			 * We used to simply update the magic cookie.
 			 * That's an odd behaviour, so just do nothing.
 			 */
+			aa_free_task_context(new_cxt);
 		}
 	} else {
 		/*
@@ -1168,18 +1149,15 @@ repeat:
 		if (hat_magic && hat_magic == cxt->hat_magic) {
 			if (!hat_name) {
 				/* Return from subprofile back to parent. */
-				aa_change_profile(cxt, cxt->profile->parent, 0);
-				/*
-				 * switching lists is not needed here because
-				 * aa_change_profile list move will leave the
-				 * cxt on the correct list
-				 */
+				aa_change_task_context(current, new_cxt,
+						       profile->parent, 0);
+				aa_free_task_context_rcu(cxt);
 			} else {
 				/*
 				 * Change to another (sibling) profile, and
 				 * stick with the same hat_magic.
 				 */
-				error = do_change_hat(hat_name, cxt,
+				error = do_change_hat(hat_name, new_cxt,
 						      cxt->hat_magic);
 			}
 		} else if (cxt->hat_magic) {
@@ -1194,6 +1172,7 @@ repeat:
 
 			/* terminate current process */
 			(void)send_sig_info(SIGKILL, NULL, current);
+			aa_free_task_context(new_cxt);
 		} else {	/* cxt->hat_magic == 0 */
 			AA_ERROR("KILLING process %s(%d) "
 				 "Task was confined to current subprofile "
@@ -1204,6 +1183,7 @@ repeat:
 
 			/* terminate current process */
 			(void)send_sig_info(SIGKILL, NULL, current);
+			aa_free_task_context(new_cxt);
 		}
 
 	}
@@ -1211,10 +1191,18 @@ repeat:
 out:
 	task_unlock(current);
 	unlock_profile(profile);
-	aa_put_profile(profile);
 	return error;
 }
 
+static inline void unlock_context_and_profile(struct aa_task_context *cxt,
+					      struct aa_profile *profile)
+{
+	if (cxt)
+		unlock_both_profiles(profile, cxt->profile);
+	else
+		unlock_profile(profile);
+}
+
 /**
  * aa_replace_profile - replace a task's profile
  */
@@ -1223,47 +1211,74 @@ struct aa_profile *aa_replace_profile(st
 				      u32 hat_magic)
 {
 	struct aa_task_context *cxt, *new_cxt = NULL;
-	struct aa_profile *old_profile;
-	int isstale;
+	struct aa_profile *old_profile = NULL;
 
-	/* If the task has no task context yet, allocate one. */
-	if (!aa_task_context(task)) {
+	if (profile) {
 		new_cxt = aa_alloc_task_context(task);
 		if (!new_cxt)
 			return ERR_PTR(-ENOMEM);
 	}
 
-repeat:
-	old_profile = aa_get_profile(task);
-	lock_both_profiles(old_profile, profile);
-	task_lock(task);
-	cxt = aa_task_context(task);
-	isstale = (profile && profile->isstale);
-	if (unlikely((cxt && old_profile != cxt->profile) || isstale)) {
-		/*
-		 * Someone invalidated the profile we wanted to attach
-		 * to this task, or the task switched profiles before we
-		 * could get hold of the locks.
-		 */
+	cxt = lock_task_and_profiles(task, profile);
+	if (profile && profile->isstale) {
 		task_unlock(task);
-		unlock_both_profiles(old_profile, profile);
-		aa_put_profile(old_profile);
-		old_profile = ERR_PTR(-ESTALE);
-		if (isstale)
-			goto out;
-		goto repeat;
-	}
-	if (!cxt) {
-		rcu_assign_pointer(task->security, new_cxt);
-		cxt = new_cxt;
-		new_cxt = NULL;
+		unlock_context_and_profile(cxt, profile);
+		aa_free_task_context(new_cxt);
+		return ERR_PTR(-ESTALE);
 	}
-	aa_change_profile(cxt, profile, hat_magic);
+
+	if (cxt) {
+		aa_change_task_context(task, new_cxt, profile, cxt->hat_magic);
+		old_profile = aa_dup_profile(cxt->profile);
+	} else
+		aa_change_task_context(task, new_cxt, profile, 0);
+
 	task_unlock(task);
-	unlock_both_profiles(old_profile, profile);
+	unlock_context_and_profile(cxt, profile);
+	aa_free_task_context_rcu(cxt);
 
-out:
-	if (new_cxt)
-		aa_free_task_context(new_cxt);
 	return old_profile;
 }
+
+void free_aa_task_context_rcu_callback(struct rcu_head *head)
+{
+	struct aa_task_context *cxt;
+	cxt = container_of(head, struct aa_task_context, rcu);
+	aa_free_task_context(cxt);
+}
+
+/**
+ * lock_task_and_profile - lock the task and confining profiles and @profile
+ * @task - task to lock
+ * @profile - extra profile to lock in addition to the current profile
+ *
+ * Handle the spinning on locking to make sure the task context and
+ * profile are consistent once all locks are aquired.
+ *
+ * return the aa_task_context currently confining the task.  The task lock
+ * will be held whether or not the task is confined.
+ */
+struct aa_task_context *
+lock_task_and_profiles(struct task_struct *task, struct aa_profile *profile)
+{
+	struct aa_task_context *cxt, *check_cxt;
+
+	rcu_read_lock();
+repeat:
+	cxt = aa_task_context(task);
+	if (cxt)
+		lock_both_profiles(profile, cxt->profile);
+	else
+		lock_profile(profile);
+	task_lock(task);
+	check_cxt = aa_task_context(task);
+
+	/* check for race with profile transition, replacement or removal */
+	if (unlikely(check_cxt != cxt)) {
+		task_unlock(task);
+		unlock_context_and_profile(cxt, profile);
+		goto repeat;
+	}
+	rcu_read_unlock();
+	return cxt;
+}
Index: b/security/apparmor/module_interface.c
===================================================================
--- a/security/apparmor/module_interface.c
+++ b/security/apparmor/module_interface.c
@@ -14,61 +14,7 @@
 #include "apparmor.h"
 #include "inline.h"
 
-/**
- * free_aa_profile_rcu - rcu callback for free profiles
- * @head: rcu_head struct of the profile whose reference is being put.
- *
- * the rcu callback routine, which delays the freeing of a profile when
- * its last reference is put.
- */
-static void free_aa_profile_rcu(struct rcu_head *head)
-{
-	struct aa_profile *p = container_of(head, struct aa_profile, rcu);
-	free_aa_profile(p);
-}
-
-/** task_replace - replace aa_task_context's current profile with a new profile
- * @cxt: aa_task_context to replace the profile on
- * @new: new profile
- *
- * Replace a task's (aa_task_context's) profile with a new profile.  If
- * task was in a hat then the new profile will also be in the equivalent
- * hat in the new profile if it exists.  If it doesn't exist the
- * task will be placed in the special null_profile state.
- */
-static inline void task_replace(struct aa_task_context *cxt,
-				struct aa_profile *new_profile)
-{
-	AA_DEBUG("%s: replacing profile for task %s(%d) "
-		 "profile=%s (%p) hat=%s (%p)\n",
-		 __FUNCTION__,
-		 cxt->task->comm, cxt->task->pid,
-		 cxt->profile->parent->name, cxt->profile->parent,
-		 cxt->profile->name, cxt->profile);
-
-	if (cxt->profile != cxt->profile->parent) {
-		struct aa_profile *hat;
-
-		/* The old profile was in a hat, check to see if the new
-		 * profile has an equivalent hat */
-		hat = __aa_find_profile(cxt->profile->name, &new_profile->sub);
-
-		if (!hat)
-			hat = aa_dup_profile(new_profile->null_profile);
-
-		aa_change_profile(cxt, hat, cxt->hat_magic);
-		/*
-		 * aa_change_profile switches profile lists but we don't
-		 * want this for change_hat.  Switch back to the parents
-		 * list.
-		 * FIXME: update to a full profile change mechanism
-		 * to get rid of this special casing
-		 */
-		list_move(&cxt->list, &hat->parent->task_contexts);
-		aa_put_profile(hat);
-	} else
-		aa_change_profile(cxt, new_profile, cxt->hat_magic);
-}
+static DEFINE_MUTEX(aa_interface_lock);
 
 /* The AppArmor interface treats data as a type byte followed by the
  * actual data.  The interface has the notion of a a named entry
@@ -418,19 +364,62 @@ ssize_t aa_file_prof_add(void *data, siz
 	if (IS_ERR(profile))
 		return PTR_ERR(profile);
 
+	mutex_lock(&aa_interface_lock);
 	write_lock(&profile_list_lock);
 	if (__aa_find_profile(profile->name, &profile_list)) {
 		/* A profile with this name exists already. */
 		write_unlock(&profile_list_lock);
+		mutex_unlock(&aa_interface_lock);
 		aa_put_profile(profile);
 		return -EEXIST;
 	}
 	list_add(&profile->list, &profile_list);
 	write_unlock(&profile_list_lock);
+	mutex_unlock(&aa_interface_lock);
 
 	return size;
 }
 
+/** task_replace - replace aa_task_context's current profile with a new profile
+ * @task: task to replace profile on
+ * @new_cxt: new aa_task_context to do replacement with
+ * @new: new profile
+ *
+ * Replace a task's (aa_task_context's) profile with a new profile.  If
+ * task was in a hat then the new profile will also be in the equivalent
+ * hat in the new profile if it exists.  If it doesn't exist the
+ * task will be placed in the special null_profile state.
+ */
+static inline void task_replace(struct task_struct *task,
+				struct aa_task_context *new_cxt,
+				struct aa_profile *new_profile)
+{
+	struct aa_task_context *cxt = aa_task_context(task);
+
+	AA_DEBUG("%s: replacing profile for task %s(%d) "
+		 "profile=%s (%p) hat=%s (%p)\n",
+		 __FUNCTION__,
+		 cxt->task->comm, cxt->task->pid,
+		 cxt->profile->parent->name, cxt->profile->parent,
+		 cxt->profile->name, cxt->profile);
+
+	if (cxt->profile != cxt->profile->parent) {
+		struct aa_profile *hat;
+
+		/* The old profile was in a hat, check to see if the new
+		 * profile has an equivalent hat */
+		hat = __aa_find_profile(cxt->profile->name, &new_profile->sub);
+
+		if (!hat)
+			hat = aa_dup_profile(new_profile->null_profile);
+
+		aa_change_task_context(task, new_cxt, hat, cxt->hat_magic);
+		aa_put_profile(hat);
+	} else
+		aa_change_task_context(task, new_cxt, new_profile,
+				       cxt->hat_magic);
+}
+
 /**
  * aa_file_prof_replace - replace a profile on the profile list
  * @udata: serialized data stream
@@ -443,6 +432,7 @@ ssize_t aa_file_prof_add(void *data, siz
 ssize_t aa_file_prof_replace(void *udata, size_t size)
 {
 	struct aa_profile *old_profile, *new_profile;
+	struct aa_task_context *new_cxt;
 	struct aa_ext e = {
 		.start = udata,
 		.end = udata + size,
@@ -456,33 +446,50 @@ ssize_t aa_file_prof_replace(void *udata
 	if (IS_ERR(new_profile))
 		return PTR_ERR(new_profile);
 
+	mutex_lock(&aa_interface_lock);
 	write_lock(&profile_list_lock);
 	old_profile = __aa_find_profile(new_profile->name, &profile_list);
 	if (old_profile) {
+		old_profile->isstale = 1;
+		list_del_init(&old_profile->list);
+	}
+	list_add(&new_profile->list, &profile_list);
+	write_unlock(&profile_list_lock);
+
+	if (!old_profile)
+		goto out;
+
+	do {
+		new_cxt = aa_alloc_task_context(NULL);
+		/* FIXME: what do we do when allocation fails */
+		if (!new_cxt)
+			break;
+
 		/*
 		 * new_profile needs to be locked in the case that there
-		 * are multiple tasks on old_profiles list, this avoids
+		 * are multiple tasks on old_profile->list, this avoids
 		 * a race between an already replaced task changing its
 		 * profile (updating the list) and replacement updating
 		 * the list
 		 */
 		lock_both_profiles(old_profile, new_profile);
-		old_profile->isstale = 1;
-		while (!list_empty(&old_profile->task_contexts)) {
+		if (!list_empty(&old_profile->task_contexts)) {
 			struct aa_task_context *cxt =
 				list_entry(old_profile->task_contexts.next,
 					   struct aa_task_context, list);
 			task_lock(cxt->task);
-			task_replace(cxt, new_profile);
+			task_replace(cxt->task, new_cxt, new_profile);
 			task_unlock(cxt->task);
+			aa_free_task_context_rcu(cxt);
+			new_cxt = NULL;
 		}
 		unlock_both_profiles(old_profile, new_profile);
+	} while (!new_cxt);
+	aa_free_task_context(new_cxt);
+	aa_put_profile(old_profile);
 
-		list_del_init(&old_profile->list);
-		aa_put_profile(old_profile);
-	}
-	list_add(&new_profile->list, &profile_list);
-	write_unlock(&profile_list_lock);
+out:
+	mutex_unlock(&aa_interface_lock);
 
 	return size;
 }
@@ -499,27 +506,30 @@ ssize_t aa_file_prof_remove(const char *
 {
 	struct aa_profile *profile;
 
+	mutex_lock(&aa_interface_lock);
 	write_lock(&profile_list_lock);
 	profile = __aa_find_profile(name, &profile_list);
 	if (!profile) {
 		write_unlock(&profile_list_lock);
+		mutex_unlock(&aa_interface_lock);
 		return -ENOENT;
 	}
+	profile->isstale = 1;
+	list_del_init(&profile->list);
+	write_unlock(&profile_list_lock);
 
 	lock_profile(profile);
-	profile->isstale = 1;
 	while (!list_empty(&profile->task_contexts)) {
 		struct aa_task_context *cxt =
 			list_entry(profile->task_contexts.next,
 				   struct aa_task_context, list);
 		task_lock(cxt->task);
-		aa_change_profile(cxt, NULL, 0);
+		aa_change_task_context(cxt->task, NULL, NULL, 0);
 		task_unlock(cxt->task);
-		list_del_init(&cxt->list);
+		aa_free_task_context_rcu(cxt);
 	}
 	unlock_profile(profile);
-	list_del_init(&profile->list);
-	write_unlock(&profile_list_lock);
+	mutex_unlock(&aa_interface_lock);
 	aa_put_profile(profile);
 
 	return size;
@@ -533,7 +543,7 @@ void free_aa_profile_kref(struct kref *k
 {
 	struct aa_profile *p=container_of(kr, struct aa_profile, count);
 
-	call_rcu(&p->rcu, free_aa_profile_rcu);
+	free_aa_profile(p);
 }
 
 /**
