Index: b/security/apparmor/inline.h
===================================================================
--- a/security/apparmor/inline.h
+++ b/security/apparmor/inline.h
@@ -62,28 +62,21 @@ static inline struct aa_profile *aa_find
 }
 
 /**
- * aa_switch_to_profile - change aa_task_context to use a new profile
+ * aa_change_profile - switch a task context to a new profile
  * @cxt: aa_task_context to switch the profile on
- * @newactive: new profile (NULL for unconfined)
+ * @profile: new profile (NULL for unconfined)
  * @hat_magic: hat value to switch to (0 for no hat)
- *
- * aa_switch_to_profile handles the changing of a aa_task_context's profile
- * profile.  The cxt_lock must be held to ensure consistency against
- * other writers.  Some write paths (ex. aa_register) require
- * cxt->profile not to change over several operations, so the calling
- * function is responsible for grabbing the cxt_lock to meet its
- * consistency constraints before calling aa_switch_to_profile
- */
-static inline void aa_switch_to_profile(struct aa_task_context *cxt,
-					struct aa_profile *newactive,
-					u32 hat_magic)
+ */
+static inline void aa_change_profile(struct aa_task_context *cxt,
+				     struct aa_profile *profile,
+				     u32 hat_magic)
 {
-	struct aa_profile *old = cxt->profile;
+	struct aa_profile *old_profile = cxt->profile;
 
 	cxt->caps_logged = CAP_EMPTY_SET;
 	cxt->hat_magic = hat_magic;
-	rcu_assign_pointer(cxt->profile, aa_dup_profile(newactive));
-	aa_put_profile(old);
+	rcu_assign_pointer(cxt->profile, aa_dup_profile(profile));
+	aa_put_profile(old_profile);
 }
 
 /**
Index: b/security/apparmor/lsm.c
===================================================================
--- a/security/apparmor/lsm.c
+++ b/security/apparmor/lsm.c
@@ -772,7 +772,7 @@ static void __exit apparmor_exit(void)
 	read_lock(&task_context_list_lock);
 	list_for_each_entry(cxt, &task_context_list, list) {
 		if (cxt->profile)
-			aa_switch_to_profile(cxt, NULL, 0);
+			aa_change_profile(cxt, NULL, 0);
 	}
 	read_unlock(&task_context_list_lock);
 	spin_unlock_irqrestore(&cxt_lock, flags);
Index: b/security/apparmor/main.c
===================================================================
--- a/security/apparmor/main.c
+++ b/security/apparmor/main.c
@@ -759,7 +759,7 @@ int aa_fork(struct task_struct *task)
 		 * he new task would end up with an obsolete profile.
 		 */
 		spin_lock_irqsave(&cxt_lock, flags);
-		aa_switch_to_profile(newcxt, cxt->profile, cxt->hat_magic);
+		aa_change_profile(newcxt, cxt->profile, cxt->hat_magic);
 		spin_unlock_irqrestore(&cxt_lock, flags);
 
 		if (APPARMOR_COMPLAIN(cxt) &&
@@ -1000,7 +1000,7 @@ repeat:
 				((unsigned long)bprm->security | bprm_flags);
 		}
 
-		aa_switch_to_profile(cxt, newprofile, 0);
+		aa_change_profile(cxt, newprofile, 0);
 
 		if (complain && newprofile == null_complain_profile)
 			LOG_HINT(newprofile, GFP_ATOMIC, HINT_CHGPROF,
@@ -1030,7 +1030,7 @@ cleanup:
  * removing a profile from a aa_task_context.  Once the aa_task_context has
  * been removed from the aa_task_context_list, we are no longer racing other
  * writers. There may still be other readers so we must still use
- * aa_switch_to_profile to put the aa_task_context's reference safely.
+ * aa_change_profile to put the aa_task_context's reference safely.
  */
 void aa_release(struct task_struct *task)
 {
@@ -1039,7 +1039,7 @@ void aa_release(struct task_struct *task
 		task->security = NULL;
 
 		aa_task_context_list_remove(cxt);
-		aa_switch_to_profile(cxt, NULL, 0);
+		aa_change_profile(cxt, NULL, 0);
 
 		kfree(cxt);
 	}
@@ -1070,7 +1070,7 @@ static inline int do_change_hat(const ch
 	sub = __aa_find_profile(hat_name, &cxt->profile->parent->sub);
 	if (sub) {
 		/* change hat */
-		aa_switch_to_profile(cxt, sub, hat_magic);
+		aa_change_profile(cxt, sub, hat_magic);
 	} else {
 		if (APPARMOR_COMPLAIN(cxt)) {
 			LOG_HINT(cxt->profile, GFP_ATOMIC, HINT_UNKNOWN_HAT,
@@ -1098,8 +1098,7 @@ static inline int do_change_hat(const ch
 		 *
 		 * In learning mode, this allows us to learn about new hats.
 		 */
-		aa_switch_to_profile(cxt, cxt->profile->null_profile,
-				     hat_magic);
+		aa_change_profile(cxt, cxt->profile->null_profile, hat_magic);
 	}
 
 	return error;
@@ -1187,8 +1186,7 @@ int aa_change_hat(const char *hat_name, 
 				 * Got here via changehat(NULL, magic)
 				 * Return from subprofile, back to parent
 				 */
-				aa_switch_to_profile(cxt, cxt->profile->parent,
-						     0);
+				aa_change_profile(cxt, cxt->profile->parent, 0);
 			} else {
 				/*
 				 * Change to another (sibling) profile, and
Index: b/security/apparmor/module_interface.c
===================================================================
--- a/security/apparmor/module_interface.c
+++ b/security/apparmor/module_interface.c
@@ -61,10 +61,10 @@ static inline void task_replace(struct a
 		if (!nactive)
 			nactive = aa_dup_profile(new->null_profile);
 
-		aa_switch_to_profile(cxt, nactive, cxt->hat_magic);
+		aa_change_profile(cxt, nactive, cxt->hat_magic);
 		aa_put_profile(nactive);
 	} else
-		aa_switch_to_profile(cxt, new, cxt->hat_magic);
+		aa_change_profile(cxt, new, cxt->hat_magic);
 }
 
 static inline int aa_inbounds(struct aa_ext *e, size_t size)
@@ -522,7 +522,7 @@ ssize_t aa_file_prof_remove(const char *
 	list_for_each_entry(cxt, &task_context_list, list) {
 		if (cxt->profile && cxt->profile->parent == profile) {
 			spin_lock(&cxt_lock);
-			aa_switch_to_profile(cxt, NULL, 0);
+			aa_change_profile(cxt, NULL, 0);
 			spin_unlock(&cxt_lock);
 		}
 	}
Index: b/security/apparmor/procattr.c
===================================================================
--- a/security/apparmor/procattr.c
+++ b/security/apparmor/procattr.c
@@ -235,7 +235,7 @@ int aa_setprocattr_setprofile(struct tas
 				cxt->profile->parent->name,
 				cxt->profile->name);
 
-			aa_switch_to_profile(cxt, NULL, 0);
+			aa_change_profile(cxt, NULL, 0);
 		} else {
 			AA_WARN("%s: task %s(%d) "
 				"is already unconstrained\n",
@@ -308,7 +308,7 @@ int aa_setprocattr_setprofile(struct tas
 			cxt->profile ? cxt->profile->name : "unconstrained",
 			name);
 
-		aa_switch_to_profile(cxt, profile, 0);
+		aa_change_profile(cxt, profile, 0);
 		aa_put_profile(profile);
 	}
 
