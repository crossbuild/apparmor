From: Andreas Gruenbacher <agruen@suse.de>
Subject: Pass no useless nameidata to the create, lookup, and permission IOPs

The create, lookup, and permission inode operations are all passed a
full nameidata.  This is unfortunate because in nfsd and the mqueue
filesystem, we must instantiate a struct nameidata but cannot provide
all of the same information that a regular lookup would provide.  The
unused there take up excess space on the stack, but more importantly, it
not obvious which fields have meaningful values and which don't, and so
things might easily break.

This patch introduces struct nameidata2 with only the fields that make
sense independent of an actual lookup, and uses that struct in those
places where a full nameidat is not needed.

Signed-off-by: Andreas Gruenbacher <agruen@suse.de>

---
 fs/9p/vfs_inode.c              |    4 ++--
 fs/adfs/dir.c                  |    2 +-
 fs/affs/affs.h                 |    4 ++--
 fs/affs/namei.c                |    4 ++--
 fs/afs/dir.c                   |    8 ++++----
 fs/afs/mntpt.c                 |    4 ++--
 fs/autofs/root.c               |    6 +++---
 fs/autofs4/root.c              |    8 ++++----
 fs/bad_inode.c                 |    6 +++---
 fs/befs/linuxvfs.c             |    4 ++--
 fs/bfs/dir.c                   |    4 ++--
 fs/cifs/cifsfs.c               |    2 +-
 fs/cifs/cifsfs.h               |    4 ++--
 fs/cifs/dir.c                  |    6 +++---
 fs/coda/dir.c                  |   14 +++++++-------
 fs/coda/pioctl.c               |    4 ++--
 fs/configfs/dir.c              |    2 +-
 fs/cramfs/inode.c              |    2 +-
 fs/ecryptfs/dentry.c           |    2 +-
 fs/ecryptfs/inode.c            |   10 +++++-----
 fs/efs/namei.c                 |    2 +-
 fs/exec.c                      |    8 ++++----
 fs/ext2/acl.c                  |    2 +-
 fs/ext2/acl.h                  |    2 +-
 fs/ext2/namei.c                |    4 ++--
 fs/ext3/acl.c                  |    2 +-
 fs/ext3/acl.h                  |    2 +-
 fs/ext3/namei.c                |    4 ++--
 fs/ext4/acl.c                  |    2 +-
 fs/ext4/acl.h                  |    2 +-
 fs/ext4/namei.c                |    4 ++--
 fs/freevxfs/vxfs_lookup.c      |    4 ++--
 fs/fuse/dir.c                  |   10 +++++-----
 fs/gfs2/inode.c                |    2 +-
 fs/gfs2/inode.h                |    2 +-
 fs/gfs2/ops_dentry.c           |    2 +-
 fs/gfs2/ops_inode.c            |    6 +++---
 fs/hfs/dir.c                   |    4 ++--
 fs/hfs/inode.c                 |    4 ++--
 fs/hfs/sysdep.c                |    2 +-
 fs/hfsplus/dir.c               |    4 ++--
 fs/hfsplus/inode.c             |    4 ++--
 fs/hpfs/dir.c                  |    2 +-
 fs/hpfs/hpfs_fn.h              |    2 +-
 fs/hpfs/namei.c                |    2 +-
 fs/hugetlbfs/inode.c           |    2 +-
 fs/inotify_user.c              |    2 +-
 fs/isofs/isofs.h               |    2 +-
 fs/isofs/namei.c               |    2 +-
 fs/jffs2/acl.c                 |    2 +-
 fs/jffs2/acl.h                 |    2 +-
 fs/jffs2/dir.c                 |    8 ++++----
 fs/jfs/acl.c                   |    2 +-
 fs/jfs/jfs_acl.h               |    2 +-
 fs/jfs/namei.c                 |    4 ++--
 fs/libfs.c                     |    2 +-
 fs/minix/namei.c               |    4 ++--
 fs/msdos/namei.c               |    4 ++--
 fs/namei.c                     |   39 ++++++++++++++++++++-------------------
 fs/ncpfs/dir.c                 |   14 +++++++-------
 fs/nfs/dir.c                   |   30 +++++++++++++++---------------
 fs/nfs/nfs3proc.c              |    2 +-
 fs/nfs/nfs4_fs.h               |    4 ++--
 fs/nfs/nfs4proc.c              |    8 ++++----
 fs/nfs/proc.c                  |    2 +-
 fs/nfsd/vfs.c                  |    2 +-
 fs/ntfs/namei.c                |    2 +-
 fs/ocfs2/dcache.c              |    2 +-
 fs/ocfs2/dlm/dlmfs.c           |    2 +-
 fs/ocfs2/file.c                |    2 +-
 fs/ocfs2/file.h                |    2 +-
 fs/ocfs2/namei.c               |    4 ++--
 fs/open.c                      |   13 +++++++------
 fs/proc/base.c                 |   18 +++++++++---------
 fs/proc/generic.c              |    2 +-
 fs/proc/proc_sysctl.c          |    6 +++---
 fs/proc/root.c                 |    2 +-
 fs/qnx4/namei.c                |    2 +-
 fs/ramfs/inode.c               |    2 +-
 fs/reiserfs/namei.c            |    4 ++--
 fs/reiserfs/xattr.c            |    2 +-
 fs/romfs/inode.c               |    2 +-
 fs/smbfs/dir.c                 |   12 ++++++------
 fs/smbfs/file.c                |    2 +-
 fs/sysfs/dir.c                 |    2 +-
 fs/sysv/namei.c                |    4 ++--
 fs/udf/namei.c                 |    4 ++--
 fs/ufs/namei.c                 |    4 ++--
 fs/utimes.c                    |    4 ++--
 fs/vfat/namei.c                |    6 +++---
 fs/xfs/linux-2.6/xfs_iops.c    |    6 +++---
 include/linux/coda_linux.h     |    2 +-
 include/linux/dcache.h         |    3 ++-
 include/linux/efs_fs.h         |    2 +-
 include/linux/fs.h             |   15 ++++++++-------
 include/linux/namei.h          |   37 +++++++++++++++++++++++++++----------
 include/linux/nfs_fs.h         |    2 +-
 include/linux/nfs_xdr.h        |    2 +-
 include/linux/proc_fs.h        |    4 ++--
 include/linux/qnx4_fs.h        |    2 +-
 include/linux/reiserfs_xattr.h |    2 +-
 include/linux/security.h       |    6 +++---
 include/linux/shmem_fs.h       |    2 +-
 ipc/mqueue.c                   |    4 ++--
 mm/shmem.c                     |    2 +-
 mm/shmem_acl.c                 |    2 +-
 security/apparmor/lsm.c        |    2 +-
 security/dummy.c               |    2 +-
 security/selinux/hooks.c       |    2 +-
 109 files changed, 274 insertions(+), 253 deletions(-)

--- a/fs/9p/vfs_inode.c
+++ b/fs/9p/vfs_inode.c
@@ -457,7 +457,7 @@ v9fs_open_created(struct inode *inode, s
 
 static int
 v9fs_vfs_create(struct inode *dir, struct dentry *dentry, int mode,
-		struct nameidata *nd)
+		struct nameidata2 *nd)
 {
 	int err;
 	u32 fid, perm, iounit;
@@ -615,7 +615,7 @@ error:
  */
 
 static struct dentry *v9fs_vfs_lookup(struct inode *dir, struct dentry *dentry,
-				      struct nameidata *nameidata)
+				      struct nameidata2 *nameidata)
 {
 	struct super_block *sb;
 	struct v9fs_session_info *v9ses;
--- a/fs/adfs/dir.c
+++ b/fs/adfs/dir.c
@@ -268,7 +268,7 @@ struct dentry_operations adfs_dentry_ope
 };
 
 static struct dentry *
-adfs_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nd)
+adfs_lookup(struct inode *dir, struct dentry *dentry, struct nameidata2 *nd)
 {
 	struct inode *inode = NULL;
 	struct object_info obj;
--- a/fs/affs/affs.h
+++ b/fs/affs/affs.h
@@ -153,9 +153,9 @@ extern void	affs_free_bitmap(struct supe
 /* namei.c */
 
 extern int	affs_hash_name(struct super_block *sb, const u8 *name, unsigned int len);
-extern struct dentry *affs_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *);
+extern struct dentry *affs_lookup(struct inode *dir, struct dentry *dentry, struct nameidata2 *);
 extern int	affs_unlink(struct inode *dir, struct dentry *dentry);
-extern int	affs_create(struct inode *dir, struct dentry *dentry, int mode, struct nameidata *);
+extern int	affs_create(struct inode *dir, struct dentry *dentry, int mode, struct nameidata2 *);
 extern int	affs_mkdir(struct inode *dir, struct dentry *dentry, int mode);
 extern int	affs_rmdir(struct inode *dir, struct dentry *dentry);
 extern int	affs_link(struct dentry *olddentry, struct inode *dir,
--- a/fs/affs/namei.c
+++ b/fs/affs/namei.c
@@ -197,7 +197,7 @@ affs_find_entry(struct inode *dir, struc
 }
 
 struct dentry *
-affs_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nd)
+affs_lookup(struct inode *dir, struct dentry *dentry, struct nameidata2 *nd)
 {
 	struct super_block *sb = dir->i_sb;
 	struct buffer_head *bh;
@@ -243,7 +243,7 @@ affs_unlink(struct inode *dir, struct de
 }
 
 int
-affs_create(struct inode *dir, struct dentry *dentry, int mode, struct nameidata *nd)
+affs_create(struct inode *dir, struct dentry *dentry, int mode, struct nameidata2 *nd)
 {
 	struct super_block *sb = dir->i_sb;
 	struct inode	*inode;
--- a/fs/afs/dir.c
+++ b/fs/afs/dir.c
@@ -23,10 +23,10 @@
 #include "internal.h"
 
 static struct dentry *afs_dir_lookup(struct inode *dir, struct dentry *dentry,
-				     struct nameidata *nd);
+				     struct nameidata2 *nd);
 static int afs_dir_open(struct inode *inode, struct file *file);
 static int afs_dir_readdir(struct file *file, void *dirent, filldir_t filldir);
-static int afs_d_revalidate(struct dentry *dentry, struct nameidata *nd);
+static int afs_d_revalidate(struct dentry *dentry, struct nameidata2 *nd);
 static int afs_d_delete(struct dentry *dentry);
 static int afs_dir_lookup_filldir(void *_cookie, const char *name, int nlen,
 				  loff_t fpos, u64 ino, unsigned dtype);
@@ -433,7 +433,7 @@ static int afs_dir_lookup_filldir(void *
  * look up an entry in a directory
  */
 static struct dentry *afs_dir_lookup(struct inode *dir, struct dentry *dentry,
-				     struct nameidata *nd)
+				     struct nameidata2 *nd)
 {
 	struct afs_dir_lookup_cookie cookie;
 	struct afs_super_info *as;
@@ -507,7 +507,7 @@ static struct dentry *afs_dir_lookup(str
  *   inode
  * (derived from nfs_lookup_revalidate)
  */
-static int afs_d_revalidate(struct dentry *dentry, struct nameidata *nd)
+static int afs_d_revalidate(struct dentry *dentry, struct nameidata2 *nd)
 {
 	struct afs_dir_lookup_cookie cookie;
 	struct dentry *parent;
--- a/fs/afs/mntpt.c
+++ b/fs/afs/mntpt.c
@@ -27,7 +27,7 @@
 
 static struct dentry *afs_mntpt_lookup(struct inode *dir,
 				       struct dentry *dentry,
-				       struct nameidata *nd);
+				       struct nameidata2 *nd);
 static int afs_mntpt_open(struct inode *inode, struct file *file);
 static void *afs_mntpt_follow_link(struct dentry *dentry, struct nameidata *nd);
 
@@ -114,7 +114,7 @@ int afs_mntpt_check_symlink(struct afs_v
  */
 static struct dentry *afs_mntpt_lookup(struct inode *dir,
 				       struct dentry *dentry,
-				       struct nameidata *nd)
+				       struct nameidata2 *nd)
 {
 	kenter("%p,%p{%p{%s},%s}",
 	       dir,
--- a/fs/autofs/root.c
+++ b/fs/autofs/root.c
@@ -19,7 +19,7 @@
 #include "autofs_i.h"
 
 static int autofs_root_readdir(struct file *,void *,filldir_t);
-static struct dentry *autofs_root_lookup(struct inode *,struct dentry *, struct nameidata *);
+static struct dentry *autofs_root_lookup(struct inode *,struct dentry *, struct nameidata2 *);
 static int autofs_root_symlink(struct inode *,struct dentry *,const char *);
 static int autofs_root_unlink(struct inode *,struct dentry *);
 static int autofs_root_rmdir(struct inode *,struct dentry *);
@@ -145,7 +145,7 @@ static int try_to_fill_dentry(struct den
  * yet completely filled in, and revalidate has to delay such
  * lookups..
  */
-static int autofs_revalidate(struct dentry * dentry, struct nameidata *nd)
+static int autofs_revalidate(struct dentry * dentry, struct nameidata2 *nd)
 {
 	struct inode * dir;
 	struct autofs_sb_info *sbi;
@@ -196,7 +196,7 @@ static struct dentry_operations autofs_d
 	.d_revalidate	= autofs_revalidate,
 };
 
-static struct dentry *autofs_root_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nd)
+static struct dentry *autofs_root_lookup(struct inode *dir, struct dentry *dentry, struct nameidata2 *nd)
 {
 	struct autofs_sb_info *sbi;
 	int oz_mode;
--- a/fs/autofs4/root.c
+++ b/fs/autofs4/root.c
@@ -29,7 +29,7 @@ static int autofs4_dir_open(struct inode
 static int autofs4_dir_close(struct inode *inode, struct file *file);
 static int autofs4_dir_readdir(struct file * filp, void * dirent, filldir_t filldir);
 static int autofs4_root_readdir(struct file * filp, void * dirent, filldir_t filldir);
-static struct dentry *autofs4_lookup(struct inode *,struct dentry *, struct nameidata *);
+static struct dentry *autofs4_lookup(struct inode *,struct dentry *, struct nameidata2 *);
 static void *autofs4_follow_link(struct dentry *, struct nameidata *);
 
 const struct file_operations autofs4_root_operations = {
@@ -123,7 +123,7 @@ static int autofs4_dir_open(struct inode
 
 	status = -ENOENT;
 	if (!d_mountpoint(dentry) && dentry->d_op && dentry->d_op->d_revalidate) {
-		struct nameidata nd;
+		struct nameidata2 nd;
 		int empty, ret;
 
 		/* In case there are stale directory dentrys from a failed mount */
@@ -393,7 +393,7 @@ out_error:
  * yet completely filled in, and revalidate has to delay such
  * lookups..
  */
-static int autofs4_revalidate(struct dentry *dentry, struct nameidata *nd)
+static int autofs4_revalidate(struct dentry *dentry, struct nameidata2 *nd)
 {
 	struct inode *dir = dentry->d_parent->d_inode;
 	struct autofs_sb_info *sbi = autofs4_sbi(dir->i_sb);
@@ -566,7 +566,7 @@ next:
 }
 
 /* Lookups in the root directory */
-static struct dentry *autofs4_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nd)
+static struct dentry *autofs4_lookup(struct inode *dir, struct dentry *dentry, struct nameidata2 *nd)
 {
 	struct autofs_sb_info *sbi;
 	struct dentry *unhashed;
--- a/fs/bad_inode.c
+++ b/fs/bad_inode.c
@@ -194,13 +194,13 @@ static const struct file_operations bad_
 };
 
 static int bad_inode_create (struct inode *dir, struct dentry *dentry,
-		int mode, struct nameidata *nd)
+		int mode, struct nameidata2 *nd)
 {
 	return -EIO;
 }
 
 static struct dentry *bad_inode_lookup(struct inode *dir,
-			struct dentry *dentry, struct nameidata *nd)
+			struct dentry *dentry, struct nameidata2 *nd)
 {
 	return ERR_PTR(-EIO);
 }
@@ -252,7 +252,7 @@ static int bad_inode_readlink(struct den
 }
 
 static int bad_inode_permission(struct inode *inode, int mask,
-			struct nameidata *nd)
+			struct nameidata2 *nd)
 {
 	return -EIO;
 }
--- a/fs/befs/linuxvfs.c
+++ b/fs/befs/linuxvfs.c
@@ -34,7 +34,7 @@ static int befs_readdir(struct file *, v
 static int befs_get_block(struct inode *, sector_t, struct buffer_head *, int);
 static int befs_readpage(struct file *file, struct page *page);
 static sector_t befs_bmap(struct address_space *mapping, sector_t block);
-static struct dentry *befs_lookup(struct inode *, struct dentry *, struct nameidata *);
+static struct dentry *befs_lookup(struct inode *, struct dentry *, struct nameidata2 *);
 static void befs_read_inode(struct inode *ino);
 static struct inode *befs_alloc_inode(struct super_block *sb);
 static void befs_destroy_inode(struct inode *inode);
@@ -159,7 +159,7 @@ befs_get_block(struct inode *inode, sect
 }
 
 static struct dentry *
-befs_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nd)
+befs_lookup(struct inode *dir, struct dentry *dentry, struct nameidata2 *nd)
 {
 	struct inode *inode = NULL;
 	struct super_block *sb = dir->i_sb;
--- a/fs/bfs/dir.c
+++ b/fs/bfs/dir.c
@@ -79,7 +79,7 @@ const struct file_operations bfs_dir_ope
 extern void dump_imap(const char *, struct super_block *);
 
 static int bfs_create(struct inode * dir, struct dentry * dentry, int mode,
-		struct nameidata *nd)
+		struct nameidata2 *nd)
 {
 	int err;
 	struct inode * inode;
@@ -127,7 +127,7 @@ static int bfs_create(struct inode * dir
 	return 0;
 }
 
-static struct dentry * bfs_lookup(struct inode * dir, struct dentry * dentry, struct nameidata *nd)
+static struct dentry * bfs_lookup(struct inode * dir, struct dentry * dentry, struct nameidata2 *nd)
 {
 	struct inode * inode = NULL;
 	struct buffer_head * bh;
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -227,7 +227,7 @@ cifs_statfs(struct dentry *dentry, struc
 				   longer available? */
 }
 
-static int cifs_permission(struct inode * inode, int mask, struct nameidata *nd)
+static int cifs_permission(struct inode * inode, int mask, struct nameidata2 *nd)
 {
 	struct cifs_sb_info *cifs_sb;
 
--- a/fs/cifs/cifsfs.h
+++ b/fs/cifs/cifsfs.h
@@ -44,9 +44,9 @@ extern void cifs_read_inode(struct inode
 /* Functions related to inodes */
 extern const struct inode_operations cifs_dir_inode_ops;
 extern int cifs_create(struct inode *, struct dentry *, int, 
-		       struct nameidata *);
+		       struct nameidata2 *);
 extern struct dentry * cifs_lookup(struct inode *, struct dentry *,
-				  struct nameidata *);
+				  struct nameidata2 *);
 extern int cifs_unlink(struct inode *, struct dentry *);
 extern int cifs_hardlink(struct dentry *, struct inode *, struct dentry *);
 extern int cifs_mknod(struct inode *, struct dentry *, int, dev_t);
--- a/fs/cifs/dir.c
+++ b/fs/cifs/dir.c
@@ -124,7 +124,7 @@ BB remove above eight lines BB */
 
 int
 cifs_create(struct inode *inode, struct dentry *direntry, int mode,
-		struct nameidata *nd)
+		struct nameidata2 *nd)
 {
 	int rc = -ENOENT;
 	int xid;
@@ -432,7 +432,7 @@ int cifs_mknod(struct inode *inode, stru
 
 
 struct dentry *
-cifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry, struct nameidata *nd)
+cifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry, struct nameidata2 *nd)
 {
 	int xid;
 	int rc = 0; /* to get around spurious gcc warning, set to zero here */
@@ -527,7 +527,7 @@ cifs_lookup(struct inode *parent_dir_ino
 }
 
 static int
-cifs_d_revalidate(struct dentry *direntry, struct nameidata *nd)
+cifs_d_revalidate(struct dentry *direntry, struct nameidata2 *nd)
 {
 	int isValid = 1;
 
--- a/fs/coda/dir.c
+++ b/fs/coda/dir.c
@@ -30,8 +30,8 @@
 #include "coda_int.h"
 
 /* dir inode-ops */
-static int coda_create(struct inode *dir, struct dentry *new, int mode, struct nameidata *nd);
-static struct dentry *coda_lookup(struct inode *dir, struct dentry *target, struct nameidata *nd);
+static int coda_create(struct inode *dir, struct dentry *new, int mode, struct nameidata2 *nd);
+static struct dentry *coda_lookup(struct inode *dir, struct dentry *target, struct nameidata2 *nd);
 static int coda_link(struct dentry *old_dentry, struct inode *dir_inode, 
 		     struct dentry *entry);
 static int coda_unlink(struct inode *dir_inode, struct dentry *entry);
@@ -46,7 +46,7 @@ static int coda_rename(struct inode *old
 static int coda_readdir(struct file *file, void *dirent, filldir_t filldir);
 
 /* dentry ops */
-static int coda_dentry_revalidate(struct dentry *de, struct nameidata *nd);
+static int coda_dentry_revalidate(struct dentry *de, struct nameidata2 *nd);
 static int coda_dentry_delete(struct dentry *);
 
 /* support routines */
@@ -95,7 +95,7 @@ const struct file_operations coda_dir_op
 
 /* inode operations for directories */
 /* access routines: lookup, readlink, permission */
-static struct dentry *coda_lookup(struct inode *dir, struct dentry *entry, struct nameidata *nd)
+static struct dentry *coda_lookup(struct inode *dir, struct dentry *entry, struct nameidata2 *nd)
 {
 	struct inode *res_inode = NULL;
 	struct CodaFid resfid = { { 0, } };
@@ -152,7 +152,7 @@ exit:
 }
 
 
-int coda_permission(struct inode *inode, int mask, struct nameidata *nd)
+int coda_permission(struct inode *inode, int mask, struct nameidata2 *nd)
 {
         int error = 0;
  
@@ -195,7 +195,7 @@ static inline void coda_dir_changed(stru
 }
 
 /* creation routines: create, mknod, mkdir, link, symlink */
-static int coda_create(struct inode *dir, struct dentry *de, int mode, struct nameidata *nd)
+static int coda_create(struct inode *dir, struct dentry *de, int mode, struct nameidata2 *nd)
 {
         int error=0;
 	const char *name=de->d_name.name;
@@ -590,7 +590,7 @@ static int coda_venus_readdir(struct fil
 }
 
 /* called when a cache lookup succeeds */
-static int coda_dentry_revalidate(struct dentry *de, struct nameidata *nd)
+static int coda_dentry_revalidate(struct dentry *de, struct nameidata2 *nd)
 {
 	struct inode *inode = de->d_inode;
 	struct coda_inode_info *cii;
--- a/fs/coda/pioctl.c
+++ b/fs/coda/pioctl.c
@@ -25,7 +25,7 @@
 
 /* pioctl ops */
 static int coda_ioctl_permission(struct inode *inode, int mask,
-				 struct nameidata *nd);
+				 struct nameidata2 *nd);
 static int coda_pioctl(struct inode * inode, struct file * filp, 
                        unsigned int cmd, unsigned long user_data);
 
@@ -43,7 +43,7 @@ const struct file_operations coda_ioctl_
 
 /* the coda pioctl inode ops */
 static int coda_ioctl_permission(struct inode *inode, int mask,
-				 struct nameidata *nd)
+				 struct nameidata2 *nd)
 {
         return 0;
 }
--- a/fs/configfs/dir.c
+++ b/fs/configfs/dir.c
@@ -297,7 +297,7 @@ static int configfs_attach_attr(struct c
 
 static struct dentry * configfs_lookup(struct inode *dir,
 				       struct dentry *dentry,
-				       struct nameidata *nd)
+				       struct nameidata2 *nd)
 {
 	struct configfs_dirent * parent_sd = dentry->d_parent->d_fsdata;
 	struct configfs_dirent * sd;
--- a/fs/cramfs/inode.c
+++ b/fs/cramfs/inode.c
@@ -404,7 +404,7 @@ static int cramfs_readdir(struct file *f
 /*
  * Lookup and fill in the inode data..
  */
-static struct dentry * cramfs_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nd)
+static struct dentry * cramfs_lookup(struct inode *dir, struct dentry *dentry, struct nameidata2 *nd)
 {
 	unsigned int offset = 0;
 	int sorted;
--- a/fs/ecryptfs/dentry.c
+++ b/fs/ecryptfs/dentry.c
@@ -41,7 +41,7 @@
  * Returns 1 if valid, 0 otherwise.
  *
  */
-static int ecryptfs_d_revalidate(struct dentry *dentry, struct nameidata *nd)
+static int ecryptfs_d_revalidate(struct dentry *dentry, struct nameidata2 *nd)
 {
 	struct dentry *lower_dentry = ecryptfs_dentry_to_lower(dentry);
 	struct vfsmount *lower_mnt = ecryptfs_dentry_to_lower_mnt(dentry);
--- a/fs/ecryptfs/inode.c
+++ b/fs/ecryptfs/inode.c
@@ -69,7 +69,7 @@ static void unlock_dir(struct dentry *di
 static int
 ecryptfs_create_underlying_file(struct inode *lower_dir_inode,
 				struct dentry *dentry, int mode,
-				struct nameidata *nd)
+				struct nameidata2 *nd)
 {
 	struct dentry *lower_dentry = ecryptfs_dentry_to_lower(dentry);
 	struct vfsmount *lower_mnt = ecryptfs_dentry_to_lower_mnt(dentry);
@@ -103,7 +103,7 @@ ecryptfs_create_underlying_file(struct i
 static int
 ecryptfs_do_create(struct inode *directory_inode,
 		   struct dentry *ecryptfs_dentry, int mode,
-		   struct nameidata *nd)
+		   struct nameidata2 *nd)
 {
 	int rc;
 	struct dentry *lower_dentry;
@@ -248,7 +248,7 @@ out:
  */
 static int
 ecryptfs_create(struct inode *directory_inode, struct dentry *ecryptfs_dentry,
-		int mode, struct nameidata *nd)
+		int mode, struct nameidata2 *nd)
 {
 	int rc;
 
@@ -275,7 +275,7 @@ out:
  * dentry cache and continue on to read it from the disk.
  */
 static struct dentry *ecryptfs_lookup(struct inode *dir, struct dentry *dentry,
-				      struct nameidata *nd)
+				      struct nameidata2 *nd)
 {
 	int rc = 0;
 	struct dentry *lower_dir_dentry;
@@ -857,7 +857,7 @@ out:
 }
 
 static int
-ecryptfs_permission(struct inode *inode, int mask, struct nameidata *nd)
+ecryptfs_permission(struct inode *inode, int mask, struct nameidata2 *nd)
 {
 	int rc;
 
--- a/fs/efs/namei.c
+++ b/fs/efs/namei.c
@@ -57,7 +57,7 @@ static efs_ino_t efs_find_entry(struct i
 	return(0);
 }
 
-struct dentry *efs_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nd) {
+struct dentry *efs_lookup(struct inode *dir, struct dentry *dentry, struct nameidata2 *nd) {
 	efs_ino_t inodenum;
 	struct inode * inode = NULL;
 
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -136,7 +136,7 @@ asmlinkage long sys_uselib(const char __
 	if (!S_ISREG(nd.dentry->d_inode->i_mode))
 		goto exit;
 
-	error = vfs_permission(&nd, MAY_READ | MAY_EXEC);
+	error = vfs_permission(ND2(&nd), MAY_READ | MAY_EXEC);
 	if (error)
 		goto exit;
 
@@ -168,7 +168,7 @@ asmlinkage long sys_uselib(const char __
 out:
   	return error;
 exit:
-	release_open_intent(&nd);
+	release_open_intent(ND2(&nd));
 	path_release(&nd);
 	goto out;
 }
@@ -484,7 +484,7 @@ struct file *open_exec(const char *name)
 		file = ERR_PTR(-EACCES);
 		if (!(nd.mnt->mnt_flags & MNT_NOEXEC) &&
 		    S_ISREG(inode->i_mode)) {
-			int err = vfs_permission(&nd, MAY_EXEC);
+			int err = vfs_permission(ND2(&nd), MAY_EXEC);
 			file = ERR_PTR(err);
 			if (!err) {
 				file = nameidata_to_filp(&nd, O_RDONLY);
@@ -499,7 +499,7 @@ out:
 				return file;
 			}
 		}
-		release_open_intent(&nd);
+		release_open_intent(ND2(&nd));
 		path_release(&nd);
 	}
 	goto out;
--- a/fs/ext2/acl.c
+++ b/fs/ext2/acl.c
@@ -294,7 +294,7 @@ ext2_check_acl(struct inode *inode, int 
 }
 
 int
-ext2_permission(struct inode *inode, int mask, struct nameidata *nd)
+ext2_permission(struct inode *inode, int mask, struct nameidata2 *nd)
 {
 	return generic_permission(inode, mask, ext2_check_acl);
 }
--- a/fs/ext2/acl.h
+++ b/fs/ext2/acl.h
@@ -58,7 +58,7 @@ static inline int ext2_acl_count(size_t 
 #define EXT2_ACL_NOT_CACHED ((void *)-1)
 
 /* acl.c */
-extern int ext2_permission (struct inode *, int, struct nameidata *);
+extern int ext2_permission (struct inode *, int, struct nameidata2 *);
 extern int ext2_acl_chmod (struct inode *);
 extern int ext2_init_acl (struct inode *, struct inode *);
 
--- a/fs/ext2/namei.c
+++ b/fs/ext2/namei.c
@@ -52,7 +52,7 @@ static inline int ext2_add_nondir(struct
  * Methods themselves.
  */
 
-static struct dentry *ext2_lookup(struct inode * dir, struct dentry *dentry, struct nameidata *nd)
+static struct dentry *ext2_lookup(struct inode * dir, struct dentry *dentry, struct nameidata2 *nd)
 {
 	struct inode * inode;
 	ino_t ino;
@@ -103,7 +103,7 @@ struct dentry *ext2_get_parent(struct de
  * If the create succeeds, we fill in the inode information
  * with d_instantiate(). 
  */
-static int ext2_create (struct inode * dir, struct dentry * dentry, int mode, struct nameidata *nd)
+static int ext2_create (struct inode * dir, struct dentry * dentry, int mode, struct nameidata2 *nd)
 {
 	struct inode * inode = ext2_new_inode (dir, mode);
 	int err = PTR_ERR(inode);
--- a/fs/ext3/acl.c
+++ b/fs/ext3/acl.c
@@ -299,7 +299,7 @@ ext3_check_acl(struct inode *inode, int 
 }
 
 int
-ext3_permission(struct inode *inode, int mask, struct nameidata *nd)
+ext3_permission(struct inode *inode, int mask, struct nameidata2 *nd)
 {
 	return generic_permission(inode, mask, ext3_check_acl);
 }
--- a/fs/ext3/acl.h
+++ b/fs/ext3/acl.h
@@ -58,7 +58,7 @@ static inline int ext3_acl_count(size_t 
 #define EXT3_ACL_NOT_CACHED ((void *)-1)
 
 /* acl.c */
-extern int ext3_permission (struct inode *, int, struct nameidata *);
+extern int ext3_permission (struct inode *, int, struct nameidata2 *);
 extern int ext3_acl_chmod (struct inode *);
 extern int ext3_init_acl (handle_t *, struct inode *, struct inode *);
 
--- a/fs/ext3/namei.c
+++ b/fs/ext3/namei.c
@@ -996,7 +996,7 @@ errout:
 }
 #endif
 
-static struct dentry *ext3_lookup(struct inode * dir, struct dentry *dentry, struct nameidata *nd)
+static struct dentry *ext3_lookup(struct inode * dir, struct dentry *dentry, struct nameidata2 *nd)
 {
 	struct inode * inode;
 	struct ext3_dir_entry_2 * de;
@@ -1641,7 +1641,7 @@ static int ext3_add_nondir(handle_t *han
  * with d_instantiate().
  */
 static int ext3_create (struct inode * dir, struct dentry * dentry, int mode,
-		struct nameidata *nd)
+		struct nameidata2 *nd)
 {
 	handle_t *handle;
 	struct inode * inode;
--- a/fs/ext4/acl.c
+++ b/fs/ext4/acl.c
@@ -299,7 +299,7 @@ ext4_check_acl(struct inode *inode, int 
 }
 
 int
-ext4_permission(struct inode *inode, int mask, struct nameidata *nd)
+ext4_permission(struct inode *inode, int mask, struct nameidata2 *nd)
 {
 	return generic_permission(inode, mask, ext4_check_acl);
 }
--- a/fs/ext4/acl.h
+++ b/fs/ext4/acl.h
@@ -58,7 +58,7 @@ static inline int ext4_acl_count(size_t 
 #define EXT4_ACL_NOT_CACHED ((void *)-1)
 
 /* acl.c */
-extern int ext4_permission (struct inode *, int, struct nameidata *);
+extern int ext4_permission (struct inode *, int, struct nameidata2 *);
 extern int ext4_acl_chmod (struct inode *);
 extern int ext4_init_acl (handle_t *, struct inode *, struct inode *);
 
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@ -994,7 +994,7 @@ errout:
 }
 #endif
 
-static struct dentry *ext4_lookup(struct inode * dir, struct dentry *dentry, struct nameidata *nd)
+static struct dentry *ext4_lookup(struct inode * dir, struct dentry *dentry, struct nameidata2 *nd)
 {
 	struct inode * inode;
 	struct ext4_dir_entry_2 * de;
@@ -1639,7 +1639,7 @@ static int ext4_add_nondir(handle_t *han
  * with d_instantiate().
  */
 static int ext4_create (struct inode * dir, struct dentry * dentry, int mode,
-		struct nameidata *nd)
+		struct nameidata2 *nd)
 {
 	handle_t *handle;
 	struct inode * inode;
--- a/fs/freevxfs/vxfs_lookup.c
+++ b/fs/freevxfs/vxfs_lookup.c
@@ -49,7 +49,7 @@
 #define VXFS_BLOCK_PER_PAGE(sbp)  ((PAGE_CACHE_SIZE / (sbp)->s_blocksize))
 
 
-static struct dentry *	vxfs_lookup(struct inode *, struct dentry *, struct nameidata *);
+static struct dentry *	vxfs_lookup(struct inode *, struct dentry *, struct nameidata2 *);
 static int		vxfs_readdir(struct file *, void *, filldir_t);
 
 const struct inode_operations vxfs_dir_inode_ops = {
@@ -202,7 +202,7 @@ vxfs_inode_by_name(struct inode *dip, st
  *   in the return pointer.
  */
 static struct dentry *
-vxfs_lookup(struct inode *dip, struct dentry *dp, struct nameidata *nd)
+vxfs_lookup(struct inode *dip, struct dentry *dp, struct nameidata2 *nd)
 {
 	struct inode		*ip = NULL;
 	ino_t			ino;
--- a/fs/fuse/dir.c
+++ b/fs/fuse/dir.c
@@ -127,7 +127,7 @@ static void fuse_lookup_init(struct fuse
  * the lookup once more.  If the lookup results in the same inode,
  * then refresh the attributes, timeouts and mark the dentry valid.
  */
-static int fuse_dentry_revalidate(struct dentry *entry, struct nameidata *nd)
+static int fuse_dentry_revalidate(struct dentry *entry, struct nameidata2 *nd)
 {
 	struct inode *inode = entry->d_inode;
 
@@ -220,7 +220,7 @@ static int fuse_d_add_directory(struct d
 }
 
 static struct dentry *fuse_lookup(struct inode *dir, struct dentry *entry,
-				  struct nameidata *nd)
+				  struct nameidata2 *nd)
 {
 	int err;
 	struct fuse_entry_out outarg;
@@ -303,7 +303,7 @@ static void fuse_sync_release(struct fus
  * 'mknod' + 'open' requests.
  */
 static int fuse_create_open(struct inode *dir, struct dentry *entry, int mode,
-			    struct nameidata *nd)
+			    struct nameidata2 *nd)
 {
 	int err;
 	struct inode *inode;
@@ -483,7 +483,7 @@ static int fuse_mknod(struct inode *dir,
 }
 
 static int fuse_create(struct inode *dir, struct dentry *entry, int mode,
-		       struct nameidata *nd)
+		       struct nameidata2 *nd)
 {
 	if (nd && (nd->flags & LOOKUP_CREATE)) {
 		int err = fuse_create_open(dir, entry, mode, nd);
@@ -792,7 +792,7 @@ static int fuse_access(struct inode *ino
  * access request is sent.  Execute permission is still checked
  * locally based on file mode.
  */
-static int fuse_permission(struct inode *inode, int mask, struct nameidata *nd)
+static int fuse_permission(struct inode *inode, int mask, struct nameidata2 *nd)
 {
 	struct fuse_conn *fc = get_fuse_conn(inode);
 
--- a/fs/gfs2/inode.c
+++ b/fs/gfs2/inode.c
@@ -361,7 +361,7 @@ struct inode *gfs2_lookup_simple(struct 
  */
 
 struct inode *gfs2_lookupi(struct inode *dir, const struct qstr *name,
-			   int is_root, struct nameidata *nd)
+			   int is_root, struct nameidata2 *nd)
 {
 	struct super_block *sb = dir->i_sb;
 	struct gfs2_inode *dip = GFS2_I(dir);
--- a/fs/gfs2/inode.h
+++ b/fs/gfs2/inode.h
@@ -41,7 +41,7 @@ int gfs2_inode_refresh(struct gfs2_inode
 int gfs2_dinode_dealloc(struct gfs2_inode *inode);
 int gfs2_change_nlink(struct gfs2_inode *ip, int diff);
 struct inode *gfs2_lookupi(struct inode *dir, const struct qstr *name,
-			   int is_root, struct nameidata *nd);
+			   int is_root, struct nameidata2 *nd);
 struct inode *gfs2_createi(struct gfs2_holder *ghs, const struct qstr *name,
 			   unsigned int mode, dev_t dev);
 int gfs2_rmdiri(struct gfs2_inode *dip, const struct qstr *name,
--- a/fs/gfs2/ops_dentry.c
+++ b/fs/gfs2/ops_dentry.c
@@ -34,7 +34,7 @@
  * Returns: 1 if the dentry is ok, 0 if it isn't
  */
 
-static int gfs2_drevalidate(struct dentry *dentry, struct nameidata *nd)
+static int gfs2_drevalidate(struct dentry *dentry, struct nameidata2 *nd)
 {
 	struct dentry *parent = dget_parent(dentry);
 	struct gfs2_sbd *sdp = GFS2_SB(parent->d_inode);
--- a/fs/gfs2/ops_inode.c
+++ b/fs/gfs2/ops_inode.c
@@ -48,7 +48,7 @@
  */
 
 static int gfs2_create(struct inode *dir, struct dentry *dentry,
-		       int mode, struct nameidata *nd)
+		       int mode, struct nameidata2 *nd)
 {
 	struct gfs2_inode *dip = GFS2_I(dir);
 	struct gfs2_sbd *sdp = GFS2_SB(dir);
@@ -103,7 +103,7 @@ static int gfs2_create(struct inode *dir
  */
 
 static struct dentry *gfs2_lookup(struct inode *dir, struct dentry *dentry,
-				  struct nameidata *nd)
+				  struct nameidata2 *nd)
 {
 	struct inode *inode = NULL;
 
@@ -872,7 +872,7 @@ static void *gfs2_follow_link(struct den
  * Returns: errno
  */
 
-static int gfs2_permission(struct inode *inode, int mask, struct nameidata *nd)
+static int gfs2_permission(struct inode *inode, int mask, struct nameidata2 *nd)
 {
 	struct gfs2_inode *ip = GFS2_I(inode);
 	struct gfs2_holder i_gh;
--- a/fs/hfs/dir.c
+++ b/fs/hfs/dir.c
@@ -18,7 +18,7 @@
  * hfs_lookup()
  */
 static struct dentry *hfs_lookup(struct inode *dir, struct dentry *dentry,
-				 struct nameidata *nd)
+				 struct nameidata2 *nd)
 {
 	hfs_cat_rec rec;
 	struct hfs_find_data fd;
@@ -178,7 +178,7 @@ static int hfs_dir_release(struct inode 
  * the directory and the name (and its length) of the new file.
  */
 static int hfs_create(struct inode *dir, struct dentry *dentry, int mode,
-		      struct nameidata *nd)
+		      struct nameidata2 *nd)
 {
 	struct inode *inode;
 	int res;
--- a/fs/hfs/inode.c
+++ b/fs/hfs/inode.c
@@ -458,7 +458,7 @@ out:
 }
 
 static struct dentry *hfs_file_lookup(struct inode *dir, struct dentry *dentry,
-				      struct nameidata *nd)
+				      struct nameidata2 *nd)
 {
 	struct inode *inode = NULL;
 	hfs_cat_rec rec;
@@ -507,7 +507,7 @@ void hfs_clear_inode(struct inode *inode
 }
 
 static int hfs_permission(struct inode *inode, int mask,
-			  struct nameidata *nd)
+			  struct nameidata2 *nd)
 {
 	if (S_ISREG(inode->i_mode) && mask & MAY_EXEC)
 		return 0;
--- a/fs/hfs/sysdep.c
+++ b/fs/hfs/sysdep.c
@@ -12,7 +12,7 @@
 
 /* dentry case-handling: just lowercase everything */
 
-static int hfs_revalidate_dentry(struct dentry *dentry, struct nameidata *nd)
+static int hfs_revalidate_dentry(struct dentry *dentry, struct nameidata2 *nd)
 {
 	struct inode *inode = dentry->d_inode;
 	int diff;
--- a/fs/hfsplus/dir.c
+++ b/fs/hfsplus/dir.c
@@ -25,7 +25,7 @@ static inline void hfsplus_instantiate(s
 
 /* Find the entry inside dir named dentry->d_name */
 static struct dentry *hfsplus_lookup(struct inode *dir, struct dentry *dentry,
-				     struct nameidata *nd)
+				     struct nameidata2 *nd)
 {
 	struct inode *inode = NULL;
 	struct hfs_find_data fd;
@@ -234,7 +234,7 @@ static int hfsplus_dir_release(struct in
 }
 
 static int hfsplus_create(struct inode *dir, struct dentry *dentry, int mode,
-			  struct nameidata *nd)
+			  struct nameidata2 *nd)
 {
 	struct inode *inode;
 	int res;
--- a/fs/hfsplus/inode.c
+++ b/fs/hfsplus/inode.c
@@ -131,7 +131,7 @@ const struct address_space_operations hf
 };
 
 static struct dentry *hfsplus_file_lookup(struct inode *dir, struct dentry *dentry,
-					  struct nameidata *nd)
+					  struct nameidata2 *nd)
 {
 	struct hfs_find_data fd;
 	struct super_block *sb = dir->i_sb;
@@ -226,7 +226,7 @@ static void hfsplus_set_perms(struct ino
 	perms->dev = cpu_to_be32(HFSPLUS_I(inode).dev);
 }
 
-static int hfsplus_permission(struct inode *inode, int mask, struct nameidata *nd)
+static int hfsplus_permission(struct inode *inode, int mask, struct nameidata2 *nd)
 {
 	/* MAY_EXEC is also used for lookup, if no x bit is set allow lookup,
 	 * open_exec has the same test, so it's still not executable, if a x bit
--- a/fs/hpfs/dir.c
+++ b/fs/hpfs/dir.c
@@ -184,7 +184,7 @@ out:
  *	      to tell read_inode to read fnode or not.
  */
 
-struct dentry *hpfs_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nd)
+struct dentry *hpfs_lookup(struct inode *dir, struct dentry *dentry, struct nameidata2 *nd)
 {
 	const char *name = dentry->d_name.name;
 	unsigned len = dentry->d_name.len;
--- a/fs/hpfs/hpfs_fn.h
+++ b/fs/hpfs/hpfs_fn.h
@@ -238,7 +238,7 @@ void hpfs_set_dentry_operations(struct d
 
 /* dir.c */
 
-struct dentry *hpfs_lookup(struct inode *, struct dentry *, struct nameidata *);
+struct dentry *hpfs_lookup(struct inode *, struct dentry *, struct nameidata2 *);
 extern const struct file_operations hpfs_dir_ops;
 
 /* dnode.c */
--- a/fs/hpfs/namei.c
+++ b/fs/hpfs/namei.c
@@ -118,7 +118,7 @@ bail:
 	return err;
 }
 
-static int hpfs_create(struct inode *dir, struct dentry *dentry, int mode, struct nameidata *nd)
+static int hpfs_create(struct inode *dir, struct dentry *dentry, int mode, struct nameidata2 *nd)
 {
 	const char *name = dentry->d_name.name;
 	unsigned len = dentry->d_name.len;
--- a/fs/hugetlbfs/inode.c
+++ b/fs/hugetlbfs/inode.c
@@ -415,7 +415,7 @@ static int hugetlbfs_mkdir(struct inode 
 	return retval;
 }
 
-static int hugetlbfs_create(struct inode *dir, struct dentry *dentry, int mode, struct nameidata *nd)
+static int hugetlbfs_create(struct inode *dir, struct dentry *dentry, int mode, struct nameidata2 *nd)
 {
 	return hugetlbfs_mknod(dir, dentry, mode | S_IFREG, 0);
 }
--- a/fs/inotify_user.c
+++ b/fs/inotify_user.c
@@ -349,7 +349,7 @@ static int find_inode(const char __user 
 	if (error)
 		return error;
 	/* you can only watch an inode if you have read permissions on it */
-	error = vfs_permission(nd, MAY_READ);
+	error = vfs_permission(ND2(nd), MAY_READ);
 	if (error)
 		path_release(nd);
 	return error;
--- a/fs/isofs/isofs.h
+++ b/fs/isofs/isofs.h
@@ -111,7 +111,7 @@ extern int isofs_name_translate(struct i
 int get_joliet_filename(struct iso_directory_record *, unsigned char *, struct inode *);
 int get_acorn_filename(struct iso_directory_record *, char *, struct inode *);
 
-extern struct dentry *isofs_lookup(struct inode *, struct dentry *, struct nameidata *);
+extern struct dentry *isofs_lookup(struct inode *, struct dentry *, struct nameidata2 *);
 extern struct buffer_head *isofs_bread(struct inode *, sector_t);
 extern int isofs_get_blocks(struct inode *, sector_t, struct buffer_head **, unsigned long);
 
--- a/fs/isofs/namei.c
+++ b/fs/isofs/namei.c
@@ -155,7 +155,7 @@ isofs_find_entry(struct inode *dir, stru
 	return 0;
 }
 
-struct dentry *isofs_lookup(struct inode * dir, struct dentry * dentry, struct nameidata *nd)
+struct dentry *isofs_lookup(struct inode * dir, struct dentry * dentry, struct nameidata2 *nd)
 {
 	int found;
 	unsigned long block, offset;
--- a/fs/jffs2/acl.c
+++ b/fs/jffs2/acl.c
@@ -301,7 +301,7 @@ static int jffs2_check_acl(struct inode 
 	return -EAGAIN;
 }
 
-int jffs2_permission(struct inode *inode, int mask, struct nameidata *nd)
+int jffs2_permission(struct inode *inode, int mask, struct nameidata2 *nd)
 {
 	return generic_permission(inode, mask, jffs2_check_acl);
 }
--- a/fs/jffs2/acl.h
+++ b/fs/jffs2/acl.h
@@ -27,7 +27,7 @@ struct jffs2_acl_header {
 
 #define JFFS2_ACL_NOT_CACHED ((void *)-1)
 
-extern int jffs2_permission(struct inode *, int, struct nameidata *);
+extern int jffs2_permission(struct inode *, int, struct nameidata2 *);
 extern int jffs2_acl_chmod(struct inode *);
 extern int jffs2_init_acl(struct inode *, struct inode *);
 extern void jffs2_clear_acl(struct jffs2_inode_info *);
--- a/fs/jffs2/dir.c
+++ b/fs/jffs2/dir.c
@@ -24,9 +24,9 @@
 static int jffs2_readdir (struct file *, void *, filldir_t);
 
 static int jffs2_create (struct inode *,struct dentry *,int,
-			 struct nameidata *);
+			 struct nameidata2 *);
 static struct dentry *jffs2_lookup (struct inode *,struct dentry *,
-				    struct nameidata *);
+				    struct nameidata2 *);
 static int jffs2_link (struct dentry *,struct inode *,struct dentry *);
 static int jffs2_unlink (struct inode *,struct dentry *);
 static int jffs2_symlink (struct inode *,struct dentry *,const char *);
@@ -72,7 +72,7 @@ const struct inode_operations jffs2_dir_
    nice and simple
 */
 static struct dentry *jffs2_lookup(struct inode *dir_i, struct dentry *target,
-				   struct nameidata *nd)
+				   struct nameidata2 *nd)
 {
 	struct jffs2_inode_info *dir_f;
 	struct jffs2_sb_info *c;
@@ -178,7 +178,7 @@ static int jffs2_readdir(struct file *fi
 
 
 static int jffs2_create(struct inode *dir_i, struct dentry *dentry, int mode,
-			struct nameidata *nd)
+			struct nameidata2 *nd)
 {
 	struct jffs2_raw_inode *ri;
 	struct jffs2_inode_info *f, *dir_f;
--- a/fs/jfs/acl.c
+++ b/fs/jfs/acl.c
@@ -140,7 +140,7 @@ static int jfs_check_acl(struct inode *i
 	return -EAGAIN;
 }
 
-int jfs_permission(struct inode *inode, int mask, struct nameidata *nd)
+int jfs_permission(struct inode *inode, int mask, struct nameidata2 *nd)
 {
 	return generic_permission(inode, mask, jfs_check_acl);
 }
--- a/fs/jfs/jfs_acl.h
+++ b/fs/jfs/jfs_acl.h
@@ -20,7 +20,7 @@
 
 #ifdef CONFIG_JFS_POSIX_ACL
 
-int jfs_permission(struct inode *, int, struct nameidata *);
+int jfs_permission(struct inode *, int, struct nameidata2 *);
 int jfs_init_acl(tid_t, struct inode *, struct inode *);
 int jfs_setattr(struct dentry *, struct iattr *);
 
--- a/fs/jfs/namei.c
+++ b/fs/jfs/namei.c
@@ -71,7 +71,7 @@ static inline void free_ea_wmap(struct i
  *
  */
 static int jfs_create(struct inode *dip, struct dentry *dentry, int mode,
-		struct nameidata *nd)
+		struct nameidata2 *nd)
 {
 	int rc = 0;
 	tid_t tid;		/* transaction id */
@@ -1428,7 +1428,7 @@ static int jfs_mknod(struct inode *dir, 
 	return rc;
 }
 
-static struct dentry *jfs_lookup(struct inode *dip, struct dentry *dentry, struct nameidata *nd)
+static struct dentry *jfs_lookup(struct inode *dip, struct dentry *dentry, struct nameidata2 *nd)
 {
 	struct btstack btstack;
 	ino_t inum;
--- a/fs/libfs.c
+++ b/fs/libfs.c
@@ -41,7 +41,7 @@ static int simple_delete_dentry(struct d
  * Lookup the data. This is trivial - if the dentry didn't already
  * exist, we know it is negative.  Set d_op to delete negative dentries.
  */
-struct dentry *simple_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nd)
+struct dentry *simple_lookup(struct inode *dir, struct dentry *dentry, struct nameidata2 *nd)
 {
 	static struct dentry_operations simple_dentry_operations = {
 		.d_delete = simple_delete_dentry,
--- a/fs/minix/namei.c
+++ b/fs/minix/namei.c
@@ -42,7 +42,7 @@ struct dentry_operations minix_dentry_op
 	.d_hash		= minix_hash,
 };
 
-static struct dentry *minix_lookup(struct inode * dir, struct dentry *dentry, struct nameidata *nd)
+static struct dentry *minix_lookup(struct inode * dir, struct dentry *dentry, struct nameidata2 *nd)
 {
 	struct inode * inode = NULL;
 	ino_t ino;
@@ -83,7 +83,7 @@ static int minix_mknod(struct inode * di
 }
 
 static int minix_create(struct inode * dir, struct dentry *dentry, int mode,
-		struct nameidata *nd)
+		struct nameidata2 *nd)
 {
 	return minix_mknod(dir, dentry, mode, 0);
 }
--- a/fs/msdos/namei.c
+++ b/fs/msdos/namei.c
@@ -205,7 +205,7 @@ static struct dentry_operations msdos_de
 
 /***** Get inode using directory and name */
 static struct dentry *msdos_lookup(struct inode *dir, struct dentry *dentry,
-				   struct nameidata *nd)
+				   struct nameidata2 *nd)
 {
 	struct super_block *sb = dir->i_sb;
 	struct fat_slot_info sinfo;
@@ -277,7 +277,7 @@ static int msdos_add_entry(struct inode 
 
 /***** Create a file */
 static int msdos_create(struct inode *dir, struct dentry *dentry, int mode,
-			struct nameidata *nd)
+			struct nameidata2 *nd)
 {
 	struct super_block *sb = dir->i_sb;
 	struct inode *inode = NULL;
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -225,7 +225,7 @@ int generic_permission(struct inode *ino
 	return -EACCES;
 }
 
-int permission(struct inode *inode, int mask, struct nameidata *nd)
+int permission(struct inode *inode, int mask, struct nameidata2 *nd)
 {
 	umode_t mode = inode->i_mode;
 	int retval, submask;
@@ -278,7 +278,7 @@ int permission(struct inode *inode, int 
  * for filesystem access without changing the "normal" uids which
  * are used for other things.
  */
-int vfs_permission(struct nameidata *nd, int mask)
+int vfs_permission(struct nameidata2 *nd, int mask)
 {
 	return permission(nd->dentry->d_inode, mask, nd);
 }
@@ -366,7 +366,7 @@ void path_release_on_umount(struct namei
  * release_open_intent - free up open intent resources
  * @nd: pointer to nameidata
  */
-void release_open_intent(struct nameidata *nd)
+void release_open_intent(struct nameidata2 *nd)
 {
 	if (nd->intent.open.file->f_path.dentry == NULL)
 		put_filp(nd->intent.open.file);
@@ -377,7 +377,7 @@ void release_open_intent(struct nameidat
 static inline struct dentry *
 do_revalidate(struct dentry *dentry, struct nameidata *nd)
 {
-	int status = dentry->d_op->d_revalidate(dentry, nd);
+	int status = dentry->d_op->d_revalidate(dentry, ND2(nd));
 	if (unlikely(status <= 0)) {
 		/*
 		 * The dentry failed validation.
@@ -455,7 +455,7 @@ static int exec_permission_lite(struct i
 
 	return -EACCES;
 ok:
-	return security_inode_permission(inode, MAY_EXEC, nd);
+	return security_inode_permission(inode, MAY_EXEC, ND2(nd));
 }
 
 /*
@@ -491,7 +491,7 @@ static struct dentry * real_lookup(struc
 		struct dentry * dentry = d_alloc(parent, name);
 		result = ERR_PTR(-ENOMEM);
 		if (dentry) {
-			result = dir->i_op->lookup(dir, dentry, nd);
+			result = dir->i_op->lookup(dir, dentry, ND2(nd));
 			if (result)
 				dput(dentry);
 			else
@@ -832,7 +832,7 @@ static fastcall int __link_path_walk(con
 		nd->flags |= LOOKUP_CONTINUE;
 		err = exec_permission_lite(inode, nd);
 		if (err == -EAGAIN)
-			err = vfs_permission(nd, MAY_EXEC);
+			err = vfs_permission(ND2(nd), MAY_EXEC);
  		if (err)
 			break;
 
@@ -978,7 +978,8 @@ return_reval:
 		    (nd->dentry->d_sb->s_type->fs_flags & FS_REVAL_DOT)) {
 			err = -ESTALE;
 			/* Note: we do not d_invalidate() */
-			if (!nd->dentry->d_op->d_revalidate(nd->dentry, nd))
+			if (!nd->dentry->d_op->d_revalidate(nd->dentry,
+							    ND2(nd)))
 				break;
 		}
 return_base:
@@ -1194,7 +1195,7 @@ static int __path_lookup_intent_open(int
 			path_release(nd);
 		}
 	} else if (err != 0)
-		release_open_intent(nd);
+		release_open_intent(ND2(nd));
 	return err;
 }
 
@@ -1255,7 +1256,7 @@ static struct dentry * __lookup_hash(str
 	int err;
 
 	inode = base->d_inode;
-	err = permission(inode, MAY_EXEC, nd);
+	err = permission(inode, MAY_EXEC, ND2(nd));
 	dentry = ERR_PTR(err);
 	if (err)
 		goto out;
@@ -1277,7 +1278,7 @@ static struct dentry * __lookup_hash(str
 		dentry = ERR_PTR(-ENOMEM);
 		if (!new)
 			goto out;
-		dentry = inode->i_op->lookup(inode, new, nd);
+		dentry = inode->i_op->lookup(inode, new, ND2(nd));
 		if (!dentry)
 			dentry = new;
 		else
@@ -1422,13 +1423,13 @@ static int may_delete(struct inode *dir,
  *  4. We can't do it if dir is immutable (done in permission())
  */
 static inline int may_create(struct inode *dir, struct dentry *child,
-			     struct nameidata *nd)
+			     struct nameidata2 *nd)
 {
 	if (child->d_inode)
 		return -EEXIST;
 	if (IS_DEADDIR(dir))
 		return -ENOENT;
-	return permission(dir,MAY_WRITE | MAY_EXEC, nd);
+	return permission(dir, MAY_WRITE | MAY_EXEC, nd);
 }
 
 /* 
@@ -1492,7 +1493,7 @@ void unlock_rename(struct dentry *p1, st
 }
 
 int vfs_create(struct inode *dir, struct dentry *dentry, int mode,
-		struct nameidata *nd)
+		struct nameidata2 *nd)
 {
 	int error = may_create(dir, dentry, nd);
 
@@ -1528,7 +1529,7 @@ int may_open(struct nameidata *nd, int a
 	if (S_ISDIR(inode->i_mode) && (flag & FMODE_WRITE))
 		return -EISDIR;
 
-	error = vfs_permission(nd, acc_mode);
+	error = vfs_permission(ND2(nd), acc_mode);
 	if (error)
 		return error;
 
@@ -1601,7 +1602,7 @@ static int open_namei_create(struct name
 
 	if (!IS_POSIXACL(dir->d_inode))
 		mode &= ~current->fs->umask;
-	error = vfs_create(dir->d_inode, path->dentry, mode, nd);
+	error = vfs_create(dir->d_inode, path->dentry, mode, ND2(nd));
 	mutex_unlock(&dir->d_inode->i_mutex);
 	dput(nd->dentry);
 	nd->dentry = path->dentry;
@@ -1734,7 +1735,7 @@ exit_dput:
 	dput_path(&path, nd);
 exit:
 	if (!IS_ERR(nd->intent.open.file))
-		release_open_intent(nd);
+		release_open_intent(ND2(nd));
 	path_release(nd);
 	return error;
 
@@ -1762,7 +1763,7 @@ do_link:
 		 * me so stupid? Anathema to whoever designed this non-sense
 		 * with "intent.open".
 		 */
-		release_open_intent(nd);
+		release_open_intent(ND2(nd));
 		return error;
 	}
 	nd->flags &= ~LOOKUP_PARENT;
@@ -1888,7 +1889,7 @@ asmlinkage long sys_mknodat(int dfd, con
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode, dentry, mode,
-					   &nd);
+					   ND2(&nd));
 			break;
 		case S_IFCHR: case S_IFBLK:
 			error = vfs_mknod(nd.dentry->d_inode, dentry, nd.mnt,
--- a/fs/ncpfs/dir.c
+++ b/fs/ncpfs/dir.c
@@ -33,8 +33,8 @@ static void ncp_do_readdir(struct file *
 
 static int ncp_readdir(struct file *, void *, filldir_t);
 
-static int ncp_create(struct inode *, struct dentry *, int, struct nameidata *);
-static struct dentry *ncp_lookup(struct inode *, struct dentry *, struct nameidata *);
+static int ncp_create(struct inode *, struct dentry *, int, struct nameidata2 *);
+static struct dentry *ncp_lookup(struct inode *, struct dentry *, struct nameidata2 *);
 static int ncp_unlink(struct inode *, struct dentry *);
 static int ncp_mkdir(struct inode *, struct dentry *, int);
 static int ncp_rmdir(struct inode *, struct dentry *);
@@ -74,7 +74,7 @@ const struct inode_operations ncp_dir_in
 /*
  * Dentry operations routines
  */
-static int ncp_lookup_validate(struct dentry *, struct nameidata *);
+static int ncp_lookup_validate(struct dentry *, struct nameidata2 *);
 static int ncp_hash_dentry(struct dentry *, struct qstr *);
 static int ncp_compare_dentry (struct dentry *, struct qstr *, struct qstr *);
 static int ncp_delete_dentry(struct dentry *);
@@ -266,7 +266,7 @@ leave_me:;
 
 
 static int
-__ncp_lookup_validate(struct dentry * dentry, struct nameidata *nd)
+__ncp_lookup_validate(struct dentry * dentry, struct nameidata2 *nd)
 {
 	struct ncp_server *server;
 	struct dentry *parent;
@@ -336,7 +336,7 @@ finished:
 }
 
 static int
-ncp_lookup_validate(struct dentry * dentry, struct nameidata *nd)
+ncp_lookup_validate(struct dentry * dentry, struct nameidata2 *nd)
 {
 	int res;
 	lock_kernel();
@@ -791,7 +791,7 @@ out:
 	return result;
 }
 
-static struct dentry *ncp_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nd)
+static struct dentry *ncp_lookup(struct inode *dir, struct dentry *dentry, struct nameidata2 *nd)
 {
 	struct ncp_server *server = NCP_SERVER(dir);
 	struct inode *inode = NULL;
@@ -940,7 +940,7 @@ out:
 }
 
 static int ncp_create(struct inode *dir, struct dentry *dentry, int mode,
-		struct nameidata *nd)
+		struct nameidata2 *nd)
 {
 	return ncp_create_new(dir, dentry, mode, 0, 0);
 }
--- a/fs/nfs/dir.c
+++ b/fs/nfs/dir.c
@@ -43,8 +43,8 @@
 
 static int nfs_opendir(struct inode *, struct file *);
 static int nfs_readdir(struct file *, void *, filldir_t);
-static struct dentry *nfs_lookup(struct inode *, struct dentry *, struct nameidata *);
-static int nfs_create(struct inode *, struct dentry *, int, struct nameidata *);
+static struct dentry *nfs_lookup(struct inode *, struct dentry *, struct nameidata2 *);
+static int nfs_create(struct inode *, struct dentry *, int, struct nameidata2 *);
 static int nfs_mkdir(struct inode *, struct dentry *, int);
 static int nfs_rmdir(struct inode *, struct dentry *);
 static int nfs_unlink(struct inode *, struct dentry *);
@@ -103,7 +103,7 @@ const struct inode_operations nfs3_dir_i
 
 #ifdef CONFIG_NFS_V4
 
-static struct dentry *nfs_atomic_lookup(struct inode *, struct dentry *, struct nameidata *);
+static struct dentry *nfs_atomic_lookup(struct inode *, struct dentry *, struct nameidata2 *);
 const struct inode_operations nfs4_dir_inode_operations = {
 	.create		= nfs_create,
 	.lookup		= nfs_atomic_lookup,
@@ -674,7 +674,7 @@ static inline void nfs_renew_times(struc
  * component of the path.
  * We check for this using LOOKUP_CONTINUE and LOOKUP_PARENT.
  */
-static inline unsigned int nfs_lookup_check_intent(struct nameidata *nd, unsigned int mask)
+static inline unsigned int nfs_lookup_check_intent(struct nameidata2 *nd, unsigned int mask)
 {
 	if (nd->flags & (LOOKUP_CONTINUE|LOOKUP_PARENT))
 		return 0;
@@ -690,7 +690,7 @@ static inline unsigned int nfs_lookup_ch
  *
  */
 static inline
-int nfs_lookup_verify_inode(struct inode *inode, struct nameidata *nd)
+int nfs_lookup_verify_inode(struct inode *inode, struct nameidata2 *nd)
 {
 	struct nfs_server *server = NFS_SERVER(inode);
 
@@ -719,7 +719,7 @@ out_force:
  */
 static inline
 int nfs_neg_need_reval(struct inode *dir, struct dentry *dentry,
-		       struct nameidata *nd)
+		       struct nameidata2 *nd)
 {
 	/* Don't revalidate a negative dentry if we're creating a new file */
 	if (nd != NULL && nfs_lookup_check_intent(nd, LOOKUP_CREATE) != 0)
@@ -738,7 +738,7 @@ int nfs_neg_need_reval(struct inode *dir
  * If the parent directory is seen to have changed, we throw out the
  * cached dentry and do a new lookup.
  */
-static int nfs_lookup_revalidate(struct dentry * dentry, struct nameidata *nd)
+static int nfs_lookup_revalidate(struct dentry * dentry, struct nameidata2 *nd)
 {
 	struct inode *dir;
 	struct inode *inode;
@@ -871,7 +871,7 @@ struct dentry_operations nfs_dentry_oper
  * an O_EXCL create using this path component.
  */
 static inline
-int nfs_is_exclusive_create(struct inode *dir, struct nameidata *nd)
+int nfs_is_exclusive_create(struct inode *dir, struct nameidata2 *nd)
 {
 	if (NFS_PROTO(dir)->version == 2)
 		return 0;
@@ -891,7 +891,7 @@ static inline int nfs_reval_fsid(struct 
 	return 0;
 }
 
-static struct dentry *nfs_lookup(struct inode *dir, struct dentry * dentry, struct nameidata *nd)
+static struct dentry *nfs_lookup(struct inode *dir, struct dentry * dentry, struct nameidata2 *nd)
 {
 	struct dentry *res;
 	struct inode *inode = NULL;
@@ -961,7 +961,7 @@ out:
 }
 
 #ifdef CONFIG_NFS_V4
-static int nfs_open_revalidate(struct dentry *, struct nameidata *);
+static int nfs_open_revalidate(struct dentry *, struct nameidata2 *);
 
 struct dentry_operations nfs4_dentry_operations = {
 	.d_revalidate	= nfs_open_revalidate,
@@ -973,7 +973,7 @@ struct dentry_operations nfs4_dentry_ope
  * Use intent information to determine whether we need to substitute
  * the NFSv4-style stateful OPEN for the LOOKUP call
  */
-static int is_atomic_open(struct inode *dir, struct nameidata *nd)
+static int is_atomic_open(struct inode *dir, struct nameidata2 *nd)
 {
 	if (nd == NULL || nfs_lookup_check_intent(nd, LOOKUP_OPEN) == 0)
 		return 0;
@@ -986,7 +986,7 @@ static int is_atomic_open(struct inode *
 	return 1;
 }
 
-static struct dentry *nfs_atomic_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nd)
+static struct dentry *nfs_atomic_lookup(struct inode *dir, struct dentry *dentry, struct nameidata2 *nd)
 {
 	struct dentry *res = NULL;
 	int error;
@@ -1055,7 +1055,7 @@ no_open:
 	return nfs_lookup(dir, dentry, nd);
 }
 
-static int nfs_open_revalidate(struct dentry *dentry, struct nameidata *nd)
+static int nfs_open_revalidate(struct dentry *dentry, struct nameidata2 *nd)
 {
 	struct dentry *parent = NULL;
 	struct inode *inode = dentry->d_inode;
@@ -1215,7 +1215,7 @@ int nfs_instantiate(struct dentry *dentr
  * reply path made it appear to have failed.
  */
 static int nfs_create(struct inode *dir, struct dentry *dentry, int mode,
-		struct nameidata *nd)
+		struct nameidata2 *nd)
 {
 	struct iattr attr;
 	int error;
@@ -1949,7 +1949,7 @@ out:
 	return -EACCES;
 }
 
-int nfs_permission(struct inode *inode, int mask, struct nameidata *nd)
+int nfs_permission(struct inode *inode, int mask, struct nameidata2 *nd)
 {
 	struct rpc_cred *cred;
 	int res = 0;
--- a/fs/nfs/nfs3proc.c
+++ b/fs/nfs/nfs3proc.c
@@ -259,7 +259,7 @@ static int nfs3_proc_readlink(struct ino
  */
 static int
 nfs3_proc_create(struct inode *dir, struct dentry *dentry, struct iattr *sattr,
-		 int flags, struct nameidata *nd)
+		 int flags, struct nameidata2 *nd)
 {
 	struct nfs_fh		fhandle;
 	struct nfs_fattr	fattr;
--- a/fs/nfs/nfs4_fs.h
+++ b/fs/nfs/nfs4_fs.h
@@ -166,8 +166,8 @@ extern int nfs4_proc_setclientid_confirm
 extern int nfs4_proc_async_renew(struct nfs_client *, struct rpc_cred *);
 extern int nfs4_proc_renew(struct nfs_client *, struct rpc_cred *);
 extern int nfs4_do_close(struct inode *inode, struct nfs4_state *state);
-extern struct dentry *nfs4_atomic_open(struct inode *, struct dentry *, struct nameidata *);
-extern int nfs4_open_revalidate(struct inode *, struct dentry *, int, struct nameidata *);
+extern struct dentry *nfs4_atomic_open(struct inode *, struct dentry *, struct nameidata2 *);
+extern int nfs4_open_revalidate(struct inode *, struct dentry *, int, struct nameidata2 *);
 extern int nfs4_server_capabilities(struct nfs_server *server, struct nfs_fh *fhandle);
 extern int nfs4_proc_fs_locations(struct inode *dir, struct qstr *name,
 		struct nfs4_fs_locations *fs_locations, struct page *page);
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -1241,7 +1241,7 @@ out:
 	return status;
 }
 
-static int nfs4_intent_set_file(struct nameidata *nd, struct dentry *dentry, struct nfs4_state *state)
+static int nfs4_intent_set_file(struct nameidata2 *nd, struct dentry *dentry, struct nfs4_state *state)
 {
 	struct file *filp;
 
@@ -1257,7 +1257,7 @@ static int nfs4_intent_set_file(struct n
 }
 
 struct dentry *
-nfs4_atomic_open(struct inode *dir, struct dentry *dentry, struct nameidata *nd)
+nfs4_atomic_open(struct inode *dir, struct dentry *dentry, struct nameidata2 *nd)
 {
 	struct iattr attr;
 	struct rpc_cred *cred;
@@ -1292,7 +1292,7 @@ nfs4_atomic_open(struct inode *dir, stru
 }
 
 int
-nfs4_open_revalidate(struct inode *dir, struct dentry *dentry, int openflags, struct nameidata *nd)
+nfs4_open_revalidate(struct inode *dir, struct dentry *dentry, int openflags, struct nameidata2 *nd)
 {
 	struct rpc_cred *cred;
 	struct nfs4_state *state;
@@ -1750,7 +1750,7 @@ static int nfs4_proc_readlink(struct ino
 
 static int
 nfs4_proc_create(struct inode *dir, struct dentry *dentry, struct iattr *sattr,
-                 int flags, struct nameidata *nd)
+                 int flags, struct nameidata2 *nd)
 {
 	struct nfs4_state *state;
 	struct rpc_cred *cred;
--- a/fs/nfs/proc.c
+++ b/fs/nfs/proc.c
@@ -188,7 +188,7 @@ static int nfs_proc_readlink(struct inod
 
 static int
 nfs_proc_create(struct inode *dir, struct dentry *dentry, struct iattr *sattr,
-		int flags, struct nameidata *nd)
+		int flags, struct nameidata2 *nd)
 {
 	struct nfs_fh		fhandle;
 	struct nfs_fattr	fattr;
--- a/fs/nfsd/vfs.c
+++ b/fs/nfsd/vfs.c
@@ -1112,7 +1112,7 @@ static inline int
 nfsd_do_create(struct inode *dir, struct dentry *child, struct vfsmount *mnt,
 	       int mode)
 {
-	struct nameidata nd = {
+	struct nameidata2 nd = {
 		.dentry = child,
 		.mnt = mnt,
 	};
--- a/fs/ntfs/namei.c
+++ b/fs/ntfs/namei.c
@@ -99,7 +99,7 @@
  * Locking: Caller must hold i_mutex on the directory.
  */
 static struct dentry *ntfs_lookup(struct inode *dir_ino, struct dentry *dent,
-		struct nameidata *nd)
+		struct nameidata2 *nd)
 {
 	ntfs_volume *vol = NTFS_SB(dir_ino->i_sb);
 	struct inode *dent_inode;
--- a/fs/ocfs2/dcache.c
+++ b/fs/ocfs2/dcache.c
@@ -41,7 +41,7 @@
 
 
 static int ocfs2_dentry_revalidate(struct dentry *dentry,
-				   struct nameidata *nd)
+				   struct nameidata2 *nd)
 {
 	struct inode *inode = dentry->d_inode;
 	int ret = 0;    /* if all else fails, just return false */
--- a/fs/ocfs2/dlm/dlmfs.c
+++ b/fs/ocfs2/dlm/dlmfs.c
@@ -463,7 +463,7 @@ bail:
 static int dlmfs_create(struct inode *dir,
 			struct dentry *dentry,
 			int mode,
-			struct nameidata *nd)
+			struct nameidata2 *nd)
 {
 	int status = 0;
 	struct inode *inode;
--- a/fs/ocfs2/file.c
+++ b/fs/ocfs2/file.c
@@ -964,7 +964,7 @@ bail:
 	return err;
 }
 
-int ocfs2_permission(struct inode *inode, int mask, struct nameidata *nd)
+int ocfs2_permission(struct inode *inode, int mask, struct nameidata2 *nd)
 {
 	int ret;
 
--- a/fs/ocfs2/file.h
+++ b/fs/ocfs2/file.h
@@ -49,7 +49,7 @@ int ocfs2_setattr(struct dentry *dentry,
 int ocfs2_getattr(struct vfsmount *mnt, struct dentry *dentry,
 		  struct kstat *stat);
 int ocfs2_permission(struct inode *inode, int mask,
-		     struct nameidata *nd);
+		     struct nameidata2 *nd);
 
 int ocfs2_set_inode_size(handle_t *handle,
 			 struct inode *inode,
--- a/fs/ocfs2/namei.c
+++ b/fs/ocfs2/namei.c
@@ -138,7 +138,7 @@ static inline int ocfs2_add_entry(handle
 #define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))
 
 static struct dentry *ocfs2_lookup(struct inode *dir, struct dentry *dentry,
-				   struct nameidata *nd)
+				   struct nameidata2 *nd)
 {
 	int status;
 	u64 blkno;
@@ -628,7 +628,7 @@ static int ocfs2_mkdir(struct inode *dir
 static int ocfs2_create(struct inode *dir,
 			struct dentry *dentry,
 			int mode,
-			struct nameidata *nd)
+			struct nameidata2 *nd)
 {
 	int ret;
 
--- a/fs/open.c
+++ b/fs/open.c
@@ -241,7 +241,7 @@ static long do_sys_truncate(const char _
 	if (!S_ISREG(inode->i_mode))
 		goto dput_and_out;
 
-	error = vfs_permission(&nd, MAY_WRITE);
+	error = vfs_permission(ND2(&nd), MAY_WRITE);
 	if (error)
 		goto dput_and_out;
 
@@ -390,7 +390,7 @@ asmlinkage long sys_faccessat(int dfd, c
 	if (res)
 		goto out;
 
-	res = vfs_permission(&nd, mode);
+	res = vfs_permission(ND2(&nd), mode);
 	/* SuS v2 requires we report a read only fs too */
 	if(res || !(mode & S_IWOTH) ||
 	   special_file(nd.dentry->d_inode->i_mode))
@@ -424,7 +424,7 @@ asmlinkage long sys_chdir(const char __u
 	if (error)
 		goto out;
 
-	error = vfs_permission(&nd, MAY_EXEC);
+	error = vfs_permission(ND2(&nd), MAY_EXEC);
 	if (error)
 		goto dput_and_out;
 
@@ -475,7 +475,7 @@ asmlinkage long sys_chroot(const char __
 	if (error)
 		goto out;
 
-	error = vfs_permission(&nd, MAY_EXEC);
+	error = vfs_permission(ND2(&nd), MAY_EXEC);
 	if (error)
 		goto dput_and_out;
 
@@ -796,8 +796,9 @@ EXPORT_SYMBOL(filp_open);
  * If the open callback is set to NULL, then the standard f_op->open()
  * filesystem callback is substituted.
  */
-struct file *lookup_instantiate_filp(struct nameidata *nd, struct dentry *dentry,
-		int (*open)(struct inode *, struct file *))
+struct file *lookup_instantiate_filp(struct nameidata2 *nd,
+				     struct dentry *dentry,
+				     int (*open)(struct inode *, struct file *))
 {
 	if (IS_ERR(nd->intent.open.file))
 		goto out;
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -1071,7 +1071,7 @@ static int pid_getattr(struct vfsmount *
  * made this apply to all per process world readable and executable
  * directories.
  */
-static int pid_revalidate(struct dentry *dentry, struct nameidata *nd)
+static int pid_revalidate(struct dentry *dentry, struct nameidata2 *nd)
 {
 	struct inode *inode = dentry->d_inode;
 	struct task_struct *task = get_proc_task(inode);
@@ -1219,7 +1219,7 @@ static int proc_fd_link(struct inode *in
 	return -ENOENT;
 }
 
-static int tid_fd_revalidate(struct dentry *dentry, struct nameidata *nd)
+static int tid_fd_revalidate(struct dentry *dentry, struct nameidata2 *nd)
 {
 	struct inode *inode = dentry->d_inode;
 	struct task_struct *task = get_proc_task(inode);
@@ -1314,7 +1314,7 @@ out_iput:
 	goto out;
 }
 
-static struct dentry *proc_lookupfd(struct inode * dir, struct dentry * dentry, struct nameidata *nd)
+static struct dentry *proc_lookupfd(struct inode * dir, struct dentry * dentry, struct nameidata2 *nd)
 {
 	struct task_struct *task = get_proc_task(dir);
 	unsigned fd = name_to_int(dentry);
@@ -1630,7 +1630,7 @@ static const struct file_operations proc
 };
 
 static struct dentry *proc_attr_dir_lookup(struct inode *dir,
-				struct dentry *dentry, struct nameidata *nd)
+				struct dentry *dentry, struct nameidata2 *nd)
 {
 	return proc_pident_lookup(dir, dentry,
 				  attr_dir_stuff, ARRAY_SIZE(attr_dir_stuff));
@@ -1684,7 +1684,7 @@ static struct pid_entry proc_base_stuff[
  * directory. In this case, however, we can do it - no aliasing problems
  * due to the way we treat inodes.
  */
-static int proc_base_revalidate(struct dentry *dentry, struct nameidata *nd)
+static int proc_base_revalidate(struct dentry *dentry, struct nameidata2 *nd)
 {
 	struct inode *inode = dentry->d_inode;
 	struct task_struct *task = get_proc_task(inode);
@@ -1879,7 +1879,7 @@ static const struct file_operations proc
 	.readdir	= proc_tgid_base_readdir,
 };
 
-static struct dentry *proc_tgid_base_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nd){
+static struct dentry *proc_tgid_base_lookup(struct inode *dir, struct dentry *dentry, struct nameidata2 *nd){
 	return proc_pident_lookup(dir, dentry,
 				  tgid_base_stuff, ARRAY_SIZE(tgid_base_stuff));
 }
@@ -1987,7 +1987,7 @@ out:
 	return error;
 }
 
-struct dentry *proc_pid_lookup(struct inode *dir, struct dentry * dentry, struct nameidata *nd)
+struct dentry *proc_pid_lookup(struct inode *dir, struct dentry * dentry, struct nameidata2 *nd)
 {
 	struct dentry *result = ERR_PTR(-ENOENT);
 	struct task_struct *task;
@@ -2152,7 +2152,7 @@ static int proc_tid_base_readdir(struct 
 				   tid_base_stuff,ARRAY_SIZE(tid_base_stuff));
 }
 
-static struct dentry *proc_tid_base_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nd){
+static struct dentry *proc_tid_base_lookup(struct inode *dir, struct dentry *dentry, struct nameidata2 *nd){
 	return proc_pident_lookup(dir, dentry,
 				  tid_base_stuff, ARRAY_SIZE(tid_base_stuff));
 }
@@ -2196,7 +2196,7 @@ out:
 	return error;
 }
 
-static struct dentry *proc_task_lookup(struct inode *dir, struct dentry * dentry, struct nameidata *nd)
+static struct dentry *proc_task_lookup(struct inode *dir, struct dentry * dentry, struct nameidata2 *nd)
 {
 	struct dentry *result = ERR_PTR(-ENOENT);
 	struct task_struct *task;
--- a/fs/proc/generic.c
+++ b/fs/proc/generic.c
@@ -382,7 +382,7 @@ static struct dentry_operations proc_den
  * Don't create negative dentries here, return -ENOENT by hand
  * instead.
  */
-struct dentry *proc_lookup(struct inode * dir, struct dentry *dentry, struct nameidata *nd)
+struct dentry *proc_lookup(struct inode * dir, struct dentry *dentry, struct nameidata2 *nd)
 {
 	struct inode *inode = NULL;
 	struct proc_dir_entry * de;
--- a/fs/proc/proc_sysctl.c
+++ b/fs/proc/proc_sysctl.c
@@ -139,7 +139,7 @@ static struct ctl_table *do_proc_sys_loo
 }
 
 static struct dentry *proc_sys_lookup(struct inode *dir, struct dentry *dentry,
-					struct nameidata *nd)
+					struct nameidata2 *nd)
 {
 	struct ctl_table_header *head;
 	struct inode *inode;
@@ -369,7 +369,7 @@ out:
 	return ret;
 }
 
-static int proc_sys_permission(struct inode *inode, int mask, struct nameidata *nd)
+static int proc_sys_permission(struct inode *inode, int mask, struct nameidata2 *nd)
 {
 	/*
 	 * sysctl entries that are not writeable,
@@ -450,7 +450,7 @@ static struct inode_operations proc_sys_
 	.setattr	= proc_sys_setattr,
 };
 
-static int proc_sys_revalidate(struct dentry *dentry, struct nameidata *nd)
+static int proc_sys_revalidate(struct dentry *dentry, struct nameidata2 *nd)
 {
 	struct ctl_table_header *head;
 	struct ctl_table *table;
--- a/fs/proc/root.c
+++ b/fs/proc/root.c
@@ -90,7 +90,7 @@ static int proc_root_getattr(struct vfsm
 	return 0;
 }
 
-static struct dentry *proc_root_lookup(struct inode * dir, struct dentry * dentry, struct nameidata *nd)
+static struct dentry *proc_root_lookup(struct inode * dir, struct dentry * dentry, struct nameidata2 *nd)
 {
 	if (!proc_lookup(dir, dentry, nd)) {
 		return NULL;
--- a/fs/qnx4/namei.c
+++ b/fs/qnx4/namei.c
@@ -106,7 +106,7 @@ static struct buffer_head *qnx4_find_ent
 	return NULL;
 }
 
-struct dentry * qnx4_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nd)
+struct dentry * qnx4_lookup(struct inode *dir, struct dentry *dentry, struct nameidata2 *nd)
 {
 	int ino;
 	struct qnx4_inode_entry *de;
--- a/fs/ramfs/inode.c
+++ b/fs/ramfs/inode.c
@@ -117,7 +117,7 @@ static int ramfs_mkdir(struct inode * di
 	return retval;
 }
 
-static int ramfs_create(struct inode *dir, struct dentry *dentry, int mode, struct nameidata *nd)
+static int ramfs_create(struct inode *dir, struct dentry *dentry, int mode, struct nameidata2 *nd)
 {
 	return ramfs_mknod(dir, dentry, mode | S_IFREG, 0);
 }
--- a/fs/reiserfs/namei.c
+++ b/fs/reiserfs/namei.c
@@ -325,7 +325,7 @@ static int reiserfs_find_entry(struct in
 }
 
 static struct dentry *reiserfs_lookup(struct inode *dir, struct dentry *dentry,
-				      struct nameidata *nd)
+				      struct nameidata2 *nd)
 {
 	int retval;
 	struct inode *inode = NULL;
@@ -601,7 +601,7 @@ static int new_inode_init(struct inode *
 }
 
 static int reiserfs_create(struct inode *dir, struct dentry *dentry, int mode,
-			   struct nameidata *nd)
+			   struct nameidata2 *nd)
 {
 	int retval;
 	struct inode *inode;
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -1342,7 +1342,7 @@ static int reiserfs_check_acl(struct ino
 	return error;
 }
 
-int reiserfs_permission(struct inode *inode, int mask, struct nameidata *nd)
+int reiserfs_permission(struct inode *inode, int mask, struct nameidata2 *nd)
 {
 	/*
 	 * We don't do permission checks on the internal objects.
--- a/fs/romfs/inode.c
+++ b/fs/romfs/inode.c
@@ -332,7 +332,7 @@ out:
 }
 
 static struct dentry *
-romfs_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nd)
+romfs_lookup(struct inode *dir, struct dentry *dentry, struct nameidata2 *nd)
 {
 	unsigned long offset, maxoff;
 	int fslen, res;
--- a/fs/smbfs/dir.c
+++ b/fs/smbfs/dir.c
@@ -24,8 +24,8 @@
 static int smb_readdir(struct file *, void *, filldir_t);
 static int smb_dir_open(struct inode *, struct file *);
 
-static struct dentry *smb_lookup(struct inode *, struct dentry *, struct nameidata *);
-static int smb_create(struct inode *, struct dentry *, int, struct nameidata *);
+static struct dentry *smb_lookup(struct inode *, struct dentry *, struct nameidata2 *);
+static int smb_create(struct inode *, struct dentry *, int, struct nameidata2 *);
 static int smb_mkdir(struct inode *, struct dentry *, int);
 static int smb_rmdir(struct inode *, struct dentry *);
 static int smb_unlink(struct inode *, struct dentry *);
@@ -271,7 +271,7 @@ smb_dir_open(struct inode *dir, struct f
 /*
  * Dentry operations routines
  */
-static int smb_lookup_validate(struct dentry *, struct nameidata *);
+static int smb_lookup_validate(struct dentry *, struct nameidata2 *);
 static int smb_hash_dentry(struct dentry *, struct qstr *);
 static int smb_compare_dentry(struct dentry *, struct qstr *, struct qstr *);
 static int smb_delete_dentry(struct dentry *);
@@ -295,7 +295,7 @@ static struct dentry_operations smbfs_de
  * This is the callback when the dcache has a lookup hit.
  */
 static int
-smb_lookup_validate(struct dentry * dentry, struct nameidata *nd)
+smb_lookup_validate(struct dentry * dentry, struct nameidata2 *nd)
 {
 	struct smb_sb_info *server = server_from_dentry(dentry);
 	struct inode * inode = dentry->d_inode;
@@ -423,7 +423,7 @@ smb_renew_times(struct dentry * dentry)
 }
 
 static struct dentry *
-smb_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nd)
+smb_lookup(struct inode *dir, struct dentry *dentry, struct nameidata2 *nd)
 {
 	struct smb_fattr finfo;
 	struct inode *inode;
@@ -519,7 +519,7 @@ out_close:
 /* N.B. How should the mode argument be used? */
 static int
 smb_create(struct inode *dir, struct dentry *dentry, int mode,
-		struct nameidata *nd)
+		struct nameidata2 *nd)
 {
 	struct smb_sb_info *server = server_from_dentry(dentry);
 	__u16 fileid;
--- a/fs/smbfs/file.c
+++ b/fs/smbfs/file.c
@@ -389,7 +389,7 @@ smb_file_release(struct inode *inode, st
  * privileges, so we need our own check for this.
  */
 static int
-smb_file_permission(struct inode *inode, int mask, struct nameidata *nd)
+smb_file_permission(struct inode *inode, int mask, struct nameidata2 *nd)
 {
 	int mode = inode->i_mode;
 	int error = 0;
--- a/fs/sysfs/dir.c
+++ b/fs/sysfs/dir.c
@@ -272,7 +272,7 @@ static int sysfs_attach_link(struct sysf
 }
 
 static struct dentry * sysfs_lookup(struct inode *dir, struct dentry *dentry,
-				struct nameidata *nd)
+				struct nameidata2 *nd)
 {
 	struct sysfs_dirent * parent_sd = dentry->d_parent->d_fsdata;
 	struct sysfs_dirent * sd;
--- a/fs/sysv/namei.c
+++ b/fs/sysv/namei.c
@@ -43,7 +43,7 @@ struct dentry_operations sysv_dentry_ope
 	.d_hash		= sysv_hash,
 };
 
-static struct dentry *sysv_lookup(struct inode * dir, struct dentry * dentry, struct nameidata *nd)
+static struct dentry *sysv_lookup(struct inode * dir, struct dentry * dentry, struct nameidata2 *nd)
 {
 	struct inode * inode = NULL;
 	ino_t ino;
@@ -81,7 +81,7 @@ static int sysv_mknod(struct inode * dir
 	return err;
 }
 
-static int sysv_create(struct inode * dir, struct dentry * dentry, int mode, struct nameidata *nd)
+static int sysv_create(struct inode * dir, struct dentry * dentry, int mode, struct nameidata2 *nd)
 {
 	return sysv_mknod(dir, dentry, mode, 0);
 }
--- a/fs/udf/namei.c
+++ b/fs/udf/namei.c
@@ -293,7 +293,7 @@ udf_find_entry(struct inode *dir, struct
  */
 
 static struct dentry *
-udf_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nd)
+udf_lookup(struct inode *dir, struct dentry *dentry, struct nameidata2 *nd)
 {
 	struct inode *inode = NULL;
 	struct fileIdentDesc cfi;
@@ -614,7 +614,7 @@ static int udf_delete_entry(struct inode
 	return udf_write_fi(inode, cfi, fi, fibh, NULL, NULL);
 }
 
-static int udf_create(struct inode *dir, struct dentry *dentry, int mode, struct nameidata *nd)
+static int udf_create(struct inode *dir, struct dentry *dentry, int mode, struct nameidata2 *nd)
 {
 	struct udf_fileident_bh fibh;
 	struct inode *inode;
--- a/fs/ufs/namei.c
+++ b/fs/ufs/namei.c
@@ -46,7 +46,7 @@ static inline int ufs_add_nondir(struct 
 	return err;
 }
 
-static struct dentry *ufs_lookup(struct inode * dir, struct dentry *dentry, struct nameidata *nd)
+static struct dentry *ufs_lookup(struct inode * dir, struct dentry *dentry, struct nameidata2 *nd)
 {
 	struct inode * inode = NULL;
 	ino_t ino;
@@ -77,7 +77,7 @@ static struct dentry *ufs_lookup(struct 
  * with d_instantiate(). 
  */
 static int ufs_create (struct inode * dir, struct dentry * dentry, int mode,
-		struct nameidata *nd)
+		struct nameidata2 *nd)
 {
 	struct inode *inode;
 	int err;
--- a/fs/utimes.c
+++ b/fs/utimes.c
@@ -58,7 +58,7 @@ asmlinkage long sys_utime(char __user * 
                         goto dput_and_out;
 
 		if (current->fsuid != inode->i_uid &&
-		    (error = vfs_permission(&nd, MAY_WRITE)) != 0)
+		    (error = vfs_permission(ND2(&nd), MAY_WRITE)) != 0)
 			goto dput_and_out;
 	}
 	mutex_lock(&inode->i_mutex);
@@ -111,7 +111,7 @@ long do_utimes(int dfd, char __user *fil
                         goto dput_and_out;
 
 		if (current->fsuid != inode->i_uid &&
-		    (error = vfs_permission(&nd, MAY_WRITE)) != 0)
+		    (error = vfs_permission(ND2(&nd), MAY_WRITE)) != 0)
 			goto dput_and_out;
 	}
 	mutex_lock(&inode->i_mutex);
--- a/fs/vfat/namei.c
+++ b/fs/vfat/namei.c
@@ -25,7 +25,7 @@
 #include <linux/buffer_head.h>
 #include <linux/namei.h>
 
-static int vfat_revalidate(struct dentry *dentry, struct nameidata *nd)
+static int vfat_revalidate(struct dentry *dentry, struct nameidata2 *nd)
 {
 	int ret = 1;
 
@@ -684,7 +684,7 @@ static int vfat_find(struct inode *dir, 
 }
 
 static struct dentry *vfat_lookup(struct inode *dir, struct dentry *dentry,
-				  struct nameidata *nd)
+				  struct nameidata2 *nd)
 {
 	struct super_block *sb = dir->i_sb;
 	struct fat_slot_info sinfo;
@@ -731,7 +731,7 @@ error:
 }
 
 static int vfat_create(struct inode *dir, struct dentry *dentry, int mode,
-		       struct nameidata *nd)
+		       struct nameidata2 *nd)
 {
 	struct super_block *sb = dir->i_sb;
 	struct inode *inode;
--- a/fs/xfs/linux-2.6/xfs_iops.c
+++ b/fs/xfs/linux-2.6/xfs_iops.c
@@ -367,7 +367,7 @@ xfs_vn_create(
 	struct inode	*dir,
 	struct dentry	*dentry,
 	int		mode,
-	struct nameidata *nd)
+	struct nameidata2 *nd)
 {
 	return xfs_vn_mknod(dir, dentry, mode, 0);
 }
@@ -385,7 +385,7 @@ STATIC struct dentry *
 xfs_vn_lookup(
 	struct inode	*dir,
 	struct dentry	*dentry,
-	struct nameidata *nd)
+	struct nameidata2 *nd)
 {
 	bhv_vnode_t	*vp = vn_from_inode(dir), *cvp;
 	int		error;
@@ -605,7 +605,7 @@ STATIC int
 xfs_vn_permission(
 	struct inode	*inode,
 	int		mode,
-	struct nameidata *nd)
+	struct nameidata2 *nd)
 {
 	return -bhv_vop_access(vn_from_inode(inode), mode << 6, NULL);
 }
--- a/include/linux/coda_linux.h
+++ b/include/linux/coda_linux.h
@@ -38,7 +38,7 @@ extern const struct file_operations coda
 int coda_open(struct inode *i, struct file *f);
 int coda_flush(struct file *f, fl_owner_t id);
 int coda_release(struct inode *i, struct file *f);
-int coda_permission(struct inode *inode, int mask, struct nameidata *nd);
+int coda_permission(struct inode *inode, int mask, struct nameidata2 *nd);
 int coda_revalidate_inode(struct dentry *);
 int coda_getattr(struct vfsmount *, struct dentry *, struct kstat *);
 int coda_setattr(struct dentry *, struct iattr *);
--- a/include/linux/dcache.h
+++ b/include/linux/dcache.h
@@ -10,6 +10,7 @@
 #include <linux/rcupdate.h>
 
 struct nameidata;
+struct nameidata2;
 struct vfsmount;
 
 /*
@@ -127,7 +128,7 @@ enum dentry_d_lock_class
 };
 
 struct dentry_operations {
-	int (*d_revalidate)(struct dentry *, struct nameidata *);
+	int (*d_revalidate)(struct dentry *, struct nameidata2 *);
 	int (*d_hash) (struct dentry *, struct qstr *);
 	int (*d_compare) (struct dentry *, struct qstr *, struct qstr *);
 	int (*d_delete)(struct dentry *);
--- a/include/linux/efs_fs.h
+++ b/include/linux/efs_fs.h
@@ -44,7 +44,7 @@ extern void efs_read_inode(struct inode 
 extern efs_block_t efs_map_block(struct inode *, efs_block_t);
 extern int efs_get_block(struct inode *, sector_t, struct buffer_head *, int);
 
-extern struct dentry *efs_lookup(struct inode *, struct dentry *, struct nameidata *);
+extern struct dentry *efs_lookup(struct inode *, struct dentry *, struct nameidata2 *);
 extern struct dentry *efs_get_parent(struct dentry *);
 extern int efs_bmap(struct inode *, int);
 
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -289,6 +289,7 @@ extern int dir_notify_enable;
 struct hd_geometry;
 struct iovec;
 struct nameidata;
+struct nameidata2;
 struct kiocb;
 struct pipe_inode_info;
 struct poll_table_struct;
@@ -981,8 +982,8 @@ extern void unlock_super(struct super_bl
 /*
  * VFS helper functions..
  */
-extern int vfs_permission(struct nameidata *, int);
-extern int vfs_create(struct inode *, struct dentry *, int, struct nameidata *);
+extern int vfs_permission(struct nameidata2 *, int);
+extern int vfs_create(struct inode *, struct dentry *, int, struct nameidata2 *);
 extern int vfs_mkdir(struct inode *, struct dentry *, struct vfsmount *, int);
 extern int vfs_mknod(struct inode *, struct dentry *, struct vfsmount *, int, dev_t);
 extern int vfs_symlink(struct inode *, struct dentry *, struct vfsmount *, const char *, int);
@@ -1106,8 +1107,8 @@ struct file_operations {
 };
 
 struct inode_operations {
-	int (*create) (struct inode *,struct dentry *,int, struct nameidata *);
-	struct dentry * (*lookup) (struct inode *,struct dentry *, struct nameidata *);
+	int (*create) (struct inode *,struct dentry *,int, struct nameidata2 *);
+	struct dentry * (*lookup) (struct inode *,struct dentry *, struct nameidata2 *);
 	int (*link) (struct dentry *,struct inode *,struct dentry *);
 	int (*unlink) (struct inode *,struct dentry *);
 	int (*symlink) (struct inode *,struct dentry *,const char *);
@@ -1120,7 +1121,7 @@ struct inode_operations {
 	void * (*follow_link) (struct dentry *, struct nameidata *);
 	void (*put_link) (struct dentry *, struct nameidata *, void *);
 	void (*truncate) (struct inode *);
-	int (*permission) (struct inode *, int, struct nameidata *);
+	int (*permission) (struct inode *, int, struct nameidata2 *);
 	int (*setattr) (struct dentry *, struct iattr *);
 	int (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);
 	int (*setxattr) (struct dentry *, const char *,const void *,size_t,int);
@@ -1616,7 +1617,7 @@ extern int do_remount_sb(struct super_bl
 extern sector_t bmap(struct inode *, sector_t);
 #endif
 extern int notify_change(struct dentry *, struct vfsmount *, struct iattr *);
-extern int permission(struct inode *, int, struct nameidata *);
+extern int permission(struct inode *, int, struct nameidata2 *);
 extern int generic_permission(struct inode *, int,
 		int (*check_acl)(struct inode *, int));
 
@@ -1873,7 +1874,7 @@ extern int simple_prepare_write(struct f
 extern int simple_commit_write(struct file *file, struct page *page,
 				unsigned offset, unsigned to);
 
-extern struct dentry *simple_lookup(struct inode *, struct dentry *, struct nameidata *);
+extern struct dentry *simple_lookup(struct inode *, struct dentry *, struct nameidata2 *);
 extern ssize_t generic_read_dir(struct file *, char __user *, size_t, loff_t *);
 extern const struct file_operations simple_dir_operations;
 extern const struct inode_operations simple_dir_inode_operations;
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -14,21 +14,39 @@ struct open_intent {
 
 enum { MAX_NESTED_LINKS = 8 };
 
+/**
+ * Fields shared between nameidata and nameidata2 -- nameidata2 could
+ * be embedded in nameidata, but then the vfs code would become
+ * cluttered with dereferences.
+ */
+#define __NAMEIDATA2				\
+	struct dentry	*dentry;		\
+	struct vfsmount *mnt;			\
+	unsigned int	flags;			\
+						\
+	union {					\
+		struct open_intent open;	\
+	} intent;
+
 struct nameidata {
-	struct dentry	*dentry;
-	struct vfsmount *mnt;
+	__NAMEIDATA2
 	struct qstr	last;
-	unsigned int	flags;
 	int		last_type;
 	unsigned	depth;
 	char *saved_names[MAX_NESTED_LINKS + 1];
+};
 
-	/* Intent data */
-	union {
-		struct open_intent open;
-	} intent;
+struct nameidata2 {
+	__NAMEIDATA2
 };
 
+#undef __NAMEIDATA2
+
+static inline struct nameidata2 *ND2(struct nameidata *nd)
+{
+	return container_of(&nd->dentry, struct nameidata2, dentry);
+}
+
 struct path {
 	struct vfsmount *mnt;
 	struct dentry *dentry;
@@ -76,10 +94,9 @@ extern void path_release_on_umount(struc
 
 extern int __user_path_lookup_open(const char __user *, unsigned lookup_flags, struct nameidata *nd, int open_flags);
 extern int path_lookup_open(int dfd, const char *name, unsigned lookup_flags, struct nameidata *, int open_flags);
-extern struct file *lookup_instantiate_filp(struct nameidata *nd, struct dentry *dentry,
-		int (*open)(struct inode *, struct file *));
+extern struct file *lookup_instantiate_filp(struct nameidata2 *nd, struct dentry *dentry, int (*open)(struct inode *, struct file *));
 extern struct file *nameidata_to_filp(struct nameidata *nd, int flags);
-extern void release_open_intent(struct nameidata *);
+extern void release_open_intent(struct nameidata2 *);
 
 extern struct dentry * lookup_one_len(const char *, struct dentry *, int);
 
--- a/include/linux/nfs_fs.h
+++ b/include/linux/nfs_fs.h
@@ -290,7 +290,7 @@ extern struct inode *nfs_fhget(struct su
 extern int nfs_refresh_inode(struct inode *, struct nfs_fattr *);
 extern int nfs_post_op_update_inode(struct inode *inode, struct nfs_fattr *fattr);
 extern int nfs_getattr(struct vfsmount *, struct dentry *, struct kstat *);
-extern int nfs_permission(struct inode *, int, struct nameidata *);
+extern int nfs_permission(struct inode *, int, struct nameidata2 *);
 extern int nfs_access_get_cached(struct inode *, struct rpc_cred *, struct nfs_access_entry *);
 extern void nfs_access_add_cache(struct inode *, struct nfs_access_entry *);
 extern void nfs_access_zap_cache(struct inode *inode);
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -785,7 +785,7 @@ struct nfs_rpc_ops {
 	int	(*readlink)(struct inode *, struct page *, unsigned int,
 			    unsigned int);
 	int	(*create)  (struct inode *, struct dentry *,
-			    struct iattr *, int, struct nameidata *);
+			    struct iattr *, int, struct nameidata2 *);
 	int	(*remove)  (struct inode *, struct qstr *);
 	int	(*unlink_setup)  (struct rpc_message *,
 			    struct dentry *, struct qstr *);
--- a/include/linux/proc_fs.h
+++ b/include/linux/proc_fs.h
@@ -99,7 +99,7 @@ extern void proc_misc_init(void);
 struct mm_struct;
 
 void proc_flush_task(struct task_struct *task);
-struct dentry *proc_pid_lookup(struct inode *dir, struct dentry * dentry, struct nameidata *);
+struct dentry *proc_pid_lookup(struct inode *dir, struct dentry * dentry, struct nameidata2 *);
 int proc_pid_readdir(struct file * filp, void * dirent, filldir_t filldir);
 unsigned long task_vsize(struct mm_struct *);
 int task_statm(struct mm_struct *, int *, int *, int *, int *);
@@ -121,7 +121,7 @@ extern struct inode *proc_get_inode(stru
  * of the /proc/<pid> subdirectories.
  */
 extern int proc_readdir(struct file *, void *, filldir_t);
-extern struct dentry *proc_lookup(struct inode *, struct dentry *, struct nameidata *);
+extern struct dentry *proc_lookup(struct inode *, struct dentry *, struct nameidata2 *);
 
 extern const struct file_operations proc_kcore_operations;
 extern const struct file_operations proc_kmsg_operations;
--- a/include/linux/qnx4_fs.h
+++ b/include/linux/qnx4_fs.h
@@ -110,7 +110,7 @@ struct qnx4_inode_info {
 	struct inode vfs_inode;
 };
 
-extern struct dentry *qnx4_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nd);
+extern struct dentry *qnx4_lookup(struct inode *dir, struct dentry *dentry, struct nameidata2 *nd);
 extern unsigned long qnx4_count_free_blocks(struct super_block *sb);
 extern unsigned long qnx4_block_map(struct inode *inode, long iblock);
 
--- a/include/linux/reiserfs_xattr.h
+++ b/include/linux/reiserfs_xattr.h
@@ -55,7 +55,7 @@ int reiserfs_removexattr(struct dentry *
 int reiserfs_delete_xattrs(struct inode *inode);
 int reiserfs_chown_xattrs(struct inode *inode, struct iattr *attrs);
 int reiserfs_xattr_init(struct super_block *sb, int mount_flags);
-int reiserfs_permission(struct inode *inode, int mask, struct nameidata *nd);
+int reiserfs_permission(struct inode *inode, int mask, struct nameidata2 *nd);
 
 int reiserfs_xattr_del(struct inode *, const char *);
 int reiserfs_xattr_get(const struct inode *, const char *, void *, size_t);
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -1237,7 +1237,7 @@ struct security_operations {
 			     struct vfsmount *new_mnt);
 	int (*inode_readlink) (struct dentry *dentry, struct vfsmount *mnt);
 	int (*inode_follow_link) (struct dentry *dentry, struct nameidata *nd);
-	int (*inode_permission) (struct inode *inode, int mask, struct nameidata *nd);
+	int (*inode_permission) (struct inode *inode, int mask, struct nameidata2 *nd);
 	int (*inode_setattr) (struct dentry *dentry, struct vfsmount *mnt,
 			      struct iattr *attr);
 	int (*inode_getattr) (struct vfsmount *mnt, struct dentry *dentry);
@@ -1735,7 +1735,7 @@ static inline int security_inode_follow_
 }
 
 static inline int security_inode_permission (struct inode *inode, int mask,
-					     struct nameidata *nd)
+					     struct nameidata2 *nd)
 {
 	if (unlikely (IS_PRIVATE (inode)))
 		return 0;
@@ -2464,7 +2464,7 @@ static inline int security_inode_follow_
 }
 
 static inline int security_inode_permission (struct inode *inode, int mask,
-					     struct nameidata *nd)
+					     struct nameidata2 *nd)
 {
 	return 0;
 }
--- a/include/linux/shmem_fs.h
+++ b/include/linux/shmem_fs.h
@@ -41,7 +41,7 @@ static inline struct shmem_inode_info *S
 }
 
 #ifdef CONFIG_TMPFS_POSIX_ACL
-int shmem_permission(struct inode *, int, struct nameidata *);
+int shmem_permission(struct inode *, int, struct nameidata2 *);
 int shmem_acl_init(struct inode *, struct inode *);
 void shmem_acl_destroy_inode(struct inode *);
 
--- a/ipc/mqueue.c
+++ b/ipc/mqueue.c
@@ -268,7 +268,7 @@ static void mqueue_delete_inode(struct i
 }
 
 static int mqueue_create(struct inode *dir, struct dentry *dentry,
-				int mode, struct nameidata *nd)
+				int mode, struct nameidata2 *nd)
 {
 	struct inode *inode;
 	struct mq_attr *attr = dentry->d_fsdata;
@@ -604,7 +604,7 @@ static int mq_attr_ok(struct mq_attr *at
 static struct file *do_create(struct dentry *dir, struct dentry *dentry,
 			int oflag, mode_t mode, struct mq_attr __user *u_attr)
 {
-	struct nameidata nd = {
+	struct nameidata2 nd = {
 		.dentry = dentry,
 		.mnt = mqueue_mnt,
 	};
--- a/mm/shmem.c
+++ b/mm/shmem.c
@@ -1796,7 +1796,7 @@ static int shmem_mkdir(struct inode *dir
 }
 
 static int shmem_create(struct inode *dir, struct dentry *dentry, int mode,
-		struct nameidata *nd)
+		struct nameidata2 *nd)
 {
 	return shmem_mknod(dir, dentry, mode | S_IFREG, 0);
 }
--- a/mm/shmem_acl.c
+++ b/mm/shmem_acl.c
@@ -191,7 +191,7 @@ shmem_check_acl(struct inode *inode, int
  * shmem_permission  -  permission() inode operation
  */
 int
-shmem_permission(struct inode *inode, int mask, struct nameidata *nd)
+shmem_permission(struct inode *inode, int mask, struct nameidata2 *nd)
 {
 	return generic_permission(inode, mask, shmem_check_acl);
 }
--- a/security/apparmor/lsm.c
+++ b/security/apparmor/lsm.c
@@ -352,7 +352,7 @@ out:
 }
 
 static int apparmor_inode_permission(struct inode *inode, int mask,
-				     struct nameidata *nd)
+				     struct nameidata2 *nd)
 {
 	int check = 0;
 
--- a/security/dummy.c
+++ b/security/dummy.c
@@ -329,7 +329,7 @@ static int dummy_inode_follow_link (stru
 	return 0;
 }
 
-static int dummy_inode_permission (struct inode *inode, int mask, struct nameidata *nd)
+static int dummy_inode_permission (struct inode *inode, int mask, struct nameidata2 *nd)
 {
 	return 0;
 }
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@ -2266,7 +2266,7 @@ static int selinux_inode_follow_link(str
 }
 
 static int selinux_inode_permission(struct inode *inode, int mask,
-				    struct nameidata *nd)
+				    struct nameidata2 *nd)
 {
 	int rc;
 
