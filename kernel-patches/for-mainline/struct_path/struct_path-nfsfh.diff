Index: linux-2.6/fs/nfsd/nfs2acl.c
===================================================================
--- linux-2.6.orig/fs/nfsd/nfs2acl.c
+++ linux-2.6/fs/nfsd/nfs2acl.c
@@ -62,7 +62,7 @@ static __be32 nfsacld_proc_getacl(struct
 		if (acl == NULL) {
 			/* Solaris returns the inode's minimum ACL. */
 
-			struct inode *inode = fh->fh_dentry->d_inode;
+			struct inode *inode = fh->fh_path.dentry->d_inode;
 			acl = posix_acl_from_mode(inode->i_mode, GFP_KERNEL);
 		}
 		resp->acl_access = acl;
@@ -220,7 +220,7 @@ static int nfsaclsvc_decode_accessargs(s
 static int nfsaclsvc_encode_getaclres(struct svc_rqst *rqstp, __be32 *p,
 		struct nfsd3_getaclres *resp)
 {
-	struct dentry *dentry = resp->fh.fh_dentry;
+	struct dentry *dentry = resp->fh.fh_path.dentry;
 	struct inode *inode = dentry->d_inode;
 	struct kvec *head = rqstp->rq_res.head;
 	unsigned int base;
Index: linux-2.6/fs/nfsd/nfs3acl.c
===================================================================
--- linux-2.6.orig/fs/nfsd/nfs3acl.c
+++ linux-2.6/fs/nfsd/nfs3acl.c
@@ -58,7 +58,7 @@ static __be32 nfsd3_proc_getacl(struct s
 		if (acl == NULL) {
 			/* Solaris returns the inode's minimum ACL. */
 
-			struct inode *inode = fh->fh_dentry->d_inode;
+			struct inode *inode = fh->fh_path.dentry->d_inode;
 			acl = posix_acl_from_mode(inode->i_mode, GFP_KERNEL);
 		}
 		resp->acl_access = acl;
@@ -166,7 +166,7 @@ static int nfs3svc_decode_setaclargs(str
 static int nfs3svc_encode_getaclres(struct svc_rqst *rqstp, __be32 *p,
 		struct nfsd3_getaclres *resp)
 {
-	struct dentry *dentry = resp->fh.fh_dentry;
+	struct dentry *dentry = resp->fh.fh_path.dentry;
 
 	p = nfs3svc_encode_post_op_attr(rqstp, p, &resp->fh);
 	if (resp->status == 0 && dentry && dentry->d_inode) {
Index: linux-2.6/fs/nfsd/nfs3proc.c
===================================================================
--- linux-2.6.orig/fs/nfsd/nfs3proc.c
+++ linux-2.6/fs/nfsd/nfs3proc.c
@@ -58,7 +58,6 @@ nfsd3_proc_getattr(struct svc_rqst *rqst
 {
 	int	err;
 	__be32	nfserr;
-	struct path path;
 
 	dprintk("nfsd: GETATTR(3)  %s\n",
 		SVCFH_fmt(&argp->fh));
@@ -68,9 +67,7 @@ nfsd3_proc_getattr(struct svc_rqst *rqst
 	if (nfserr)
 		RETURN_STATUS(nfserr);
 
-	path.mnt = resp->fh.fh_export->ex_mnt;
-	path.dentry = resp->fh.fh_dentry;
-	err = vfs_getattr(&path, &resp->stat);
+	err = vfs_getattr(&resp->fh.fh_path, &resp->stat);
 	nfserr = nfserrno(err);
 
 	RETURN_STATUS(nfserr);
@@ -187,7 +184,7 @@ nfsd3_proc_read(struct svc_rqst *rqstp, 
 			   	  rqstp->rq_vec, argp->vlen,
 				  &resp->count);
 	if (nfserr == 0) {
-		struct inode	*inode = resp->fh.fh_dentry->d_inode;
+		struct inode	*inode = resp->fh.fh_path.dentry->d_inode;
 
 		resp->eof = (argp->offset + resp->count) >= inode->i_size;
 	}
@@ -566,7 +563,7 @@ nfsd3_proc_fsinfo(struct svc_rqst * rqst
 	 * different read/write sizes for file systems known to have
 	 * problems with large blocks */
 	if (nfserr == 0) {
-		struct super_block *sb = argp->fh.fh_dentry->d_inode->i_sb;
+		struct super_block *sb = argp->fh.fh_path.dentry->d_inode->i_sb;
 
 		/* Note that we don't care for remote fs's here */
 		if (sb->s_magic == 0x4d44 /* MSDOS_SUPER_MAGIC */) {
@@ -602,7 +599,7 @@ nfsd3_proc_pathconf(struct svc_rqst * rq
 	nfserr = fh_verify(rqstp, &argp->fh, 0, MAY_NOP);
 
 	if (nfserr == 0) {
-		struct super_block *sb = argp->fh.fh_dentry->d_inode->i_sb;
+		struct super_block *sb = argp->fh.fh_path.dentry->d_inode->i_sb;
 
 		/* Note that we don't care for remote fs's here */
 		switch (sb->s_magic) {
Index: linux-2.6/fs/nfsd/nfs3xdr.c
===================================================================
--- linux-2.6.orig/fs/nfsd/nfs3xdr.c
+++ linux-2.6/fs/nfsd/nfs3xdr.c
@@ -153,7 +153,7 @@ static __be32 *
 encode_fattr3(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp,
 	      struct kstat *stat)
 {
-	struct dentry	*dentry = fhp->fh_dentry;
+	struct dentry	*dentry = fhp->fh_path.dentry;
 	struct timespec time;
 
 	*p++ = htonl(nfs3_ftypes[(stat->mode & S_IFMT) >> 12]);
@@ -185,7 +185,7 @@ encode_fattr3(struct svc_rqst *rqstp, __
 static __be32 *
 encode_saved_post_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)
 {
-	struct inode	*inode = fhp->fh_dentry->d_inode;
+	struct inode	*inode = fhp->fh_path.dentry->d_inode;
 
 	/* Attributes to follow */
 	*p++ = xdr_one;
@@ -223,15 +223,13 @@ encode_saved_post_attr(struct svc_rqst *
 static __be32 *
 encode_post_op_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)
 {
-	struct path path;
+	struct dentry *dentry = fhp->fh_path.dentry;
 
-	path.dentry = fhp->fh_dentry;
-	if (path.dentry && path.dentry->d_inode != NULL) {
+	if (dentry && dentry->d_inode != NULL) {
 	        int err;
 		struct kstat stat;
 
-		path.mnt = fhp->fh_export->ex_mnt;
-		err = vfs_getattr(&path, &stat);
+		err = vfs_getattr(&fhp->fh_path, &stat);
 		if (!err) {
 			*p++ = xdr_one;		/* attributes follow */
 			return encode_fattr3(rqstp, p, fhp, &stat);
@@ -254,7 +252,7 @@ nfs3svc_encode_post_op_attr(struct svc_r
 static __be32 *
 encode_wcc_data(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)
 {
-	struct dentry	*dentry = fhp->fh_dentry;
+	struct dentry	*dentry = fhp->fh_path.dentry;
 
 	if (dentry && dentry->d_inode && fhp->fh_post_saved) {
 		if (fhp->fh_pre_saved) {
@@ -808,7 +806,7 @@ compose_entry_fh(struct nfsd3_readdirres
 	struct dentry		*dparent, *dchild;
 	int rv = 0;
 
-	dparent = cd->fh.fh_dentry;
+	dparent = cd->fh.fh_path.dentry;
 	exp  = cd->fh.fh_export;
 
 	fh_init(fhp, NFS3_FHSIZE);
Index: linux-2.6/fs/nfsd/nfs4proc.c
===================================================================
--- linux-2.6.orig/fs/nfsd/nfs4proc.c
+++ linux-2.6/fs/nfsd/nfs4proc.c
@@ -54,7 +54,7 @@ static inline void
 fh_dup2(struct svc_fh *dst, struct svc_fh *src)
 {
 	fh_put(dst);
-	dget(src->fh_dentry);
+	dget(src->fh_path.dentry);
 	if (src->fh_export)
 		cache_get(&src->fh_export->h);
 	*dst = *src;
@@ -261,7 +261,7 @@ static __be32
 nfsd4_getfh(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 	    struct svc_fh **getfh)
 {
-	if (!cstate->current_fh.fh_dentry)
+	if (!cstate->current_fh.fh_path.dentry)
 		return nfserr_nofilehandle;
 
 	*getfh = &cstate->current_fh;
@@ -295,7 +295,7 @@ static __be32
 nfsd4_restorefh(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 		void *arg)
 {
-	if (!cstate->save_fh.fh_dentry)
+	if (!cstate->save_fh.fh_path.dentry)
 		return nfserr_restorefh;
 
 	fh_dup2(&cstate->current_fh, &cstate->save_fh);
@@ -306,7 +306,7 @@ static __be32
 nfsd4_savefh(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 	     void *arg)
 {
-	if (!cstate->current_fh.fh_dentry)
+	if (!cstate->current_fh.fh_path.dentry)
 		return nfserr_nofilehandle;
 
 	fh_dup2(&cstate->save_fh, &cstate->current_fh);
@@ -457,7 +457,7 @@ nfsd4_link(struct svc_rqst *rqstp, struc
 {
 	__be32 status = nfserr_nofilehandle;
 
-	if (!cstate->save_fh.fh_dentry)
+	if (!cstate->save_fh.fh_path.dentry)
 		return status;
 	status = nfsd_link(rqstp, &cstate->current_fh,
 			   link->li_name, link->li_namelen, &cstate->save_fh);
@@ -477,7 +477,7 @@ nfsd4_lookupp(struct svc_rqst *rqstp, st
 	if((ret = exp_pseudoroot(rqstp->rq_client, &tmp_fh,
 			      &rqstp->rq_chandle)) != 0)
 		return ret;
-	if (tmp_fh.fh_dentry == cstate->current_fh.fh_dentry) {
+	if (tmp_fh.fh_path.dentry == cstate->current_fh.fh_path.dentry) {
 		fh_put(&tmp_fh);
 		return nfserr_noent;
 	}
@@ -583,7 +583,7 @@ nfsd4_rename(struct svc_rqst *rqstp, str
 {
 	__be32 status = nfserr_nofilehandle;
 
-	if (!cstate->save_fh.fh_dentry)
+	if (!cstate->save_fh.fh_path.dentry)
 		return status;
 	if (nfs4_in_grace() && !(cstate->save_fh.fh_export->ex_flags
 					& NFSEXP_NOSUBTREECHECK))
@@ -597,8 +597,8 @@ nfsd4_rename(struct svc_rqst *rqstp, str
 	if (status == nfserr_isdir)
 		status = nfserr_exist;
 	else if ((status == nfserr_notdir) &&
-                  (S_ISDIR(cstate->save_fh.fh_dentry->d_inode->i_mode) &&
-                   S_ISDIR(cstate->current_fh.fh_dentry->d_inode->i_mode)))
+                  (S_ISDIR(cstate->save_fh.fh_path.dentry->d_inode->i_mode) &&
+                   S_ISDIR(cstate->current_fh.fh_path.dentry->d_inode->i_mode)))
 		status = nfserr_exist;
 	else if (status == nfserr_symlink)
 		status = nfserr_notdir;
@@ -716,7 +716,7 @@ _nfsd4_verify(struct svc_rqst *rqstp, st
 
 	status = nfsd4_encode_fattr(&cstate->current_fh,
 				    cstate->current_fh.fh_export,
-				    cstate->current_fh.fh_dentry, buf,
+				    &cstate->current_fh.fh_path, buf,
 				    &count, verify->ve_bmval,
 				    rqstp);
 
@@ -876,7 +876,7 @@ nfsd4_proc_compound(struct svc_rqst *rqs
 
 		opdesc = &nfsd4_ops[op->opnum];
 
-		if (!cstate->current_fh.fh_dentry) {
+		if (!cstate->current_fh.fh_path.dentry) {
 			if (!(opdesc->op_flags & ALLOWED_WITHOUT_FH)) {
 				op->status = nfserr_nofilehandle;
 				goto encode_op;
Index: linux-2.6/fs/nfsd/nfs4state.c
===================================================================
--- linux-2.6.orig/fs/nfsd/nfs4state.c
+++ linux-2.6/fs/nfsd/nfs4state.c
@@ -1286,7 +1286,7 @@ test_share(struct nfs4_stateid *stp, str
 static __be32
 nfs4_share_conflict(struct svc_fh *current_fh, unsigned int deny_type)
 {
-	struct inode *ino = current_fh->fh_dentry->d_inode;
+	struct inode *ino = current_fh->fh_path.dentry->d_inode;
 	struct nfs4_file *fp;
 	struct nfs4_stateid *stp;
 	__be32 ret;
@@ -1745,7 +1745,7 @@ __be32
 nfsd4_process_open2(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_open *open)
 {
 	struct nfs4_file *fp = NULL;
-	struct inode *ino = current_fh->fh_dentry->d_inode;
+	struct inode *ino = current_fh->fh_path.dentry->d_inode;
 	struct nfs4_stateid *stp = NULL;
 	struct nfs4_delegation *dp = NULL;
 	__be32 status;
@@ -1969,7 +1969,7 @@ search_close_lru(u32 st_id, int flags)
 static inline int
 nfs4_check_fh(struct svc_fh *fhp, struct nfs4_stateid *stp)
 {
-	return fhp->fh_dentry->d_inode != stp->st_vfs_file->f_path.dentry->d_inode;
+	return fhp->fh_path.dentry->d_inode != stp->st_vfs_file->f_path.dentry->d_inode;
 }
 
 static int
@@ -2052,7 +2052,7 @@ nfs4_preprocess_stateid_op(struct svc_fh
 	struct nfs4_stateid *stp = NULL;
 	struct nfs4_delegation *dp = NULL;
 	stateid_t *stidp;
-	struct inode *ino = current_fh->fh_dentry->d_inode;
+	struct inode *ino = current_fh->fh_path.dentry->d_inode;
 	__be32 status;
 
 	dprintk("NFSD: preprocess_stateid_op: stateid = (%08x/%08x/%08x/%08x)\n",
@@ -2253,8 +2253,8 @@ nfsd4_open_confirm(struct svc_rqst *rqst
 	struct nfs4_stateid *stp;
 
 	dprintk("NFSD: nfsd4_open_confirm on file %.*s\n",
-			(int)cstate->current_fh.fh_dentry->d_name.len,
-			cstate->current_fh.fh_dentry->d_name.name);
+			(int)cstate->current_fh.fh_path.dentry->d_name.len,
+			cstate->current_fh.fh_path.dentry->d_name.name);
 
 	status = fh_verify(rqstp, &cstate->current_fh, S_IFREG, 0);
 	if (status)
@@ -2324,8 +2324,8 @@ nfsd4_open_downgrade(struct svc_rqst *rq
 	unsigned int share_access;
 
 	dprintk("NFSD: nfsd4_open_downgrade on file %.*s\n", 
-			(int)cstate->current_fh.fh_dentry->d_name.len,
-			cstate->current_fh.fh_dentry->d_name.name);
+			(int)cstate->current_fh.fh_path.dentry->d_name.len,
+			cstate->current_fh.fh_path.dentry->d_name.name);
 
 	if (!access_valid(od->od_share_access)
 			|| !deny_valid(od->od_share_deny))
@@ -2380,8 +2380,8 @@ nfsd4_close(struct svc_rqst *rqstp, stru
 	struct nfs4_stateid *stp;
 
 	dprintk("NFSD: nfsd4_close on file %.*s\n", 
-			(int)cstate->current_fh.fh_dentry->d_name.len,
-			cstate->current_fh.fh_dentry->d_name.name);
+			(int)cstate->current_fh.fh_path.dentry->d_name.len,
+			cstate->current_fh.fh_path.dentry->d_name.name);
 
 	nfs4_lock_state();
 	/* check close_lru for replay */
@@ -2837,7 +2837,7 @@ nfsd4_lockt(struct svc_rqst *rqstp, stru
 		goto out;
 	}
 
-	inode = cstate->current_fh.fh_dentry->d_inode;
+	inode = cstate->current_fh.fh_path.dentry->d_inode;
 	locks_init_lock(&file_lock);
 	switch (lockt->lt_type) {
 		case NFS4_READ_LT:
@@ -2876,7 +2876,7 @@ nfsd4_lockt(struct svc_rqst *rqstp, stru
 	 * only the dentry:inode set.
 	 */
 	memset(&file, 0, sizeof (struct file));
-	file.f_path.dentry = cstate->current_fh.fh_dentry;
+	file.f_path.dentry = cstate->current_fh.fh_path.dentry;
 
 	status = nfs_ok;
 	if (posix_test_lock(&file, &file_lock, &conflock)) {
Index: linux-2.6/fs/nfsd/nfs4xdr.c
===================================================================
--- linux-2.6.orig/fs/nfsd/nfs4xdr.c
+++ linux-2.6/fs/nfsd/nfs4xdr.c
@@ -1424,7 +1424,7 @@ static __be32 fattr_handle_absent_fs(u32
  */
 __be32
 nfsd4_encode_fattr(struct svc_fh *fhp, struct svc_export *exp,
-		struct dentry *dentry, __be32 *buffer, int *countp, u32 *bmval,
+		struct path *path, __be32 *buffer, int *countp, u32 *bmval,
 		struct svc_rqst *rqstp)
 {
 	u32 bmval0 = bmval[0];
@@ -1442,7 +1442,7 @@ nfsd4_encode_fattr(struct svc_fh *fhp, s
 	int err;
 	int aclsupport = 0;
 	struct nfs4_acl *acl = NULL;
-	struct path path;
+	struct dentry *dentry = path->dentry;
 
 	BUG_ON(bmval1 & NFSD_WRITEONLY_ATTRS_WORD1);
 	BUG_ON(bmval0 & ~NFSD_SUPPORTED_ATTRS_WORD0);
@@ -1454,9 +1454,7 @@ nfsd4_encode_fattr(struct svc_fh *fhp, s
 			goto out;
 	}
 
-	path.mnt = exp->ex_mnt;
-	path.dentry = dentry;
-	err = vfs_getattr(&path, &stat);
+	err = vfs_getattr(path, &stat);
 	if (err)
 		goto out_nfserr;
 	if ((bmval0 & (FATTR4_WORD0_FILES_FREE | FATTR4_WORD0_FILES_TOTAL)) ||
@@ -1839,28 +1837,29 @@ nfsd4_encode_dirent_fattr(struct nfsd4_r
 		const char *name, int namlen, __be32 *p, int *buflen)
 {
 	struct svc_export *exp = cd->rd_fhp->fh_export;
-	struct dentry *dentry;
+	struct path path;
 	__be32 nfserr;
 
-	dentry = lookup_one_len(name, cd->rd_fhp->fh_dentry, namlen);
-	if (IS_ERR(dentry))
-		return nfserrno(PTR_ERR(dentry));
+	path.dentry = lookup_one_len(name, cd->rd_fhp->fh_path.dentry, namlen);
+	if (IS_ERR(path.dentry))
+		return nfserrno(PTR_ERR(path.dentry));
 
 	exp_get(exp);
-	if (d_mountpoint(dentry)) {
+	if (d_mountpoint(path.dentry)) {
 		int err;
 
-		err = nfsd_cross_mnt(cd->rd_rqstp, &dentry, &exp);
+		err = nfsd_cross_mnt(cd->rd_rqstp, &path.dentry, &exp);
 		if (err) {
 			nfserr = nfserrno(err);
 			goto out_put;
 		}
 
 	}
-	nfserr = nfsd4_encode_fattr(NULL, exp, dentry, p, buflen, cd->rd_bmval,
+	path.mnt = exp->ex_mnt;
+	nfserr = nfsd4_encode_fattr(NULL, exp, &path, p, buflen, cd->rd_bmval,
 					cd->rd_rqstp);
 out_put:
-	dput(dentry);
+	dput(path.dentry);
 	exp_put(exp);
 	return nfserr;
 }
@@ -2010,7 +2009,7 @@ nfsd4_encode_getattr(struct nfsd4_compou
 		return nfserr;
 
 	buflen = resp->end - resp->p - (COMPOUND_ERR_SLACK_SPACE >> 2);
-	nfserr = nfsd4_encode_fattr(fhp, fhp->fh_export, fhp->fh_dentry,
+	nfserr = nfsd4_encode_fattr(fhp, fhp->fh_export, &fhp->fh_path,
 				    resp->p, &buflen, getattr->ga_bmval,
 				    resp->rqstp);
 	if (!nfserr)
@@ -2248,7 +2247,7 @@ nfsd4_encode_read(struct nfsd4_compoundr
 	if (nfserr)
 		return nfserr;
 	eof = (read->rd_offset + maxcount >=
-	       read->rd_fhp->fh_dentry->d_inode->i_size);
+	       read->rd_fhp->fh_path.dentry->d_inode->i_size);
 
 	WRITE32(eof);
 	WRITE32(maxcount);
Index: linux-2.6/fs/nfsd/nfsfh.c
===================================================================
--- linux-2.6.orig/fs/nfsd/nfsfh.c
+++ linux-2.6/fs/nfsd/nfsfh.c
@@ -123,7 +123,7 @@ fh_verify(struct svc_rqst *rqstp, struct
 	/* keep this filehandle for possible reference  when encoding attributes */
 	rqstp->rq_reffh = fh;
 
-	if (!fhp->fh_dentry) {
+	if (!fhp->fh_path.dentry) {
 		__u32 *datap=NULL;
 		__u32 tfh[3];		/* filehandle fragment for oldstyle filehandles */
 		int fileid_type;
@@ -238,7 +238,7 @@ fh_verify(struct svc_rqst *rqstp, struct
 		}
 #endif
 
-		fhp->fh_dentry = dentry;
+		fhp->fh_path.dentry = dentry;
 		fhp->fh_export = exp;
 		nfsd_nr_verified++;
 	} else {
@@ -246,7 +246,7 @@ fh_verify(struct svc_rqst *rqstp, struct
 		 * (e.g. nfsproc_create calls fh_verify, then nfsd_create does as well)
 		 */
 		dprintk("nfsd: fh_verify - just checking\n");
-		dentry = fhp->fh_dentry;
+		dentry = fhp->fh_path.dentry;
 		exp = fhp->fh_export;
 		/* Set user creds for this exportpoint; necessary even
 		 * in the "just checking" case because this may be a
@@ -372,7 +372,7 @@ fh_compose(struct svc_fh *fhp, struct sv
 	if (ref_fh == fhp)
 		fh_put(ref_fh);
 
-	if (fhp->fh_locked || fhp->fh_dentry) {
+	if (fhp->fh_locked || fhp->fh_path.dentry) {
 		printk(KERN_ERR "fh_compose: fh %s/%s not initialized!\n",
 			parent->d_name.name, dentry->d_name.name);
 	}
@@ -380,7 +380,8 @@ fh_compose(struct svc_fh *fhp, struct sv
 		printk(KERN_ERR "fh_compose: called with maxsize %d! %s/%s\n",
 		       fhp->fh_maxsize, parent->d_name.name, dentry->d_name.name);
 
-	fhp->fh_dentry = dget(dentry); /* our internal copy */
+	fhp->fh_path.mnt = exp->ex_mnt;  /* FIXME: can this get released while we still keep the copy here? Probably not... */
+	fhp->fh_path.dentry = dget(dentry); /* our internal copy */
 	fhp->fh_export = exp;
 	cache_get(&exp->h);
 
@@ -459,10 +460,10 @@ fh_update(struct svc_fh *fhp)
 	struct dentry *dentry;
 	__u32 *datap;
 	
-	if (!fhp->fh_dentry)
+	if (!fhp->fh_path.dentry)
 		goto out_bad;
 
-	dentry = fhp->fh_dentry;
+	dentry = fhp->fh_path.dentry;
 	if (!dentry->d_inode)
 		goto out_negative;
 	if (fhp->fh_handle.fh_version != 1) {
@@ -498,11 +499,11 @@ out_negative:
 void
 fh_put(struct svc_fh *fhp)
 {
-	struct dentry * dentry = fhp->fh_dentry;
+	struct dentry * dentry = fhp->fh_path.dentry;
 	struct svc_export * exp = fhp->fh_export;
 	if (dentry) {
 		fh_unlock(fhp);
-		fhp->fh_dentry = NULL;
+		fhp->fh_path.dentry = NULL;
 		dput(dentry);
 #ifdef CONFIG_NFSD_V3
 		fhp->fh_pre_saved = 0;
Index: linux-2.6/fs/nfsd/nfsproc.c
===================================================================
--- linux-2.6.orig/fs/nfsd/nfsproc.c
+++ linux-2.6/fs/nfsd/nfsproc.c
@@ -39,25 +39,17 @@ nfsd_proc_null(struct svc_rqst *rqstp, v
 static __be32
 nfsd_return_attrs(__be32 err, struct nfsd_attrstat *resp)
 {
-	struct path path;
-
 	if (err)
 		return err;
-	path.mnt = resp->fh.fh_export->ex_mnt;
-	path.dentry = resp->fh.fh_dentry;
-	return nfserrno(vfs_getattr(&path, &resp->stat));
+	return nfserrno(vfs_getattr(&resp->fh.fh_path, &resp->stat));
 }
 
 static __be32
 nfsd_return_dirop(__be32 err, struct nfsd_diropres *resp)
 {
-	struct path path;
-
 	if (err)
 		return err;
-	path.mnt = resp->fh.fh_export->ex_mnt;
-	path.dentry = resp->fh.fh_dentry;
-	return nfserrno(vfs_getattr(&path, &resp->stat));
+	return nfserrno(vfs_getattr(&resp->fh.fh_path, &resp->stat));
 }
 /*
  * Get a file's attributes
@@ -143,7 +135,6 @@ static __be32
 nfsd_proc_read(struct svc_rqst *rqstp, struct nfsd_readargs *argp,
 				       struct nfsd_readres  *resp)
 {
-	struct path path;
 	__be32	nfserr;
 
 	dprintk("nfsd: READ    %s %d bytes at %d\n",
@@ -172,9 +163,7 @@ nfsd_proc_read(struct svc_rqst *rqstp, s
 
 	if (nfserr)
 		return nfserr;
-	path.mnt = resp->fh.fh_export->ex_mnt;
-	path.dentry = resp->fh.fh_dentry;
-	return nfserrno(vfs_getattr(&path, &resp->stat));
+	return nfserrno(vfs_getattr(&resp->fh.fh_path, &resp->stat));
 }
 
 /*
@@ -236,7 +225,7 @@ nfsd_proc_create(struct svc_rqst *rqstp,
 	if (isdotent(argp->name, argp->len))
 		goto done;
 	fh_lock_nested(dirfhp, I_MUTEX_PARENT);
-	dchild = lookup_one_len(argp->name, dirfhp->fh_dentry, argp->len);
+	dchild = lookup_one_len(argp->name, dirfhp->fh_path.dentry, argp->len);
 	if (IS_ERR(dchild)) {
 		nfserr = nfserrno(PTR_ERR(dchild));
 		goto out_unlock;
@@ -254,14 +243,14 @@ nfsd_proc_create(struct svc_rqst *rqstp,
 		 * whether the file exists or not. Time to bail ...
 		 */
 		nfserr = nfserr_acces;
-		if (!newfhp->fh_dentry) {
+		if (!newfhp->fh_path.dentry) {
 			printk(KERN_WARNING 
 				"nfsd_proc_create: file handle not verified\n");
 			goto out_unlock;
 		}
 	}
 
-	inode = newfhp->fh_dentry->d_inode;
+	inode = newfhp->fh_path.dentry->d_inode;
 
 	/* Unfudge the mode bits */
 	if (attr->ia_valid & ATTR_MODE) {
@@ -286,9 +275,10 @@ nfsd_proc_create(struct svc_rqst *rqstp,
 					 *   echo thing > device-special-file-or-pipe
 					 * by doing a CREATE with type==0
 					 */
-					nfserr = nfsd_permission(newfhp->fh_export,
-								 newfhp->fh_dentry,
-								 MAY_WRITE|MAY_LOCAL_ACCESS);
+					nfserr = nfsd_permission(
+						newfhp->fh_export,
+						newfhp->fh_path.dentry,
+						MAY_WRITE|MAY_LOCAL_ACCESS);
 					if (nfserr && nfserr != nfserr_rofs)
 						goto out_unlock;
 				}
@@ -448,7 +438,7 @@ nfsd_proc_mkdir(struct svc_rqst *rqstp, 
 
 	dprintk("nfsd: MKDIR    %s %.*s\n", SVCFH_fmt(&argp->fh), argp->len, argp->name);
 
-	if (resp->fh.fh_dentry) {
+	if (resp->fh.fh_path.dentry) {
 		printk(KERN_WARNING
 			"nfsd_proc_mkdir: response already verified??\n");
 	}
Index: linux-2.6/fs/nfsd/nfsxdr.c
===================================================================
--- linux-2.6.orig/fs/nfsd/nfsxdr.c
+++ linux-2.6/fs/nfsd/nfsxdr.c
@@ -150,7 +150,7 @@ static __be32 *
 encode_fattr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp,
 	     struct kstat *stat)
 {
-	struct dentry	*dentry = fhp->fh_dentry;
+	struct dentry	*dentry = fhp->fh_path.dentry;
 	int type;
 	struct timespec time;
 
@@ -193,11 +193,8 @@ encode_fattr(struct svc_rqst *rqstp, __b
 __be32 *nfs2svc_encode_fattr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)
 {
 	struct kstat stat;
-	struct path path;
 
-	path.mnt = fhp->fh_export->ex_mnt;
-	path.dentry = fhp->fh_dentry;
-	vfs_getattr(&path, &stat);
+	vfs_getattr(&fhp->fh_path, &stat);
 	return encode_fattr(rqstp, p, fhp, &stat);
 }
 
Index: linux-2.6/fs/nfsd/vfs.c
===================================================================
--- linux-2.6.orig/fs/nfsd/vfs.c
+++ linux-2.6/fs/nfsd/vfs.c
@@ -165,7 +165,7 @@ nfsd_lookup(struct svc_rqst *rqstp, stru
 	if (err)
 		return err;
 
-	dparent = fhp->fh_dentry;
+	dparent = fhp->fh_path.dentry;
 	exp  = fhp->fh_export;
 	exp_get(exp);
 
@@ -268,7 +268,7 @@ nfsd_setattr(struct svc_rqst *rqstp, str
 	if (err)
 		goto out;
 
-	dentry = fhp->fh_dentry;
+	dentry = fhp->fh_path.dentry;
 	inode = dentry->d_inode;
 
 	/* Ignore any mode updates on symlinks */
@@ -438,7 +438,7 @@ nfsd4_set_nfs4_acl(struct svc_rqst *rqst
 	if (error)
 		goto out;
 
-	dentry = fhp->fh_dentry;
+	dentry = fhp->fh_path.dentry;
 	inode = dentry->d_inode;
 	if (S_ISDIR(inode->i_mode))
 		flags = NFS4_ACL_DIR;
@@ -588,7 +588,7 @@ nfsd_access(struct svc_rqst *rqstp, stru
 		goto out;
 
 	export = fhp->fh_export;
-	dentry = fhp->fh_dentry;
+	dentry = fhp->fh_path.dentry;
 
 	if (S_ISREG(dentry->d_inode->i_mode))
 		map = nfs3_regaccess;
@@ -659,7 +659,7 @@ nfsd_open(struct svc_rqst *rqstp, struct
 	if (err)
 		goto out;
 
-	dentry = fhp->fh_dentry;
+	dentry = fhp->fh_path.dentry;
 	inode = dentry->d_inode;
 
 	/* Disallow write access to files with the append-only bit set
@@ -1016,7 +1016,7 @@ nfsd_read(struct svc_rqst *rqstp, struct
 	__be32		err;
 
 	if (file) {
-		err = nfsd_permission(fhp->fh_export, fhp->fh_dentry,
+		err = nfsd_permission(fhp->fh_export, fhp->fh_path.dentry,
 				MAY_READ|MAY_OWNER_OVERRIDE);
 		if (err)
 			goto out;
@@ -1045,7 +1045,7 @@ nfsd_write(struct svc_rqst *rqstp, struc
 	__be32			err = 0;
 
 	if (file) {
-		err = nfsd_permission(fhp->fh_export, fhp->fh_dentry,
+		err = nfsd_permission(fhp->fh_export, fhp->fh_path.dentry,
 				MAY_WRITE|MAY_OWNER_OVERRIDE);
 		if (err)
 			goto out;
@@ -1128,7 +1128,7 @@ nfsd_create(struct svc_rqst *rqstp, stru
 	if (err)
 		goto out;
 
-	dentry = fhp->fh_dentry;
+	dentry = fhp->fh_path.dentry;
 	dirp = dentry->d_inode;
 
 	err = nfserr_notdir;
@@ -1138,7 +1138,7 @@ nfsd_create(struct svc_rqst *rqstp, stru
 	 * Check whether the response file handle has been verified yet.
 	 * If it has, the parent directory should already be locked.
 	 */
-	if (!resfhp->fh_dentry) {
+	if (!resfhp->fh_path.dentry) {
 		/* called from nfsd_proc_mkdir, or possibly nfsd3_proc_create */
 		fh_lock_nested(fhp, I_MUTEX_PARENT);
 		dchild = lookup_one_len(fname, dentry, flen);
@@ -1150,7 +1150,7 @@ nfsd_create(struct svc_rqst *rqstp, stru
 			goto out;
 	} else {
 		/* called from nfsd_proc_create */
-		dchild = dget(resfhp->fh_dentry);
+		dchild = dget(resfhp->fh_path.dentry);
 		if (!fhp->fh_locked) {
 			/* not actually possible */
 			printk(KERN_ERR
@@ -1258,7 +1258,7 @@ nfsd_create_v3(struct svc_rqst *rqstp, s
 	if (err)
 		goto out;
 
-	dentry = fhp->fh_dentry;
+	dentry = fhp->fh_path.dentry;
 	dirp = dentry->d_inode;
 
 	/* Get all the sanity checks out of the way before
@@ -1391,7 +1391,7 @@ nfsd_readlink(struct svc_rqst *rqstp, st
 	if (err)
 		goto out;
 
-	dentry = fhp->fh_dentry;
+	dentry = fhp->fh_path.dentry;
 	inode = dentry->d_inode;
 
 	err = nfserr_inval;
@@ -1446,7 +1446,7 @@ nfsd_symlink(struct svc_rqst *rqstp, str
 	if (err)
 		goto out;
 	fh_lock(fhp);
-	dentry = fhp->fh_dentry;
+	dentry = fhp->fh_path.dentry;
 	dnew = lookup_one_len(fname, dentry, flen);
 	host_err = PTR_ERR(dnew);
 	if (IS_ERR(dnew))
@@ -1516,7 +1516,7 @@ nfsd_link(struct svc_rqst *rqstp, struct
 		goto out;
 
 	fh_lock_nested(ffhp, I_MUTEX_PARENT);
-	ddir = ffhp->fh_dentry;
+	ddir = ffhp->fh_path.dentry;
 	dirp = ddir->d_inode;
 
 	dnew = lookup_one_len(name, ddir, len);
@@ -1524,7 +1524,7 @@ nfsd_link(struct svc_rqst *rqstp, struct
 	if (IS_ERR(dnew))
 		goto out_nfserr;
 
-	dold = tfhp->fh_dentry;
+	dold = tfhp->fh_path.dentry;
 	dest = dold->d_inode;
 
 	host_err = vfs_link(dold, dirp, dnew);
@@ -1572,10 +1572,10 @@ nfsd_rename(struct svc_rqst *rqstp, stru
 	if (err)
 		goto out;
 
-	fdentry = ffhp->fh_dentry;
+	fdentry = ffhp->fh_path.dentry;
 	fdir = fdentry->d_inode;
 
-	tdentry = tfhp->fh_dentry;
+	tdentry = tfhp->fh_path.dentry;
 	tdir = tdentry->d_inode;
 
 	err = (rqstp->rq_vers == 2) ? nfserr_acces : nfserr_xdev;
@@ -1668,7 +1668,7 @@ nfsd_unlink(struct svc_rqst *rqstp, stru
 		goto out;
 
 	fh_lock_nested(fhp, I_MUTEX_PARENT);
-	dentry = fhp->fh_dentry;
+	dentry = fhp->fh_path.dentry;
 	dirp = dentry->d_inode;
 
 	rdentry = lookup_one_len(fname, dentry, flen);
@@ -1765,7 +1765,7 @@ __be32
 nfsd_statfs(struct svc_rqst *rqstp, struct svc_fh *fhp, struct kstatfs *stat)
 {
 	__be32 err = fh_verify(rqstp, fhp, 0, MAY_NOP);
-	if (!err && vfs_statfs(fhp->fh_dentry,stat))
+	if (!err && vfs_statfs(fhp->fh_path.dentry,stat))
 		err = nfserr_io;
 	return err;
 }
@@ -1904,7 +1904,7 @@ nfsd_racache_init(int cache_size)
 struct posix_acl *
 nfsd_get_posix_acl(struct svc_fh *fhp, int type)
 {
-	struct inode *inode = fhp->fh_dentry->d_inode;
+	struct inode *inode = fhp->fh_path.dentry->d_inode;
 	char *name;
 	void *value = NULL;
 	ssize_t size;
@@ -1924,7 +1924,7 @@ nfsd_get_posix_acl(struct svc_fh *fhp, i
 		return ERR_PTR(-EOPNOTSUPP);
 	}
 
-	size = nfsd_getxattr(fhp->fh_dentry, name, &value);
+	size = nfsd_getxattr(fhp->fh_path.dentry, name, &value);
 	if (size < 0)
 		return ERR_PTR(size);
 
@@ -1936,7 +1936,7 @@ nfsd_get_posix_acl(struct svc_fh *fhp, i
 int
 nfsd_set_posix_acl(struct svc_fh *fhp, int type, struct posix_acl *acl)
 {
-	struct inode *inode = fhp->fh_dentry->d_inode;
+	struct inode *inode = fhp->fh_path.dentry->d_inode;
 	char *name;
 	void *value = NULL;
 	size_t size;
@@ -1969,12 +1969,12 @@ nfsd_set_posix_acl(struct svc_fh *fhp, i
 		size = 0;
 
 	if (size)
-		error = vfs_setxattr(fhp->fh_dentry, name, value, size, 0);
+		error = vfs_setxattr(fhp->fh_path.dentry, name, value, size, 0);
 	else {
 		if (!S_ISDIR(inode->i_mode) && type == ACL_TYPE_DEFAULT)
 			error = 0;
 		else {
-			error = vfs_removexattr(fhp->fh_dentry, name);
+			error = vfs_removexattr(fhp->fh_path.dentry, name);
 			if (error == -ENODATA)
 				error = 0;
 		}
Index: linux-2.6/include/linux/nfsd/nfsfh.h
===================================================================
--- linux-2.6.orig/include/linux/nfsd/nfsfh.h
+++ linux-2.6/include/linux/nfsd/nfsfh.h
@@ -134,7 +134,7 @@ static inline ino_t u32_to_ino_t(__u32 u
  */
 typedef struct svc_fh {
 	struct knfsd_fh		fh_handle;	/* FH data */
-	struct dentry *		fh_dentry;	/* validated dentry */
+	struct path		fh_path;	/* validated path */
 	struct svc_export *	fh_export;	/* export pointer */
 	int			fh_maxsize;	/* max size for fh_handle */
 
@@ -217,7 +217,7 @@ void	fh_put(struct svc_fh *);
 static __inline__ struct svc_fh *
 fh_copy(struct svc_fh *dst, struct svc_fh *src)
 {
-	WARN_ON(src->fh_dentry || src->fh_locked);
+	WARN_ON(src->fh_path.dentry || src->fh_locked);
 			
 	*dst = *src;
 	return dst;
@@ -240,7 +240,7 @@ fill_pre_wcc(struct svc_fh *fhp)
 {
 	struct inode    *inode;
 
-	inode = fhp->fh_dentry->d_inode;
+	inode = fhp->fh_path.dentry->d_inode;
 	if (!fhp->fh_pre_saved) {
 		fhp->fh_pre_mtime = inode->i_mtime;
 		fhp->fh_pre_ctime = inode->i_ctime;
@@ -255,7 +255,7 @@ fill_pre_wcc(struct svc_fh *fhp)
 static inline void
 fill_post_wcc(struct svc_fh *fhp)
 {
-	struct inode    *inode = fhp->fh_dentry->d_inode;
+	struct inode    *inode = fhp->fh_path.dentry->d_inode;
 
 	if (fhp->fh_post_saved)
 		printk("nfsd: inode locked twice during operation.\n");
@@ -290,7 +290,7 @@ fill_post_wcc(struct svc_fh *fhp)
 static inline void
 fh_lock_nested(struct svc_fh *fhp, unsigned int subclass)
 {
-	struct dentry	*dentry = fhp->fh_dentry;
+	struct dentry	*dentry = fhp->fh_path.dentry;
 	struct inode	*inode;
 
 	dfprintk(FILEOP, "nfsd: fh_lock(%s) locked = %d\n",
@@ -322,11 +322,11 @@ fh_lock(struct svc_fh *fhp)
 static inline void
 fh_unlock(struct svc_fh *fhp)
 {
-	BUG_ON(!fhp->fh_dentry);
+	BUG_ON(!fhp->fh_path.dentry);
 
 	if (fhp->fh_locked) {
 		fill_post_wcc(fhp);
-		mutex_unlock(&fhp->fh_dentry->d_inode->i_mutex);
+		mutex_unlock(&fhp->fh_path.dentry->d_inode->i_mutex);
 		fhp->fh_locked = 0;
 	}
 }
Index: linux-2.6/include/linux/nfsd/xdr4.h
===================================================================
--- linux-2.6.orig/include/linux/nfsd/xdr4.h
+++ linux-2.6/include/linux/nfsd/xdr4.h
@@ -433,7 +433,7 @@ int nfs4svc_encode_compoundres(struct sv
 void nfsd4_encode_operation(struct nfsd4_compoundres *, struct nfsd4_op *);
 void nfsd4_encode_replay(struct nfsd4_compoundres *resp, struct nfsd4_op *op);
 __be32 nfsd4_encode_fattr(struct svc_fh *fhp, struct svc_export *exp,
-		       struct dentry *dentry, __be32 *buffer, int *countp,
+		       struct path *path, __be32 *buffer, int *countp,
 		       u32 *bmval, struct svc_rqst *);
 extern __be32 nfsd4_setclientid(struct svc_rqst *rqstp,
 		struct nfsd4_compound_state *,
