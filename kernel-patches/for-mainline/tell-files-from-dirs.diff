Append a slash to the pathname we check against whenever we check
for access to a directory (for whichever operation, not only mkdir
and rmdir). This allows us to tell directories from non-directories
in profiles if we care, e.g.,

	/tmp/foo	<= a non-directory
	/tmp/foo/	<= a directory
	/tmp/*		<= any non-directory
	/tmp/**		<= files as well as directories

And more bizarre:

	/tmp/**/	<= directories at any depth
	/tmp/**[^/]	<= non-directories at any depth (not currently
			   passed through by the pasrer, but you get the
			   idea)

This prevents proceses from creating directories where they shouldn't,
or dropping entire directory hierarchies into places with rename.

Index: b/security/apparmor/main.c
===================================================================
--- a/security/apparmor/main.c
+++ b/security/apparmor/main.c
@@ -160,17 +160,20 @@ static int aa_link_perm(struct aa_profil
 }
 
 static char *aa_get_name(struct dentry *dentry, struct vfsmount *mnt,
-			 char **buffer)
+			 char **buffer, int is_dir)
 {
 	char *name;
 	int size = 256;
 
+	/* Make sure is_dir is either 0 or 1. */
+	is_dir = !!is_dir;
+
 	for (;;) {
 		char *buf = kmalloc(size, GFP_KERNEL);
 		if (!buf)
 			return ERR_PTR(-ENOMEM);
 
-		name = d_namespace_path(dentry, mnt, buf, size);
+		name = d_namespace_path(dentry, mnt, buf, size - is_dir);
 		if (!IS_ERR(name)) {
 			if (name[0] != '/') {
 				/*
@@ -180,6 +183,16 @@ static char *aa_get_name(struct dentry *
 				kfree(buf);
 				return ERR_PTR(-ENOENT);
 			}
+			if (is_dir && name[1] != '\0') {
+				/*
+				 * Append "/" to the pathname. The root
+				 * directory is a special case; it already
+				 * ends in slash.
+				 */
+				buf[size - 2] = '/';
+				buf[size - 1] = '\0';
+			}
+
 			*buffer = buf;
 			return name;
 		}
@@ -199,12 +212,13 @@ static inline void aa_put_name_buffer(ch
 }
 
 static int _aa_perm_vfsmount(struct aa_profile *profile, struct dentry *dentry,
-		      struct vfsmount *mnt, struct aa_audit *sa, int mask)
+		      struct vfsmount *mnt, struct aa_audit *sa, int mask,
+		      int is_dir)
 {
 	char *buffer = NULL;
 	int permerror, error;
 
-	sa->name = aa_get_name(dentry, mnt, &buffer);
+	sa->name = aa_get_name(dentry, mnt, &buffer, is_dir);
 
 	if (IS_ERR(sa->name)) {
 		permerror = PTR_ERR(sa->name);
@@ -542,7 +556,8 @@ int aa_attr(struct aa_profile *profile, 
 	sa.flags = 0;
 	sa.gfp_mask = GFP_KERNEL;
 
-	error = _aa_perm_vfsmount(profile, dentry, mnt, &sa, MAY_WRITE);
+	error = _aa_perm_vfsmount(profile, dentry, mnt, &sa, MAY_WRITE,
+				  S_ISDIR(dentry->d_inode->i_mode));
 
 	return error;
 }
@@ -569,7 +584,8 @@ int aa_perm_xattr(struct aa_profile *pro
 	sa.flags = 0;
 	sa.gfp_mask = GFP_KERNEL;
 
-	error = _aa_perm_vfsmount(profile, dentry, mnt, &sa, mask);
+	error = _aa_perm_vfsmount(profile, dentry, mnt, &sa, mask,
+				  S_ISDIR(dentry->d_inode->i_mode));
 
 	return error;
 }
@@ -610,7 +626,8 @@ int aa_perm(struct aa_profile *profile, 
 	sa.mask = mask;
 	sa.flags = 0;
 	sa.gfp_mask = GFP_KERNEL;
-	error = _aa_perm_vfsmount(profile, dentry, mnt, &sa, mask);
+	error = _aa_perm_vfsmount(profile, dentry, mnt, &sa, mask,
+				  S_ISDIR(inode->i_mode));
 
 out:
 	return error;
@@ -638,7 +655,7 @@ int aa_perm_dir(struct aa_profile *profi
 	sa.flags = 0;
 	sa.gfp_mask = GFP_KERNEL;
 
-	return _aa_perm_vfsmount(profile, dentry, mnt, &sa, mask);
+	return _aa_perm_vfsmount(profile, dentry, mnt, &sa, mask, 1);
 }
 
 /**
@@ -691,8 +708,8 @@ int aa_link(struct aa_profile *profile,
 	int permerror = -EPERM, error;
 	struct aa_audit sa;
 
-	sa.name = aa_get_name(link, link_mnt, &name_buffer);
-	sa.pval = aa_get_name(target, target_mnt, &pval_buffer);
+	sa.name = aa_get_name(link, link_mnt, &name_buffer, 0);
+	sa.pval = aa_get_name(target, target_mnt, &pval_buffer, 0);
 
 	if (IS_ERR(sa.name)) {
 		permerror = PTR_ERR(sa.name);
@@ -828,7 +845,7 @@ int aa_register(struct linux_binprm *bpr
 
 	AA_DEBUG("%s\n", __FUNCTION__);
 
-	filename = aa_get_name(filp->f_dentry, filp->f_vfsmnt, &buffer);
+	filename = aa_get_name(filp->f_dentry, filp->f_vfsmnt, &buffer, 0);
 	if (IS_ERR(filename)) {
 		AA_WARN("%s: Failed to get filename\n", __FUNCTION__);
 		return -ENOENT;
