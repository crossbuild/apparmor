---
 fs/ecryptfs/inode.c |   10 +++++-----
 fs/namei.c          |    9 ++++-----
 fs/nfsd/vfs.c       |    4 ++--
 include/linux/fs.h  |    2 +-
 ipc/mqueue.c        |   11 +++++------
 5 files changed, 17 insertions(+), 19 deletions(-)

--- a/fs/ecryptfs/inode.c
+++ b/fs/ecryptfs/inode.c
@@ -67,7 +67,7 @@ static void unlock_dir(struct dentry *di
  * Returns zero on success; non-zero on error condition
  */
 static int
-ecryptfs_create_underlying_file(struct inode *lower_dir_inode,
+ecryptfs_create_underlying_file(struct dentry *lower_dir_dentry,
 				struct dentry *dentry, int mode,
 				struct nameidata2 *nd)
 {
@@ -79,9 +79,9 @@ ecryptfs_create_underlying_file(struct i
 
 	dentry_save = nd->dentry;
 	vfsmount_save = nd->mnt;
-	nd->dentry = lower_dentry;
+	nd->dentry = lower_dir_dentry;
 	nd->mnt = lower_mnt;
-	rc = vfs_create(lower_dir_inode, lower_dentry, mode, nd);
+	rc = vfs_create(nd, lower_dentry, mode);
 	nd->dentry = dentry_save;
 	nd->mnt = vfsmount_save;
 	return rc;
@@ -117,8 +117,8 @@ ecryptfs_do_create(struct inode *directo
 		rc = PTR_ERR(lower_dir_dentry);
 		goto out;
 	}
-	rc = ecryptfs_create_underlying_file(lower_dir_dentry->d_inode,
-					     ecryptfs_dentry, mode, nd);
+	rc = ecryptfs_create_underlying_file(lower_dir_dentry, ecryptfs_dentry,
+					     mode, nd);
 	if (unlikely(rc)) {
 		ecryptfs_printk(KERN_ERR,
 				"Failure to create underlying file\n");
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -1495,9 +1495,9 @@ void unlock_rename(struct dentry *p1, st
 	}
 }
 
-int vfs_create(struct inode *dir, struct dentry *dentry, int mode,
-		struct nameidata2 *nd)
+int vfs_create(struct nameidata2 *nd, struct dentry *dentry, int mode)
 {
+	struct inode *dir = nd->dentry->d_inode;
 	int error = may_create(dir, dentry, nd);
 
 	if (error)
@@ -1605,7 +1605,7 @@ static int open_namei_create(struct name
 
 	if (!IS_POSIXACL(dir->d_inode))
 		mode &= ~current->fs->umask;
-	error = vfs_create(dir->d_inode, path->dentry, mode, ND2(nd));
+	error = vfs_create(ND2(nd), path->dentry, mode);
 	mutex_unlock(&dir->d_inode->i_mutex);
 	dput(nd->dentry);
 	nd->dentry = path->dentry;
@@ -1891,8 +1891,7 @@ asmlinkage long sys_mknodat(int dfd, con
 	if (!IS_ERR(dentry)) {
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
-			error = vfs_create(nd.dentry->d_inode, dentry, mode,
-					   ND2(&nd));
+			error = vfs_create(ND2(&nd), dentry, mode);
 			break;
 		case S_IFCHR: case S_IFBLK:
 			error = vfs_mknod(nd.dentry->d_inode, dentry, nd.mnt,
--- a/fs/nfsd/vfs.c
+++ b/fs/nfsd/vfs.c
@@ -1194,7 +1194,7 @@ nfsd_create(struct svc_rqst *rqstp, stru
 	err = 0;
 	switch (type) {
 	case S_IFREG:
-		host_err = vfs_create(nd.dentry->d_inode, dchild, iap->ia_mode, &nd);
+		host_err = vfs_create(&nd, dchild, iap->ia_mode);
 		break;
 	case S_IFDIR:
 		host_err = vfs_mkdir(dirp, dchild, exp->ex_mnt, iap->ia_mode);
@@ -1340,7 +1340,7 @@ nfsd_create_v3(struct svc_rqst *rqstp, s
 		goto out;
 	}
 
-	host_err = vfs_create(nd.dentry->d_inode, dchild, iap->ia_mode, &nd);
+	host_err = vfs_create(&nd, dchild, iap->ia_mode);
 	if (host_err < 0)
 		goto out_nfserr;
 	if (created)
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -983,7 +983,7 @@ extern void unlock_super(struct super_bl
  * VFS helper functions..
  */
 extern int vfs_permission(struct nameidata2 *, int);
-extern int vfs_create(struct inode *, struct dentry *, int, struct nameidata2 *);
+extern int vfs_create(struct nameidata2 *, struct dentry *, int);
 extern int vfs_mkdir(struct inode *, struct dentry *, struct vfsmount *, int);
 extern int vfs_mknod(struct inode *, struct dentry *, struct vfsmount *, int, dev_t);
 extern int vfs_symlink(struct inode *, struct dentry *, struct vfsmount *, const char *, int);
--- a/ipc/mqueue.c
+++ b/ipc/mqueue.c
@@ -601,11 +601,11 @@ static int mq_attr_ok(struct mq_attr *at
 /*
  * Invoked when creating a new queue via sys_mq_open
  */
-static struct file *do_create(struct dentry *dir, struct dentry *dentry,
-			int oflag, mode_t mode, struct mq_attr __user *u_attr)
+static struct file *do_create(struct dentry *dentry, int oflag, mode_t mode,
+			      struct mq_attr __user *u_attr)
 {
 	struct nameidata2 nd = {
-		.dentry = dir,
+		.dentry = mqueue_mnt->mnt_root,
 		/* Not a mounted filesystem, so set .mnt to NULL. */
 	};
 	struct mq_attr attr;
@@ -623,7 +623,7 @@ static struct file *do_create(struct den
 	}
 
 	mode &= ~current->fs->umask;
-	ret = vfs_create(dir->d_inode, dentry, mode, &nd);
+	ret = vfs_create(&nd, dentry, mode);
 	dentry->d_fsdata = NULL;
 	if (ret)
 		goto out;
@@ -691,8 +691,7 @@ asmlinkage long sys_mq_open(const char _
 				goto out;
 			filp = do_open(dentry, oflag);
 		} else {
-			filp = do_create(mqueue_mnt->mnt_root, dentry,
-						oflag, mode, u_attr);
+			filp = do_create(dentry, oflag, mode, u_attr);
 		}
 	} else {
 		error = -ENOENT;
