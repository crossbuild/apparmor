---
 fs/ecryptfs/inode.c   |   18 ++++++++----------
 fs/namei.c            |   10 +++++-----
 fs/nfsd/nfs4recover.c |    3 +--
 fs/nfsd/vfs.c         |    2 +-
 include/linux/fs.h    |    2 +-
 5 files changed, 16 insertions(+), 19 deletions(-)

--- a/fs/ecryptfs/inode.c
+++ b/fs/ecryptfs/inode.c
@@ -515,26 +515,24 @@ out_lock:
 
 static int ecryptfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 {
+	struct nameidata2 nd = {};
 	int rc;
 	struct dentry *lower_dentry;
-	struct vfsmount *lower_mnt;
-	struct dentry *lower_dir_dentry;
 
 	lower_dentry = ecryptfs_dentry_to_lower(dentry);
-	lower_mnt = ecryptfs_dentry_to_lower_mnt(dentry);
-	lower_dir_dentry = lock_parent(lower_dentry);
-	rc = vfs_mkdir(lower_dir_dentry->d_inode, lower_dentry, lower_mnt,
-		       mode);
+	nd.mnt = ecryptfs_dentry_to_lower_mnt(dentry);
+	nd.dentry = lock_parent(lower_dentry);
+	rc = vfs_mkdir(&nd, lower_dentry, mode);
 	if (rc || !lower_dentry->d_inode)
 		goto out;
 	rc = ecryptfs_interpose(lower_dentry, dentry, dir->i_sb, 0);
 	if (rc)
 		goto out;
-	fsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);
-	fsstack_copy_inode_size(dir, lower_dir_dentry->d_inode);
-	dir->i_nlink = lower_dir_dentry->d_inode->i_nlink;
+	fsstack_copy_attr_times(dir, nd.dentry->d_inode);
+	fsstack_copy_inode_size(dir, nd.dentry->d_inode);
+	dir->i_nlink = nd.dentry->d_inode->i_nlink;
 out:
-	unlock_dir(lower_dir_dentry);
+	unlock_dir(nd.dentry);
 	if (!dentry->d_inode)
 		d_drop(dentry);
 	return rc;
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -1922,10 +1922,10 @@ asmlinkage long sys_mknod(const char __u
 	return sys_mknodat(AT_FDCWD, filename, mode, dev);
 }
 
-int vfs_mkdir(struct inode *dir, struct dentry *dentry, struct vfsmount *mnt,
-	      int mode)
+int vfs_mkdir(struct nameidata2 *nd, struct dentry *dentry, int mode)
 {
-	int error = may_create(dir, dentry, NULL);
+	struct inode *dir = nd->dentry->d_inode;
+	int error = may_create(dir, dentry, nd);
 
 	if (error)
 		return error;
@@ -1934,7 +1934,7 @@ int vfs_mkdir(struct inode *dir, struct 
 		return -EPERM;
 
 	mode &= (S_IRWXUGO|S_ISVTX);
-	error = security_inode_mkdir(dir, dentry, mnt, mode);
+	error = security_inode_mkdir(dir, dentry, nd->mnt, mode);
 	if (error)
 		return error;
 
@@ -1967,7 +1967,7 @@ asmlinkage long sys_mkdirat(int dfd, con
 
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
-	error = vfs_mkdir(nd.dentry->d_inode, dentry, nd.mnt, mode);
+	error = vfs_mkdir(ND2(&nd), dentry, mode);
 	dput(dentry);
 out_unlock:
 	mutex_unlock(&nd.dentry->d_inode->i_mutex);
--- a/fs/nfsd/nfs4recover.c
+++ b/fs/nfsd/nfs4recover.c
@@ -156,8 +156,7 @@ nfsd4_create_clid_dir(struct nfs4_client
 		dprintk("NFSD: nfsd4_create_clid_dir: DIRECTORY EXISTS\n");
 		goto out_put;
 	}
-	status = vfs_mkdir(rec_dir.dentry->d_inode, dentry, rec_dir.mnt,
-			   S_IRWXU);
+	status = vfs_mkdir(ND2(&rec_dir), dentry, S_IRWXU);
 out_put:
 	dput(dentry);
 out_unlock:
--- a/fs/nfsd/vfs.c
+++ b/fs/nfsd/vfs.c
@@ -1197,7 +1197,7 @@ nfsd_create(struct svc_rqst *rqstp, stru
 		host_err = vfs_create(&nd, dchild, iap->ia_mode);
 		break;
 	case S_IFDIR:
-		host_err = vfs_mkdir(dirp, dchild, exp->ex_mnt, iap->ia_mode);
+		host_err = vfs_mkdir(&nd, dchild, iap->ia_mode);
 		break;
 	case S_IFCHR:
 	case S_IFBLK:
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -984,7 +984,7 @@ extern void unlock_super(struct super_bl
  */
 extern int vfs_permission(struct nameidata2 *, int);
 extern int vfs_create(struct nameidata2 *, struct dentry *, int);
-extern int vfs_mkdir(struct inode *, struct dentry *, struct vfsmount *, int);
+extern int vfs_mkdir(struct nameidata2 *, struct dentry *, int);
 extern int vfs_mknod(struct nameidata2 *, struct dentry *, int, dev_t);
 extern int vfs_symlink(struct inode *, struct dentry *, struct vfsmount *, const char *, int);
 extern int vfs_link(struct dentry *, struct vfsmount *, struct inode *, struct dentry *, struct vfsmount *);
