From: Andreas Gruenbacher <agruen@suse.de>
Subject: Pass nameidata2 to vfs_mknod()

Instead of passing independent dentry and vfsmount parameters, use a
nameidata2.

Signed-off-by: Andreas Gruenbacher <agruen@suse.de>

---
 fs/ecryptfs/inode.c |   16 +++++++---------
 fs/namei.c          |   15 +++++++--------
 fs/nfsd/vfs.c       |    3 +--
 include/linux/fs.h  |    2 +-
 net/unix/af_unix.c  |    2 +-
 5 files changed, 17 insertions(+), 21 deletions(-)

--- a/fs/ecryptfs/inode.c
+++ b/fs/ecryptfs/inode.c
@@ -568,25 +568,23 @@ static int ecryptfs_rmdir(struct inode *
 static int
 ecryptfs_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev)
 {
+	struct nameidata2 nd = {};
 	int rc;
 	struct dentry *lower_dentry;
-	struct vfsmount *lower_mnt;
-	struct dentry *lower_dir_dentry;
 
 	lower_dentry = ecryptfs_dentry_to_lower(dentry);
-	lower_mnt = ecryptfs_dentry_to_lower_mnt(dentry);
-	lower_dir_dentry = lock_parent(lower_dentry);
-	rc = vfs_mknod(lower_dir_dentry->d_inode, lower_dentry, lower_mnt, mode,
-		       dev);
+	nd.mnt = ecryptfs_dentry_to_lower_mnt(dentry);
+	nd.dentry = lock_parent(lower_dentry);
+	rc = vfs_mknod(&nd, lower_dentry, mode, dev);
 	if (rc || !lower_dentry->d_inode)
 		goto out;
 	rc = ecryptfs_interpose(lower_dentry, dentry, dir->i_sb, 0);
 	if (rc)
 		goto out;
-	fsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);
-	fsstack_copy_inode_size(dir, lower_dir_dentry->d_inode);
+	fsstack_copy_attr_times(dir, nd.dentry->d_inode);
+	fsstack_copy_inode_size(dir, nd.dentry->d_inode);
 out:
-	unlock_dir(lower_dir_dentry);
+	unlock_dir(nd.dentry);
 	if (!dentry->d_inode)
 		d_drop(dentry);
 	return rc;
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -1841,10 +1841,10 @@ fail:
 }
 EXPORT_SYMBOL_GPL(lookup_create);
 
-int vfs_mknod(struct inode *dir, struct dentry *dentry, struct vfsmount *mnt,
-	      int mode, dev_t dev)
+int vfs_mknod(struct nameidata2 *nd, struct dentry *dentry, int mode, dev_t dev)
 {
-	int error = may_create(dir, dentry, NULL);
+	struct inode *dir = nd->dentry->d_inode;
+	int error = may_create(dir, dentry, nd);
 
 	if (error)
 		return error;
@@ -1855,7 +1855,7 @@ int vfs_mknod(struct inode *dir, struct 
 	if (!dir->i_op || !dir->i_op->mknod)
 		return -EPERM;
 
-	error = security_inode_mknod(dir, dentry, mnt, mode, dev);
+	error = security_inode_mknod(dir, dentry, nd->mnt, mode, dev);
 	if (error)
 		return error;
 
@@ -1894,12 +1894,11 @@ asmlinkage long sys_mknodat(int dfd, con
 			error = vfs_create(ND2(&nd), dentry, mode);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			error = vfs_mknod(nd.dentry->d_inode, dentry, nd.mnt,
-					  mode, new_decode_dev(dev));
+			error = vfs_mknod(ND2(&nd), dentry, mode,
+					  new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			error = vfs_mknod(nd.dentry->d_inode, dentry, nd.mnt,
-					  mode, 0);
+			error = vfs_mknod(ND2(&nd), dentry, mode, 0);
 			break;
 		case S_IFDIR:
 			error = -EPERM;
--- a/fs/nfsd/vfs.c
+++ b/fs/nfsd/vfs.c
@@ -1203,8 +1203,7 @@ nfsd_create(struct svc_rqst *rqstp, stru
 	case S_IFBLK:
 	case S_IFIFO:
 	case S_IFSOCK:
-		host_err = vfs_mknod(dirp, dchild, exp->ex_mnt, iap->ia_mode,
-				     rdev);
+		host_err = vfs_mknod(&nd, dchild, iap->ia_mode, rdev);
 		break;
 	default:
 	        printk("nfsd: bad file type %o in nfsd_create\n", type);
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -985,7 +985,7 @@ extern void unlock_super(struct super_bl
 extern int vfs_permission(struct nameidata2 *, int);
 extern int vfs_create(struct nameidata2 *, struct dentry *, int);
 extern int vfs_mkdir(struct inode *, struct dentry *, struct vfsmount *, int);
-extern int vfs_mknod(struct inode *, struct dentry *, struct vfsmount *, int, dev_t);
+extern int vfs_mknod(struct nameidata2 *, struct dentry *, int, dev_t);
 extern int vfs_symlink(struct inode *, struct dentry *, struct vfsmount *, const char *, int);
 extern int vfs_link(struct dentry *, struct vfsmount *, struct inode *, struct dentry *, struct vfsmount *);
 extern int vfs_rmdir(struct inode *, struct dentry *, struct vfsmount *);
--- a/net/unix/af_unix.c
+++ b/net/unix/af_unix.c
@@ -808,7 +808,7 @@ static int unix_bind(struct socket *sock
 		 */
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
-		err = vfs_mknod(nd.dentry->d_inode, dentry, nd.mnt, mode, 0);
+		err = vfs_mknod(ND2(&nd), dentry, mode, 0);
 		if (err)
 			goto out_mknod_dput;
 		mutex_unlock(&nd.dentry->d_inode->i_mutex);
