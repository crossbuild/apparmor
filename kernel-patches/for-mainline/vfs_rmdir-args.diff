---
 fs/ecryptfs/inode.c   |   15 +++++++--------
 fs/namei.c            |    7 ++++---
 fs/nfsd/nfs4recover.c |    6 +++++-
 fs/nfsd/vfs.c         |   14 ++++++++------
 fs/reiserfs/xattr.c   |   11 +++++++----
 include/linux/fs.h    |    2 +-
 6 files changed, 32 insertions(+), 23 deletions(-)

--- a/fs/ecryptfs/inode.c
+++ b/fs/ecryptfs/inode.c
@@ -534,23 +534,22 @@ out:
 
 static int ecryptfs_rmdir(struct inode *dir, struct dentry *dentry)
 {
+	struct nameidata2 nd = {};
 	struct dentry *lower_dentry;
-	struct vfsmount *lower_mnt;
-	struct dentry *lower_dir_dentry;
 	int rc;
 
 	lower_dentry = ecryptfs_dentry_to_lower(dentry);
-	lower_mnt = ecryptfs_dentry_to_lower_mnt(dentry);
 	dget(dentry);
-	lower_dir_dentry = lock_parent(lower_dentry);
+	nd.dentry = lock_parent(lower_dentry);
+	nd.mnt = ecryptfs_dentry_to_lower_mnt(dentry);
 	dget(lower_dentry);
-	rc = vfs_rmdir(lower_dir_dentry->d_inode, lower_dentry, lower_mnt);
+	rc = vfs_rmdir(&nd, lower_dentry);
 	dput(lower_dentry);
 	if (!rc)
 		d_delete(lower_dentry);
-	fsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);
-	dir->i_nlink = lower_dir_dentry->d_inode->i_nlink;
-	unlock_dir(lower_dir_dentry);
+	fsstack_copy_attr_times(dir, nd.dentry->d_inode);
+	dir->i_nlink = nd.dentry->d_inode->i_nlink;
+	unlock_dir(nd.dentry);
 	if (!rc)
 		d_drop(dentry);
 	dput(dentry);
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -2005,8 +2005,9 @@ void dentry_unhash(struct dentry *dentry
 	spin_unlock(&dcache_lock);
 }
 
-int vfs_rmdir(struct inode *dir, struct dentry *dentry,struct vfsmount *mnt)
+int vfs_rmdir(struct nameidata2 *nd, struct dentry *dentry)
 {
+	struct inode *dir = nd->dentry->d_inode;
 	int error = may_delete(dir, dentry, 1);
 
 	if (error)
@@ -2015,7 +2016,7 @@ int vfs_rmdir(struct inode *dir, struct 
 	if (!dir->i_op || !dir->i_op->rmdir)
 		return -EPERM;
 
-	error = security_inode_rmdir(dir, dentry, mnt);
+	error = security_inode_rmdir(dir, dentry, nd->mnt);
 	if (error)
 		return error;
 
@@ -2070,7 +2071,7 @@ static long do_rmdir(int dfd, const char
 	error = PTR_ERR(dentry);
 	if (IS_ERR(dentry))
 		goto exit2;
-	error = vfs_rmdir(nd.dentry->d_inode, dentry, nd.mnt);
+	error = vfs_rmdir(ND2(&nd), dentry);
 	dput(dentry);
 exit2:
 	mutex_unlock(&nd.dentry->d_inode->i_mutex);
--- a/fs/nfsd/nfs4recover.c
+++ b/fs/nfsd/nfs4recover.c
@@ -268,6 +268,10 @@ nfsd4_remove_clid_file(struct dentry *di
 static int
 nfsd4_clear_clid_dir(struct dentry *dir, struct dentry *dentry)
 {
+	struct nameidata2 nd = {
+		.dentry = dir,
+		.mnt = rec_dir.mnt,
+	};
 	int status;
 
 	/* For now this directory should already be empty, but we empty it of
@@ -275,7 +279,7 @@ nfsd4_clear_clid_dir(struct dentry *dir,
 	 * a kernel from the future.... */
 	nfsd4_list_rec_dir(dentry, nfsd4_remove_clid_file);
 	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);
-	status = vfs_rmdir(dir->d_inode, dentry, rec_dir.mnt);
+	status = vfs_rmdir(&nd, dentry);
 	mutex_unlock(&dir->d_inode->i_mutex);
 	return status;
 }
--- a/fs/nfsd/vfs.c
+++ b/fs/nfsd/vfs.c
@@ -1683,7 +1683,8 @@ __be32
 nfsd_unlink(struct svc_rqst *rqstp, struct svc_fh *fhp, int type,
 				char *fname, int flen)
 {
-	struct dentry	*dentry, *rdentry;
+	struct nameidata2 nd = {};
+	struct dentry	*rdentry;
 	struct svc_export *exp;
 	struct inode	*dirp;
 	__be32		err;
@@ -1697,11 +1698,12 @@ nfsd_unlink(struct svc_rqst *rqstp, stru
 		goto out;
 
 	fh_lock_nested(fhp, I_MUTEX_PARENT);
-	dentry = fhp->fh_dentry;
-	dirp = dentry->d_inode;
+	nd.dentry = fhp->fh_dentry;
 	exp = fhp->fh_export;
+	nd.mnt = exp->ex_mnt;
+	dirp = nd.dentry->d_inode;
 
-	rdentry = lookup_one_len(fname, dentry, flen);
+	rdentry = lookup_one_len(fname, nd.dentry, flen);
 	host_err = PTR_ERR(rdentry);
 	if (IS_ERR(rdentry))
 		goto out_nfserr;
@@ -1724,7 +1726,7 @@ nfsd_unlink(struct svc_rqst *rqstp, stru
 #endif
 		host_err = vfs_unlink(dirp, rdentry, exp->ex_mnt);
 	} else { /* It's RMDIR */
-		host_err = vfs_rmdir(dirp, rdentry, exp->ex_mnt);
+		host_err = vfs_rmdir(&nd, rdentry);
 	}
 
 	dput(rdentry);
@@ -1732,7 +1734,7 @@ nfsd_unlink(struct svc_rqst *rqstp, stru
 	if (host_err)
 		goto out_nfserr;
 	if (EX_ISSYNC(exp))
-		host_err = nfsd_sync_dir(dentry);
+		host_err = nfsd_sync_dir(nd.dentry);
 
 out_nfserr:
 	err = nfserrno(host_err);
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -785,7 +785,7 @@ reiserfs_delete_xattrs_filler(void *buf,
 int reiserfs_delete_xattrs(struct inode *inode)
 {
 	struct file *fp;
-	struct dentry *dir, *root;
+	struct dentry *dir;
 	int err = 0;
 
 	/* Skip out, an xattr has no xattrs associated with it */
@@ -821,11 +821,14 @@ int reiserfs_delete_xattrs(struct inode 
 
 	/* Leftovers besides . and .. -- that's not good. */
 	if (dir->d_inode->i_nlink <= 2) {
-		root = get_xa_root(inode->i_sb);
+		struct nameidata2 nd = {
+			.dentry = get_xa_root(inode->i_sb),
+			/* .mnt = NULL, */
+		};
 		reiserfs_write_lock_xattrs(inode->i_sb);
-		err = vfs_rmdir(root->d_inode, dir, NULL);
+		err = vfs_rmdir(&nd, dir);
 		reiserfs_write_unlock_xattrs(inode->i_sb);
-		dput(root);
+		dput(nd.dentry);
 	} else {
 		reiserfs_warning(inode->i_sb,
 				 "Couldn't remove all entries in directory");
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -988,7 +988,7 @@ extern int vfs_mkdir(struct nameidata2 *
 extern int vfs_mknod(struct nameidata2 *, struct dentry *, int, dev_t);
 extern int vfs_symlink(struct nameidata2 *, struct dentry *, const char *, int);
 extern int vfs_link(struct nameidata2 *, struct dentry *, struct nameidata2 *);
-extern int vfs_rmdir(struct inode *, struct dentry *, struct vfsmount *);
+extern int vfs_rmdir(struct nameidata2 *, struct dentry *);
 extern int vfs_unlink(struct inode *, struct dentry *, struct vfsmount *);
 extern int vfs_rename(struct nameidata2 *, struct dentry *, struct nameidata2 *, struct dentry *);
 
