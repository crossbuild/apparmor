From: Andreas Gruenbacher <agruen@suse.de>
Subject: Don't use a NULL nameidata in xattr_permission()

Create nameidata2 struct xattr_permission so that it does not pass NULL
to permission.

Signed-off-by: Andreas Gruenbacher <agruen@suse.de>

---
 fs/xattr.c |   18 +++++++++++++-----
 1 file changed, 13 insertions(+), 5 deletions(-)

--- a/fs/xattr.c
+++ b/fs/xattr.c
@@ -25,8 +25,16 @@
  * because different namespaces have very different rules.
  */
 static int
-xattr_permission(struct inode *inode, const char *name, int mask)
+xattr_permission(struct dentry *dentry, struct vfsmount *mnt, const char *name,
+		 int mask)
 {
+	struct inode *inode = dentry->d_inode;
+	struct nameidata2 nd;
+
+	nd.dentry = dentry;
+	nd.mnt = mnt;
+	nd.flags = 0;
+
 	/*
 	 * We can never set or remove an extended attribute on a read-only
 	 * filesystem  or on an immutable / append-only inode.
@@ -65,7 +73,7 @@ xattr_permission(struct inode *inode, co
 			return -EPERM;
 	}
 
-	return permission(inode, mask, NULL);
+	return permission(inode, mask, &nd);
 }
 
 int
@@ -75,7 +83,7 @@ vfs_setxattr(struct dentry *dentry, stru
 	struct inode *inode = dentry->d_inode;
 	int error;
 
-	error = xattr_permission(inode, name, MAY_WRITE);
+	error = xattr_permission(dentry, mnt, name, MAY_WRITE);
 	if (error)
 		return error;
 
@@ -112,7 +120,7 @@ vfs_getxattr(struct dentry *dentry, stru
 	struct inode *inode = dentry->d_inode;
 	int error;
 
-	error = xattr_permission(inode, name, MAY_READ);
+	error = xattr_permission(dentry, mnt, name, MAY_READ);
 	if (error)
 		return error;
 
@@ -174,7 +182,7 @@ vfs_removexattr(struct dentry *dentry, s
 	if (!inode->i_op->removexattr)
 		return -EOPNOTSUPP;
 
-	error = xattr_permission(inode, name, MAY_WRITE);
+	error = xattr_permission(dentry, mnt, name, MAY_WRITE);
 	if (error)
 		return error;
 
