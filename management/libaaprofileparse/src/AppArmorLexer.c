/** \file
 *  This C source file was generated by $ANTLR version 3.0.1
 *
 *     -  From the grammar source file : AppArmor.g
 *     -                            On : 2007-08-19 11:55:24
 *     -                 for the lexer : AppArmorLexerLexer *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 * View this file with tabs set to 8 (:set ts=8 in gvim) and indent at 4 (:set sw=4 in gvim)
 *
*/

/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

#include "libaaprofileparse.h"
#include "antlr/antlr3collections.h"

void init_stream_vector(void);
void close_streams (void);

/* End of Header action.
 * =============================================================================
 */
/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "AppArmorLexer.h"
/* ----------------------------------------- */


/** String literals used by AppArmorLexer that we must do things like MATCHS() with.
 *  C will normally just lay down 8 bit characters, and you can use L"xxx" to
 *  get wchar_t, but wchar_t is 16 bits on Windows, which is not UTF32 and so
 *  we perform this little trick of defining the literals as arrays of UINT32
 *  and passing in the address of these.
 */
static ANTLR3_UCHAR	lit_1[]  = { 0x74, 0x72, 0x75, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_2[]  = { 0x66, 0x61, 0x6C, 0x73, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_3[]  = { 0x61, 0x75, 0x64, 0x69, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_4[]  = { 0x76, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_5[]  = { 0x65, 0x6E, 0x63, 0x6F, 0x64, 0x69, 0x6E, 0x67,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_6[]  = { 0x64, 0x69, 0x73, 0x61, 0x62, 0x6C, 0x65, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_7[]  = { 0x63, 0x6F, 0x6D, 0x70, 0x6C, 0x61, 0x69, 0x6E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_8[]  = { 0x70, 0x72, 0x6F, 0x66, 0x69, 0x6C, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_9[]  = { 0x66, 0x6C, 0x61, 0x67, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_10[]  = { 0x66, 0x6F, 0x6C, 0x64, 0x5F, 0x68, 0x61, 0x74, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_11[]  = { 0x63, 0x68, 0x61, 0x6E, 0x67, 0x65, 0x5F, 0x70, 0x72, 0x6F, 0x66, 0x69, 0x6C, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_12[]  = { 0x63, 0x61, 0x70, 0x61, 0x62, 0x69, 0x6C, 0x69, 0x74, 0x79,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_13[]  = { 0x69, 0x66,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_14[]  = { 0x65, 0x6C, 0x73, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_15[]  = { 0x65, 0x72, 0x72, 0x6F, 0x72,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_16[]  = { 0x75, 0x6E, 0x64, 0x65, 0x66,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_17[]  = { 0x77, 0x61, 0x72, 0x6E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_18[]  = { 0x6E, 0x6F, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_19[]  = { 0x65, 0x78, 0x69, 0x73, 0x74, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_20[]  = { 0x64, 0x65, 0x66, 0x69, 0x6E, 0x65, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_21[]  = { 0x61, 0x6E, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_22[]  = { 0x6F, 0x72,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_23[]  = { 0x6E, 0x65, 0x74, 0x77, 0x6F, 0x72, 0x6B,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_24[]  = { 0x63, 0x6F, 0x6E, 0x6E, 0x74, 0x72, 0x61, 0x63, 0x6B,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_25[]  = { 0x69, 0x6E, 0x65, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_26[]  = { 0x61, 0x78, 0x32, 0x35,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_27[]  = { 0x6E, 0x65, 0x74, 0x72, 0x6F, 0x6D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_28[]  = { 0x62, 0x72, 0x69, 0x64, 0x67, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_29[]  = { 0x61, 0x74, 0x6D, 0x70, 0x76, 0x63,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_30[]  = { 0x78, 0x32, 0x35,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_31[]  = { 0x69, 0x6E, 0x65, 0x74, 0x36,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_32[]  = { 0x72, 0x6F, 0x73, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_33[]  = { 0x6E, 0x65, 0x74, 0x62, 0x65, 0x75, 0x69,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_34[]  = { 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_35[]  = { 0x6B, 0x65, 0x79,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_36[]  = { 0x70, 0x61, 0x63, 0x6B, 0x65, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_37[]  = { 0x61, 0x73, 0x68,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_38[]  = { 0x65, 0x63, 0x6F, 0x6E, 0x65, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_39[]  = { 0x61, 0x74, 0x6D, 0x73, 0x76, 0x63,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_40[]  = { 0x73, 0x6E, 0x61,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_41[]  = { 0x69, 0x72, 0x64, 0x61,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_42[]  = { 0x70, 0x70, 0x70, 0x6F, 0x78,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_43[]  = { 0x77, 0x61, 0x6E, 0x70, 0x69, 0x70, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_44[]  = { 0x62, 0x6C, 0x75, 0x65, 0x74, 0x6F, 0x6F, 0x74, 0x68,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_45[]  = { 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_46[]  = { 0x64, 0x67, 0x72, 0x61, 0x6D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_47[]  = { 0x73, 0x65, 0x71, 0x70, 0x61, 0x63, 0x6B, 0x65, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_48[]  = { 0x72, 0x64, 0x6D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_49[]  = { 0x72, 0x61, 0x77,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_50[]  = { 0x74, 0x63, 0x70,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_51[]  = { 0x75, 0x64, 0x70,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_52[]  = { 0x69, 0x70, 0x78,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_53[]  = { 0x61, 0x70, 0x70, 0x6C, 0x65, 0x74, 0x61, 0x6C, 0x6B,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_54[]  = { 0x73, 0x63, 0x74, 0x70,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_55[]  = { 0x63, 0x6F, 0x6E, 0x6E, 0x65, 0x63, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_56[]  = { 0x61, 0x63, 0x63, 0x65, 0x70, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_57[]  = { 0x63, 0x6F, 0x6E, 0x6E, 0x65, 0x63, 0x74, 0x65, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_58[]  = { 0x73, 0x65, 0x6E, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_59[]  = { 0x72, 0x65, 0x63, 0x76,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_60[]  = { 0x74, 0x6F,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_61[]  = { 0x66, 0x72, 0x6F, 0x6D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_62[]  = { 0x65, 0x6E, 0x64, 0x70, 0x6F, 0x69, 0x6E, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_63[]  = { 0x76, 0x69, 0x61,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_64[]  = { 0x6C, 0x69, 0x6D, 0x69, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_65[]  = { 0x0D, 0x0A,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_66[]  = { 0x69, 0x6E, 0x63, 0x6C, 0x75, 0x64, 0x65, 0x20,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_67[]  = { 0x69, 0x6E, 0x63, 0x6C, 0x75, 0x64, 0x65,  ANTLR3_STRING_TERMINATOR};


/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pAppArmorLexer_##scope##_SCOPE
#define SCOPE_STACK(scope)  pAppArmorLexer_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pAppArmorLexer_##scope##Top
#define	SCOPE_SIZE(scope)			(ctx->SCOPE_STACK(scope)->size(ctx->SCOPE_STACK(scope)))
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always refering to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritence.
 */
 
/* Macros for accessing things in a lexer
 */
#undef	    LEXER
#undef	    RECOGNIZER		    
#undef	    RULEMEMO		    
#undef	    GETCHARINDEX
#undef	    GETLINE
#undef	    GETCHARPOSITIONINLINE
#undef	    EMIT
#undef	    EMITNEW
#undef	    MATCHC
#undef	    MATCHS
#undef	    MATCHRANGE
#undef	    LTOKEN
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    INPUT
#undef	    STRSTREAM
#undef	    LA
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    LRECOVER
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    BACKTRACKING
#undef		MATCHANY
#undef		MEMOIZE
#undef		HAVEPARSEDRULE
#undef		GETTEXT
#undef		INDEX
#undef		SEEK
#undef		PUSHSTREAM
#undef		POPSTREAM
#undef		SETTEXT
#undef		SETTEXT8

#define	    LEXER					ctx->pLexer
#define	    RECOGNIZER			    LEXER->rec
#define	    RULEMEMO				RECOGNIZER->ruleMemo
#define	    GETCHARINDEX()			LEXER->getCharIndex(LEXER)
#define	    GETLINE()				LEXER->getLine(LEXER)
#define	    GETTEXT()				LEXER->getText(LEXER)
#define	    GETCHARPOSITIONINLINE() LEXER->getCharPositionInLine(LEXER)
#define	    EMIT()					LEXER->type = _type; LEXER->emit(LEXER)
#define	    EMITNEW(t)				LEXER->emitNew(LEXER, t)
#define	    MATCHC(c)				LEXER->matchc(LEXER, c)
#define	    MATCHS(s)				LEXER->matchs(LEXER, s)
#define	    MATCHRANGE(c1,c2)	    LEXER->matchRange(LEXER, c1, c2)
#define	    MATCHANY()				LEXER->matchAny(LEXER)
#define	    LTOKEN  				LEXER->token
#define	    HASFAILED()				(RECOGNIZER->failed == ANTLR3_TRUE)
#define	    BACKTRACKING			RECOGNIZER->backtracking
#define	    FAILEDFLAG				RECOGNIZER->failed
#define	    INPUT					LEXER->input
#define	    STRSTREAM				INPUT
#define		INDEX()					INPUT->istream->index(INPUT->istream)
#define		SEEK(n)					INPUT->istream->seek(INPUT->istream, n)
#define	    EOF_TOKEN				&(LEXER->tokSource->eofToken)
#define	    HASEXCEPTION()			(RECOGNIZER->error == ANTLR3_TRUE)
#define	    EXCEPTION				RECOGNIZER->exception
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    LRECOVER()				LEXER->recover(LEXER)
#define	    MARK()					INPUT->istream->mark(INPUT->istream)
#define	    REWIND(m)				INPUT->istream->rewind(INPUT->istream, m)
#define	    REWINDLAST()			INPUT->istream->rewindLast(INPUT->istream)
#define		MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define		HAVEPARSEDRULE(r)		RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define		PUSHSTREAM(str)			LEXER->pushCharStream(LEXER, str)
#define		POPSTREAM()				LEXER->popCharStream(LEXER)
#define		SETTEXT(str)			LEXER->text = str
#define		USER1					LEXER->user1
#define		USER2					LEXER->user2
#define		USER3					LEXER->user3
#define		CUSTOM					LEXER->custom

/* If we have been told we can rely on the standard 8 bit or 16 bit input
 * stream, then we can define our macros to use the direct pointers
 * in the input object, which is much faster than indirect calls. This
 * is really only significant to lexers wiht a lot of fragment rules (which
 * do not place LA(1) in a temporary at the moment) and even then
 * only if there is a lot of input (order of say 1M or so).
 */
#if	defined(ANTLR3_INLINE_INPUT_ASCII) || defined(ANTLR3_INLINE_INPUT_UTF16)

# ifdef	ANTLR3_INLINE_INPUT_ASCII

/* 8 bit "ASCII" (actually any 8 bit character set) */

#  define	    NEXTCHAR			((pANTLR3_UINT8)(INPUT->nextChar))
#  define	    DATAP				((pANTLR3_UINT8)(INPUT->data))

# else

#  define	    NEXTCHAR			((pANTLR3_UINT16)(INPUT->nextChar)) 
#  define	    DATAP				((pANTLR3_UINT16)(INPUT->data))

# endif

# define	    LA(n) ((NEXTCHAR + n) > (DATAP + INPUT->sizeBuf) ? ANTLR3_CHARSTREAM_EOF : (ANTLR3_UCHAR)(*(NEXTCHAR + n - 1)))
# define	    CONSUME()											\
{																	\
    if	(NEXTCHAR < (DATAP + INPUT->sizeBuf))					\
    {																\
		INPUT->charPositionInLine++;								\
		if  ((ANTLR3_UCHAR)(*NEXTCHAR) == INPUT->newlineChar)		\
		{															\
			INPUT->line++;										\
			INPUT->charPositionInLine	= 0;						\
			INPUT->currentLine		= (void *)(NEXTCHAR + 1);	\
		}															\
		INPUT->nextChar = (void *)(NEXTCHAR + 1);					\
    }																\
}

#else

// Pick up the input character by calling the input stream implementation.
//
#define	    CONSUME()				INPUT->istream->consume(INPUT->istream)
#define	    LA(n)					INPUT->istream->_LA(INPUT->istream, n)

#endif
#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/* Forward declare the locally static matching functions we have generated and any predicate functions.
 */
static ANTLR3_INLINE void	mT32    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT33    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT34    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT35    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT36    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT37    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT38    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT39    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT40    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT41    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT42    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT43    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT44    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT45    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT46    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT47    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT48    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT49    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT50    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT51    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT52    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT53    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT54    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT55    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT56    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT57    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT58    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT59    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT60    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT61    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT62    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT63    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT64    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT65    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT66    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT67    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT68    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT69    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT70    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT71    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT72    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT73    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT74    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT75    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT76    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT77    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT78    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT79    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT80    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT81    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT82    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT83    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT84    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT85    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT86    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT87    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT88    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT89    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT90    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT91    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT92    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT93    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT94    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT95    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT96    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mT97    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mNEWLINE    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mLESS_THAN    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mGREATER_THAN    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mLEFT_BRACE    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mRIGHT_BRACE    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mAT    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mDOLLAR    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mLEFT_PAREN    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mRIGHT_PAREN    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mPLUS    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mEQUALS    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mCOMMENT_OR_INCLUDE    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mINCLUDE    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mSOL_COMMENT    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mEOL_COMMENT    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mCOMMENT    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mANYTHING_NOT_QUOTED    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mQUOTED_STRING    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mPATH    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mUNQUOTED_PATH    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mLIST_VAR_START    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mBOOL_VAR_START    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mRULE    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mIDENT_START    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mIDENT_CONTINUE    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mREAL_IDENT    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mIDENT    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mWS    (pAppArmorLexer ctx);
static ANTLR3_INLINE void	mTokens    (pAppArmorLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred1    (pAppArmorLexer ctx);
static void	AppArmorLexerFree(pAppArmorLexer ctx);

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */



	/* startOfLine, like the name suggests, tracks
	 * whether or not a non '#' character has been used on a line,
	 * in order to ultimately figure out if a comment is a "start
	 * of line" comment or an "end of line" comment.
	 * 
	 * We can't use the character position for this because a position
	 *  of '10' spaces could count as not being the start of the line.
	 */
	int startOfLine = 0;	
	
	/* inVariable and equalSign are used by the NEWLINE lexer rule to
	 * figure out if a NEWLINE should be returned to the parser. 
	 * inVariable is set by the lexer when a variable token is found,
	 * and equalSign is set when an EQUALS token is found.  If both 
	 * integers equal 1, it is assumed that we're dealing with a variable
	 * assignment.  This approach is used rather than adding another
	 * syntactic predicate to the lexer, as syntactic predicates should
	 * be avoided as often as possible.
	 *
	 * For a full explanation of why the parser needs the NEWLINE token
	 * when a variable assignment occurs, please see the last comment
	 * in the 'variableAssign' parser rule.
	 */
	int inVariable = 0;
	int equalSign = 0;
	
	/* inInclude is used by the NEWLINE lexer rule to figure out when to
	 * kick off a new lexer stream reading from an d file.
	 * There's probably a better way to do this, but in the meantime,
	 * a full description is commented in the parser include rule.
	 */
	 int inInclude = 0;
	 char *lexerIncludeFile = NULL;

	 /* When we read in an include file, we push a new input stream onto
	  * the lexer's input stack.   It's helpfully designed so that when the
	  * stream runs out of data, it bounces back to the previous stream.
	  * However, the include stream isn't actually closed.  In order to
	  * close them, we'll track a vector of streams that we open as we 
	  * encounter new files to be included, and then close them 
	  * right before startParse returns.  It's important to never close
	  * a stream before you're certain that parsing is complete, since 
	  * tokens don't actually contain the text, they just point into
	  * the input stream.
	  */
	 pANTLR3_VECTOR streamVector;
	 void init_stream_vector(void)
	 {
	 	streamVector = antlr3VectorNew(0);
	 }
	 void close_streams (void)
	 {
	 	ANTLR3_UINT64 vsize, count;
		pANTLR3_INPUT_STREAM tmp;
		vsize = streamVector->size(streamVector);
		/* The vector index is 1 based.  Decrement it
		 * so ANTLR doesn't shuffle entries around.
		 */
		for (count = vsize; count != 0; count--)
		{
			tmp = streamVector->get(streamVector, count);
			tmp->close(tmp);
			streamVector->remove(streamVector, count);
		}
		streamVector->free(streamVector);
	 }
	 



static void
AppArmorLexerFree  (pAppArmorLexer ctx)
{
    LEXER->free(LEXER);
    
    ANTLR3_FREE(ctx);
}

/** \brief Name of the gramar file that generated this code
 */
static unsigned char fileName[] = "AppArmor.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static unsigned char * getGrammarFileName()
{
	return fileName;
}

/** \brief Create a new lexer called AppArmorLexer
 *
 * \param[in] instream Pointer to an initialized input stream
 *
 * \return 
 *     - Success pAppArmorLexer initialized for the lex start
 *     - Fail (pAppArmorLexer)(ANTLR3_ERR_NOMEM)
 */
ANTLR3_API pAppArmorLexer AppArmorLexerNew         (pANTLR3_INPUT_STREAM     instream)
{
    pAppArmorLexer lexCtx; /* Context structure we will build and return   */

    lexCtx = (pAppArmorLexer) ANTLR3_MALLOC(sizeof(AppArmorLexer));

    if  (lexCtx == NULL)
    {
        /* Failed to allocate memory for lexer context */
        return  (pAppArmorLexer)ANTLR3_ERR_NOMEM;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * in base ANTLR3 structures. We intialize the function pointers
     * for the standard ANTLR3 lexer function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in AppArmorLexer.h here so you can get a sense
     * of what goes where.
     */
    
    /* Create a base lexer, using the supplied input stream
     */
    lexCtx->pLexer	= antlr3LexerNewStream(ANTLR3_SIZE_HINT, instream);

    /* Check that we allocated the memory correctly
     */
    if	(lexCtx->pLexer == (pANTLR3_LEXER)ANTLR3_ERR_NOMEM)
    {
	ANTLR3_FREE(lexCtx);
	return  (pAppArmorLexer)ANTLR3_ERR_NOMEM;
    }
    /* Install the implementation of our AppArmorLexer interface
     */
    lexCtx->mT32	= mT32;
    lexCtx->mT33	= mT33;
    lexCtx->mT34	= mT34;
    lexCtx->mT35	= mT35;
    lexCtx->mT36	= mT36;
    lexCtx->mT37	= mT37;
    lexCtx->mT38	= mT38;
    lexCtx->mT39	= mT39;
    lexCtx->mT40	= mT40;
    lexCtx->mT41	= mT41;
    lexCtx->mT42	= mT42;
    lexCtx->mT43	= mT43;
    lexCtx->mT44	= mT44;
    lexCtx->mT45	= mT45;
    lexCtx->mT46	= mT46;
    lexCtx->mT47	= mT47;
    lexCtx->mT48	= mT48;
    lexCtx->mT49	= mT49;
    lexCtx->mT50	= mT50;
    lexCtx->mT51	= mT51;
    lexCtx->mT52	= mT52;
    lexCtx->mT53	= mT53;
    lexCtx->mT54	= mT54;
    lexCtx->mT55	= mT55;
    lexCtx->mT56	= mT56;
    lexCtx->mT57	= mT57;
    lexCtx->mT58	= mT58;
    lexCtx->mT59	= mT59;
    lexCtx->mT60	= mT60;
    lexCtx->mT61	= mT61;
    lexCtx->mT62	= mT62;
    lexCtx->mT63	= mT63;
    lexCtx->mT64	= mT64;
    lexCtx->mT65	= mT65;
    lexCtx->mT66	= mT66;
    lexCtx->mT67	= mT67;
    lexCtx->mT68	= mT68;
    lexCtx->mT69	= mT69;
    lexCtx->mT70	= mT70;
    lexCtx->mT71	= mT71;
    lexCtx->mT72	= mT72;
    lexCtx->mT73	= mT73;
    lexCtx->mT74	= mT74;
    lexCtx->mT75	= mT75;
    lexCtx->mT76	= mT76;
    lexCtx->mT77	= mT77;
    lexCtx->mT78	= mT78;
    lexCtx->mT79	= mT79;
    lexCtx->mT80	= mT80;
    lexCtx->mT81	= mT81;
    lexCtx->mT82	= mT82;
    lexCtx->mT83	= mT83;
    lexCtx->mT84	= mT84;
    lexCtx->mT85	= mT85;
    lexCtx->mT86	= mT86;
    lexCtx->mT87	= mT87;
    lexCtx->mT88	= mT88;
    lexCtx->mT89	= mT89;
    lexCtx->mT90	= mT90;
    lexCtx->mT91	= mT91;
    lexCtx->mT92	= mT92;
    lexCtx->mT93	= mT93;
    lexCtx->mT94	= mT94;
    lexCtx->mT95	= mT95;
    lexCtx->mT96	= mT96;
    lexCtx->mT97	= mT97;
    lexCtx->mNEWLINE	= mNEWLINE;
    lexCtx->mLESS_THAN	= mLESS_THAN;
    lexCtx->mGREATER_THAN	= mGREATER_THAN;
    lexCtx->mLEFT_BRACE	= mLEFT_BRACE;
    lexCtx->mRIGHT_BRACE	= mRIGHT_BRACE;
    lexCtx->mAT	= mAT;
    lexCtx->mDOLLAR	= mDOLLAR;
    lexCtx->mLEFT_PAREN	= mLEFT_PAREN;
    lexCtx->mRIGHT_PAREN	= mRIGHT_PAREN;
    lexCtx->mPLUS	= mPLUS;
    lexCtx->mEQUALS	= mEQUALS;
    lexCtx->mCOMMENT_OR_INCLUDE	= mCOMMENT_OR_INCLUDE;
    lexCtx->mINCLUDE	= mINCLUDE;
    lexCtx->mSOL_COMMENT	= mSOL_COMMENT;
    lexCtx->mEOL_COMMENT	= mEOL_COMMENT;
    lexCtx->mCOMMENT	= mCOMMENT;
    lexCtx->mANYTHING_NOT_QUOTED	= mANYTHING_NOT_QUOTED;
    lexCtx->mQUOTED_STRING	= mQUOTED_STRING;
    lexCtx->mPATH	= mPATH;
    lexCtx->mUNQUOTED_PATH	= mUNQUOTED_PATH;
    lexCtx->mLIST_VAR_START	= mLIST_VAR_START;
    lexCtx->mBOOL_VAR_START	= mBOOL_VAR_START;
    lexCtx->mRULE	= mRULE;
    lexCtx->mIDENT_START	= mIDENT_START;
    lexCtx->mIDENT_CONTINUE	= mIDENT_CONTINUE;
    lexCtx->mREAL_IDENT	= mREAL_IDENT;
    lexCtx->mIDENT	= mIDENT;
    lexCtx->mWS	= mWS;
    lexCtx->mTokens	= mTokens;

    
    /** When the nextToken() call is made to this lexer's pANTLR3_TOKEN_SOURCE
     *  it will call mTokens() in this generated code, and will pass it the ctx
     * pointer of this lexer, not the context of the base lexer, so store that now.
     */
    lexCtx->pLexer->ctx	    = lexCtx;
    
    /** Install the token matching function
     */
    lexCtx->pLexer->mTokens = (void (*) (void *))(mTokens);
    
    lexCtx->getGrammarFileName	= getGrammarFileName;
    lexCtx->free		= AppArmorLexerFree;
    
	 
    /* Return the newly built lexer to the caller
     */
    return  lexCtx;
}

/* =========================================================================
 * DFA tables for the lexer
 */
/** Static dfa state tables for Cyclic dfa:
 *    1:1: Tokens : ( T32 | T33 | T34 | T35 | T36 | T37 | T38 | T39 | T40 | T41 | T42 | T43 | T44 | T45 | T46 | T47 | T48 | T49 | T50 | T51 | T52 | T53 | T54 | T55 | T56 | T57 | T58 | T59 | T60 | T61 | T62 | T63 | T64 | T65 | T66 | T67 | T68 | T69 | T70 | T71 | T72 | T73 | T74 | T75 | T76 | T77 | T78 | T79 | T80 | T81 | T82 | T83 | T84 | T85 | T86 | T87 | T88 | T89 | T90 | T91 | T92 | T93 | T94 | T95 | T96 | T97 | NEWLINE | LESS_THAN | GREATER_THAN | LEFT_BRACE | RIGHT_BRACE | AT | DOLLAR | LEFT_PAREN | RIGHT_PAREN | PLUS | EQUALS | COMMENT_OR_INCLUDE | INCLUDE | QUOTED_STRING | UNQUOTED_PATH | LIST_VAR_START | BOOL_VAR_START | RULE | IDENT | WS );
 */
static const ANTLR3_INT32 dfa9_eot[397] =
    {
	-1, 39, 39, 55, 39, 39, 39, 39, 39, -1, 39, 39, 55, 39, 39, 39, 39, 55, 
	39, 55, -1, 55, -1, -1, -1, -1, -1, 110, 112, -1, -1, -1, -1, -1, -1, -1, 
	55, 39, 39, -1, -1, 39, 39, 117, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, -1, 55, 55, 55, 55, 55, 55, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 55, 39, 39, 39, 39, 39, 150, 55, 39, 55, 39, 39, 
	55, 39, 39, 39, 39, 158, 39, 39, 39, 39, 39, 55, 39, 39, 39, 39, 39, 39, 
	39, -1, -1, -1, -1, 55, 55, 39, 175, -1, 39, 39, 39, 39, 180, 39, 39, 184, 
	39, 39, 39, 39, 189, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 206, 39, 39, -1, 39, 39, 211, 55, 39, 39, 217, -1, 39, 39, 
	220, 39, 222, 223, 39, 39, 39, 39, 39, 229, 39, 231, 39, 233, -1, 39, 39, 
	39, 237, -1, 39, 39, 39, -1, 39, 39, 243, 39, -1, 39, 39, 39, 248, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, -1, 39, 264, 265, 39, -1, 267, 
	39, 39, 39, 39, -1, 39, 39, -1, 274, -1, -1, 275, 39, 277, 39, 279, -1, 
	39, -1, 39, -1, 282, 283, 39, -1, 39, 39, 39, 288, 39, -1, 39, 291, 39, 
	39, -1, 39, 39, 39, 297, 39, 39, 39, 39, 39, 39, 39, 39, 306, 39, 308, 
	-1, -1, 309, -1, 39, 39, 39, 39, 39, 39, -1, -1, 39, -1, 39, -1, 39, 319, 
	-1, -1, 39, 39, 322, 323, -1, 324, 39, -1, 39, 39, 328, 329, 39, -1, 39, 
	39, 39, 39, 39, 39, 39, 338, -1, 39, -1, -1, 39, 39, 39, 343, 344, 39, 
	39, 39, 348, -1, 39, 39, -1, -1, -1, 351, 39, 39, -1, -1, 39, 355, 357, 
	39, 39, 39, 39, 362, -1, 363, 364, 365, 366, -1, -1, 39, 39, 39, -1, 39, 
	39, -1, 372, 373, 374, -1, 39, -1, 39, 377, 39, 39, -1, -1, -1, -1, -1, 
	39, 381, 39, 383, 384, -1, -1, -1, 385, 386, -1, 39, 39, 389, -1, 390, 
	-1, -1, -1, -1, 39, 392, -1, -1, 39, -1, 39, 39, 396, -1
    };
static const ANTLR3_INT32 dfa9_eof[397] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1
    };
static const ANTLR3_INT32 dfa9_min[397] =
    {
	9, 99, 97, 42, 101, 99, 101, 97, 97, -1, 102, 100, 42, 101, 114, 108, 50, 
	42, 99, 42, -1, 42, -1, -1, -1, -1, -1, 123, 123, -1, -1, -1, -1, -1, -1, 
	-1, 42, 120, 120, -1, -1, 117, 112, 42, 97, 108, 108, 111, 104, 112, 109, 
	100, 100, 99, 50, -1, 42, 42, 42, 42, 42, 42, 120, 120, 120, 114, 97, 114, 
	99, 115, 111, 105, 115, 114, 102, 109, 97, 112, 42, 111, 99, 112, 120, 
	99, 42, 42, 100, 42, 100, 112, 42, 120, 120, 116, 116, 42, 105, 117, 53, 
	99, 109, 42, 115, 99, 116, 97, 114, 121, 109, -1, -1, -1, -1, 42, 42, 101, 
	42, -1, 103, 115, 100, 109, 42, 108, 112, 42, 105, 101, 53, 115, 42, 111, 
	112, 111, 101, 110, 115, 97, 97, 105, 110, 112, 110, 97, 102, 107, 111, 
	42, 108, 116, -1, 97, 101, 42, 42, 112, 98, 42, -1, 100, 101, 42, 118, 
	42, 42, 101, 117, 100, 112, 112, 42, 101, 42, 105, 42, -1, 115, 101, 95, 
	42, -1, 101, 118, 118, -1, 116, 112, 42, 105, -1, 114, 111, 100, 42, 101, 
	116, 98, 109, 110, 101, 108, 103, 98, 105, 101, 120, -1, 117, 42, 42, 102, 
	-1, 42, 105, 101, 111, 111, -1, 103, 116, -1, 42, -1, -1, 42, 114, 42, 
	97, 42, -1, 97, -1, 116, -1, 42, 42, 104, -1, 116, 99, 99, 42, 116, -1, 
	111, 42, 105, 105, -1, 116, 115, 108, 42, 101, 99, 114, 97, 101, 105, 108, 
	116, 42, 100, 42, -1, -1, 42, -1, 112, 117, 114, 109, 101, 111, -1, -1, 
	105, -1, 99, -1, 109, 42, -1, -1, 97, 97, 42, 42, -1, 42, 110, -1, 110, 
	110, 42, 42, 101, -1, 100, 116, 97, 105, 95, 108, 101, 42, -1, 101, -1, 
	-1, 101, 105, 107, 42, 42, 111, 116, 107, 42, -1, 116, 108, -1, -1, -1, 
	42, 116, 103, -1, -1, 100, 42, 42, 99, 110, 112, 105, 42, -1, 42, 42, 42, 
	42, -1, -1, 116, 121, 101, -1, 115, 107, -1, 42, 42, 42, -1, 100, -1, 107, 
	42, 114, 116, -1, -1, -1, -1, -1, 104, 42, 116, 42, 42, -1, -1, -1, 42, 
	42, -1, 111, 121, 42, -1, 42, -1, -1, -1, -1, 102, 42, -1, -1, 105, -1, 
	108, 101, 42, -1
    };
static const ANTLR3_INT32 dfa9_max[397] =
    {
	255, 114, 114, 255, 105, 120, 105, 111, 120, -1, 120, 120, 255, 111, 114, 
	114, 50, 255, 116, 255, -1, 255, -1, -1, -1, -1, -1, 123, 123, -1, -1, 
	-1, -1, -1, -1, -1, 255, 120, 120, -1, -1, 117, 112, 255, 97, 108, 108, 
	111, 104, 120, 109, 100, 120, 99, 50, -1, 255, 255, 255, 255, 255, 255, 
	120, 120, 120, 114, 97, 114, 100, 115, 111, 105, 115, 114, 102, 110, 97, 
	112, 255, 111, 99, 112, 120, 101, 255, 255, 100, 255, 100, 112, 255, 120, 
	120, 116, 116, 255, 105, 117, 53, 99, 109, 255, 115, 113, 116, 97, 114, 
	121, 120, -1, -1, -1, -1, 255, 255, 101, 255, -1, 103, 115, 100, 109, 255, 
	108, 115, 255, 105, 101, 53, 115, 255, 111, 112, 111, 101, 110, 115, 97, 
	97, 105, 110, 112, 110, 97, 102, 107, 111, 255, 108, 116, -1, 97, 101, 
	255, 255, 112, 119, 255, -1, 100, 101, 255, 118, 255, 255, 101, 117, 100, 
	112, 112, 255, 101, 255, 105, 255, -1, 115, 101, 95, 255, -1, 101, 118, 
	118, -1, 116, 112, 255, 105, -1, 114, 111, 100, 255, 101, 116, 98, 109, 
	110, 116, 108, 103, 98, 105, 101, 120, -1, 117, 255, 255, 102, -1, 255, 
	105, 101, 111, 111, -1, 103, 116, -1, 255, -1, -1, 255, 114, 255, 97, 255, 
	-1, 97, -1, 116, -1, 255, 255, 104, -1, 116, 99, 99, 255, 116, -1, 111, 
	255, 105, 105, -1, 116, 115, 108, 255, 101, 99, 114, 97, 101, 105, 108, 
	116, 255, 100, 255, -1, -1, 255, -1, 112, 117, 114, 109, 101, 111, -1, 
	-1, 105, -1, 99, -1, 109, 255, -1, -1, 97, 97, 255, 255, -1, 255, 110, 
	-1, 110, 110, 255, 255, 101, -1, 100, 116, 97, 105, 95, 108, 101, 255, 
	-1, 101, -1, -1, 101, 105, 107, 255, 255, 111, 116, 107, 255, -1, 116, 
	108, -1, -1, -1, 255, 116, 103, -1, -1, 100, 255, 255, 99, 110, 112, 105, 
	255, -1, 255, 255, 255, 255, -1, -1, 116, 121, 101, -1, 115, 107, -1, 255, 
	255, 255, -1, 100, -1, 107, 255, 114, 116, -1, -1, -1, -1, -1, 104, 255, 
	116, 255, 255, -1, -1, -1, 255, 255, -1, 111, 121, 255, -1, 255, -1, -1, 
	-1, -1, 102, 255, -1, -1, 105, -1, 108, 101, 255, -1
    };
static const ANTLR3_INT32 dfa9_accept[397] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 56, -1, 67, 68, 69, 70, 71, -1, -1, 74, 75, 76, 77, 78, 80, 81, 
	-1, -1, -1, 85, 86, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 84, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 82, 72, 83, 73, -1, -1, -1, -1, 62, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 14, -1, -1, -1, -1, -1, -1, -1, 23, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 51, -1, -1, -1, -1, 
	38, -1, -1, -1, 22, -1, -1, -1, -1, 65, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 53, -1, -1, -1, -1, 52, -1, -1, -1, -1, 
	-1, 19, -1, -1, 31, -1, 49, 50, -1, -1, -1, -1, -1, 41, -1, 36, -1, 1, 
	-1, -1, -1, 63, -1, -1, -1, -1, -1, 27, -1, -1, -1, -1, 15, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 26, 42, -1, 18, -1, -1, 
	-1, -1, -1, -1, 61, 33, -1, 60, -1, 55, -1, -1, 9, 2, -1, -1, -1, -1, 3, 
	-1, -1, 16, -1, -1, -1, -1, -1, 47, -1, -1, -1, -1, -1, -1, -1, -1, 43, 
	-1, 32, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, 66, -1, -1, 40, 30, 58, 
	-1, -1, -1, 39, 20, -1, -1, -1, -1, -1, -1, -1, -1, 37, -1, -1, -1, -1, 
	28, 29, -1, -1, -1, 46, -1, -1, 4, -1, -1, -1, 21, -1, 57, -1, -1, -1, 
	-1, 8, 79, 44, 34, 24, -1, -1, -1, -1, -1, 64, 5, 6, -1, -1, 7, -1, -1, 
	-1, 35, -1, 10, 54, 59, 25, -1, -1, 45, 48, -1, 13, -1, -1, -1, 12
    };
static const ANTLR3_INT32 dfa9_special[397] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa9_T_empty	    NULL

static const ANTLR3_INT32 dfa9_T0[] =
    {
	181
    };static const ANTLR3_INT32 dfa9_T1[] =
    {
	299
    };static const ANTLR3_INT32 dfa9_T2[] =
    {
	172
    };static const ANTLR3_INT32 dfa9_T3[] =
    {
	303
    };static const ANTLR3_INT32 dfa9_T4[] =
    {
	352
    };static const ANTLR3_INT32 dfa9_T5[] =
    {
	285
    };static const ANTLR3_INT32 dfa9_T6[] =
    {
	208
    };static const ANTLR3_INT32 dfa9_T7[] =
    {
	125
    };static const ANTLR3_INT32 dfa9_T8[] =
    {
	39, -1, -1, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, -1, 
	-1, -1, -1, -1, -1, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, -1, -1, -1, -1, 39, 
	-1, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, -1, -1, -1, -1, -1, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39
    };static const ANTLR3_INT32 dfa9_T9[] =
    {
	193
    };static const ANTLR3_INT32 dfa9_T10[] =
    {
	256
    };static const ANTLR3_INT32 dfa9_T11[] =
    {
	89, -1, -1, -1, -1, -1, -1, -1, -1, -1, 88, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 87
    };static const ANTLR3_INT32 dfa9_T12[] =
    {
	188
    };static const ANTLR3_INT32 dfa9_T13[] =
    {
	304
    };static const ANTLR3_INT32 dfa9_T14[] =
    {
	202
    };static const ANTLR3_INT32 dfa9_T15[] =
    {
	153
    };static const ANTLR3_INT32 dfa9_T16[] =
    {
	139
    };static const ANTLR3_INT32 dfa9_T17[] =
    {
	296
    };static const ANTLR3_INT32 dfa9_T18[] =
    {
	227
    };static const ANTLR3_INT32 dfa9_T19[] =
    {
	187
    };static const ANTLR3_INT32 dfa9_T20[] =
    {
	205
    };static const ANTLR3_INT32 dfa9_T21[] =
    {
	239
    };static const ANTLR3_INT32 dfa9_T22[] =
    {
	334
    };static const ANTLR3_INT32 dfa9_T23[] =
    {
	185
    };static const ANTLR3_INT32 dfa9_T24[] =
    {
	245
    };static const ANTLR3_INT32 dfa9_T25[] =
    {
	332
    };static const ANTLR3_INT32 dfa9_T26[] =
    {
	295
    };static const ANTLR3_INT32 dfa9_T27[] =
    {
	350
    };static const ANTLR3_INT32 dfa9_T28[] =
    {
	170
    };static const ANTLR3_INT32 dfa9_T29[] =
    {
	314
    };static const ANTLR3_INT32 dfa9_T30[] =
    {
	376
    };static const ANTLR3_INT32 dfa9_T31[] =
    {
	394
    };static const ANTLR3_INT32 dfa9_T32[] =
    {
	191
    };static const ANTLR3_INT32 dfa9_T33[] =
    {
	77, -1, -1, -1, -1, -1, -1, 76, -1, -1, -1, -1, -1, -1, 75
    };static const ANTLR3_INT32 dfa9_T34[] =
    {
	113
    };static const ANTLR3_INT32 dfa9_T35[] =
    {
	39, -1, -1, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, -1, 
	-1, -1, -1, -1, -1, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 63, 39, 39, 39, 39, 64, 39, 39, 39, 39, 39, -1, -1, -1, -1, 39, 
	-1, 90, 39, 39, 39, 39, 39, 39, 39, 62, 39, 60, 58, 59, 39, 39, 91, 39, 
	56, 39, 39, 92, 39, 57, 39, 39, 39, -1, -1, -1, -1, -1, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39
    };static const ANTLR3_INT32 dfa9_T36[] =
    {
	195
    };static const ANTLR3_INT32 dfa9_T37[] =
    {
	116
    };static const ANTLR3_INT32 dfa9_T38[] =
    {
	240
    };static const ANTLR3_INT32 dfa9_T39[] =
    {
	293
    };static const ANTLR3_INT32 dfa9_T40[] =
    {
	335
    };static const ANTLR3_INT32 dfa9_T41[] =
    {
	40, 22, -1, -1, 22, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 40, -1, 34, 33, 28, -1, 20, -1, 29, 30, -1, 31, 9, 
	-1, -1, 35, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, -1, -1, 23, 32, 24, 
	-1, 27, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 37, 
	39, 39, 39, 39, 38, 39, 39, 39, 39, 39, -1, -1, -1, -1, 39, -1, 3, 15, 
	7, 6, 5, 2, 39, 39, 10, 39, 19, 21, 36, 13, 14, 8, 39, 17, 18, 1, 11, 4, 
	12, 16, 39, 39, 25, -1, 26, -1, -1, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39
    };static const ANTLR3_INT32 dfa9_T42[] =
    {
	225
    };static const ANTLR3_INT32 dfa9_T43[] =
    {
	177
    };static const ANTLR3_INT32 dfa9_T44[] =
    {
	354
    };static const ANTLR3_INT32 dfa9_T45[] =
    {
	114
    };static const ANTLR3_INT32 dfa9_T46[] =
    {
	178
    };static const ANTLR3_INT32 dfa9_T47[] =
    {
	310
    };static const ANTLR3_INT32 dfa9_T48[] =
    {
	156
    };static const ANTLR3_INT32 dfa9_T49[] =
    {
	121
    };static const ANTLR3_INT32 dfa9_T50[] =
    {
	257
    };static const ANTLR3_INT32 dfa9_T51[] =
    {
	253
    };static const ANTLR3_INT32 dfa9_T52[] =
    {
	290
    };static const ANTLR3_INT32 dfa9_T53[] =
    {
	111
    };static const ANTLR3_INT32 dfa9_T54[] =
    {
	266
    };static const ANTLR3_INT32 dfa9_T55[] =
    {
	369
    };static const ANTLR3_INT32 dfa9_T56[] =
    {
	331
    };static const ANTLR3_INT32 dfa9_T57[] =
    {
	173, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 85
    };static const ANTLR3_INT32 dfa9_T58[] =
    {
	218
    };static const ANTLR3_INT32 dfa9_T59[] =
    {
	39, -1, -1, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, -1, 
	-1, -1, -1, -1, -1, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 63, 39, 39, 39, 39, 64, 39, 39, 39, 39, 39, -1, -1, -1, -1, 39, 
	-1, 61, 39, 39, 39, 39, 39, 39, 39, 62, 39, 60, 58, 59, 39, 39, 91, 39, 
	56, 39, 39, 92, 39, 57, 39, 39, 39, -1, -1, -1, -1, -1, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39
    };static const ANTLR3_INT32 dfa9_T60[] =
    {
	39, -1, -1, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, -1, 
	-1, -1, -1, -1, -1, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 63, 39, 39, 39, 39, 64, 39, 39, 39, 39, 39, -1, -1, -1, -1, 39, 
	-1, 61, 39, 53, 39, 39, 39, 39, 39, 62, 39, 60, 58, 59, 51, 39, 49, 39, 
	56, 48, 50, 52, 39, 57, 54, 39, 39, -1, -1, -1, -1, -1, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39
    };static const ANTLR3_INT32 dfa9_T61[] =
    {
	317
    };static const ANTLR3_INT32 dfa9_T62[] =
    {
	74, -1, 73, -1, 72
    };static const ANTLR3_INT32 dfa9_T63[] =
    {
	163
    };static const ANTLR3_INT32 dfa9_T64[] =
    {
	316
    };static const ANTLR3_INT32 dfa9_T65[] =
    {
	151
    };static const ANTLR3_INT32 dfa9_T66[] =
    {
	169
    };static const ANTLR3_INT32 dfa9_T67[] =
    {
	232
    };static const ANTLR3_INT32 dfa9_T68[] =
    {
	203
    };static const ANTLR3_INT32 dfa9_T69[] =
    {
	368
    };static const ANTLR3_INT32 dfa9_T70[] =
    {
	196
    };static const ANTLR3_INT32 dfa9_T71[] =
    {
	123, -1, -1, -1, -1, -1, -1, -1, 78
    };static const ANTLR3_INT32 dfa9_T72[] =
    {
	271
    };static const ANTLR3_INT32 dfa9_T73[] =
    {
	284
    };static const ANTLR3_INT32 dfa9_T74[] =
    {
	201
    };static const ANTLR3_INT32 dfa9_T75[] =
    {
	204
    };static const ANTLR3_INT32 dfa9_T76[] =
    {
	141, 140
    };static const ANTLR3_INT32 dfa9_T77[] =
    {
	393
    };static const ANTLR3_INT32 dfa9_T78[] =
    {
	312
    };static const ANTLR3_INT32 dfa9_T79[] =
    {
	166, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 167, -1, -1, 168
    };static const ANTLR3_INT32 dfa9_T80[] =
    {
	152
    };static const ANTLR3_INT32 dfa9_T81[] =
    {
	98
    };static const ANTLR3_INT32 dfa9_T82[] =
    {
	78
    };static const ANTLR3_INT32 dfa9_T83[] =
    {
	39, -1, -1, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, -1, 
	-1, -1, -1, -1, -1, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 63, 39, 39, 39, 39, 64, 39, 39, 39, 39, 39, -1, -1, -1, -1, 39, 
	-1, 61, 39, 39, 39, 39, 39, 39, 39, 62, 39, 60, 58, 59, 212, 39, 91, 39, 
	56, 39, 39, 92, 39, 57, 39, 39, 39, -1, -1, -1, -1, -1, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39
    };static const ANTLR3_INT32 dfa9_T84[] =
    {
	207
    };static const ANTLR3_INT32 dfa9_T85[] =
    {
	234
    };static const ANTLR3_INT32 dfa9_T86[] =
    {
	281
    };static const ANTLR3_INT32 dfa9_T87[] =
    {
	305
    };static const ANTLR3_INT32 dfa9_T88[] =
    {
	224
    };static const ANTLR3_INT32 dfa9_T89[] =
    {
	39, -1, -1, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, -1, 
	-1, -1, -1, -1, -1, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 63, 39, 39, 39, 39, 64, 39, 39, 39, 39, 39, -1, -1, -1, -1, 39, 
	-1, 61, 39, 39, 39, 39, 39, 39, 39, 62, 39, 60, 58, 59, 155, 39, 91, 39, 
	154, 39, 39, 92, 39, 57, 39, 39, 39, -1, -1, -1, -1, -1, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39
    };static const ANTLR3_INT32 dfa9_T90[] =
    {
	289
    };static const ANTLR3_INT32 dfa9_T91[] =
    {
	302
    };static const ANTLR3_INT32 dfa9_T92[] =
    {
	138
    };static const ANTLR3_INT32 dfa9_T93[] =
    {
	349
    };static const ANTLR3_INT32 dfa9_T94[] =
    {
	387
    };static const ANTLR3_INT32 dfa9_T95[] =
    {
	294
    };static const ANTLR3_INT32 dfa9_T96[] =
    {
	307
    };static const ANTLR3_INT32 dfa9_T97[] =
    {
	192
    };static const ANTLR3_INT32 dfa9_T98[] =
    {
	160
    };static const ANTLR3_INT32 dfa9_T99[] =
    {
	252
    };static const ANTLR3_INT32 dfa9_T100[] =
    {
	337
    };static const ANTLR3_INT32 dfa9_T101[] =
    {
	361
    };static const ANTLR3_INT32 dfa9_T102[] =
    {
	213
    };static const ANTLR3_INT32 dfa9_T103[] =
    {
	300
    };static const ANTLR3_INT32 dfa9_T104[] =
    {
	115
    };static const ANTLR3_INT32 dfa9_T105[] =
    {
	273
    };static const ANTLR3_INT32 dfa9_T106[] =
    {
	269
    };static const ANTLR3_INT32 dfa9_T107[] =
    {
	194
    };static const ANTLR3_INT32 dfa9_T108[] =
    {
	122
    };static const ANTLR3_INT32 dfa9_T109[] =
    {
	388
    };static const ANTLR3_INT32 dfa9_T110[] =
    {
	345
    };static const ANTLR3_INT32 dfa9_T111[] =
    {
	39, -1, -1, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, -1, 
	-1, -1, -1, -1, -1, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 63, 39, 39, 39, 39, 64, 39, 39, 39, 39, 39, -1, -1, -1, -1, 39, 
	-1, 61, 39, 39, 39, 39, 39, 39, 39, 108, 39, 60, 58, 59, 39, 39, 91, 39, 
	56, 39, 39, 92, 39, 57, 39, 39, 39, -1, -1, -1, -1, -1, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39
    };static const ANTLR3_INT32 dfa9_T112[] =
    {
	134
    };static const ANTLR3_INT32 dfa9_T113[] =
    {
	162
    };static const ANTLR3_INT32 dfa9_T114[] =
    {
	254, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 255
    };static const ANTLR3_INT32 dfa9_T115[] =
    {
	45, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 44, -1, -1, 46, -1, -1, 47
    };static const ANTLR3_INT32 dfa9_T116[] =
    {
	341
    };static const ANTLR3_INT32 dfa9_T117[] =
    {
	318
    };static const ANTLR3_INT32 dfa9_T118[] =
    {
	380
    };static const ANTLR3_INT32 dfa9_T119[] =
    {
	39, -1, -1, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, -1, 
	-1, -1, -1, -1, -1, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 63, 39, 39, 39, 39, 64, 39, 39, 39, 39, 39, -1, -1, -1, -1, 39, 
	-1, 101, 39, 39, 100, 99, 39, 39, 39, 62, 39, 60, 58, 59, 39, 102, 91, 
	39, 56, 39, 39, 92, 39, 57, 39, 39, 39, -1, -1, -1, -1, -1, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39
    };static const ANTLR3_INT32 dfa9_T120[] =
    {
	292
    };static const ANTLR3_INT32 dfa9_T121[] =
    {
	148, -1, 149
    };static const ANTLR3_INT32 dfa9_T122[] =
    {
	171
    };static const ANTLR3_INT32 dfa9_T123[] =
    {
	85
    };static const ANTLR3_INT32 dfa9_T124[] =
    {
	238
    };static const ANTLR3_INT32 dfa9_T125[] =
    {
	200
    };static const ANTLR3_INT32 dfa9_T126[] =
    {
	183, -1, -1, 182
    };static const ANTLR3_INT32 dfa9_T127[] =
    {
	93, -1, -1, -1, -1, -1, -1, -1, -1, -1, 94
    };static const ANTLR3_INT32 dfa9_T128[] =
    {
	42, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 43, -1, -1, 41
    };static const ANTLR3_INT32 dfa9_T129[] =
    {
	214, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 216, -1, 
	-1, -1, -1, 215
    };static const ANTLR3_INT32 dfa9_T130[] =
    {
	339
    };static const ANTLR3_INT32 dfa9_T131[] =
    {
	128
    };static const ANTLR3_INT32 dfa9_T132[] =
    {
	371
    };static const ANTLR3_INT32 dfa9_T133[] =
    {
	244
    };static const ANTLR3_INT32 dfa9_T134[] =
    {
	259
    };static const ANTLR3_INT32 dfa9_T135[] =
    {
	258
    };static const ANTLR3_INT32 dfa9_T136[] =
    {
	118
    };static const ANTLR3_INT32 dfa9_T137[] =
    {
	228
    };static const ANTLR3_INT32 dfa9_T138[] =
    {
	330
    };static const ANTLR3_INT32 dfa9_T139[] =
    {
	278
    };static const ANTLR3_INT32 dfa9_T140[] =
    {
	268
    };static const ANTLR3_INT32 dfa9_T141[] =
    {
	301
    };static const ANTLR3_INT32 dfa9_T142[] =
    {
	129
    };static const ANTLR3_INT32 dfa9_T143[] =
    {
	276
    };static const ANTLR3_INT32 dfa9_T144[] =
    {
	336
    };static const ANTLR3_INT32 dfa9_T145[] =
    {
	251
    };static const ANTLR3_INT32 dfa9_T146[] =
    {
	359
    };static const ANTLR3_INT32 dfa9_T147[] =
    {
	136
    };static const ANTLR3_INT32 dfa9_T148[] =
    {
	286
    };static const ANTLR3_INT32 dfa9_T149[] =
    {
	130
    };static const ANTLR3_INT32 dfa9_T150[] =
    {
	327
    };static const ANTLR3_INT32 dfa9_T151[] =
    {
	246
    };static const ANTLR3_INT32 dfa9_T152[] =
    {
	120
    };static const ANTLR3_INT32 dfa9_T153[] =
    {
	321
    };static const ANTLR3_INT32 dfa9_T154[] =
    {
	65, -1, -1, -1, 66
    };static const ANTLR3_INT32 dfa9_T155[] =
    {
	287
    };static const ANTLR3_INT32 dfa9_T156[] =
    {
	272
    };static const ANTLR3_INT32 dfa9_T157[] =
    {
	358
    };static const ANTLR3_INT32 dfa9_T158[] =
    {
	241
    };static const ANTLR3_INT32 dfa9_T159[] =
    {
	197
    };static const ANTLR3_INT32 dfa9_T160[] =
    {
	190
    };static const ANTLR3_INT32 dfa9_T161[] =
    {
	395
    };static const ANTLR3_INT32 dfa9_T162[] =
    {
	261
    };static const ANTLR3_INT32 dfa9_T163[] =
    {
	161
    };static const ANTLR3_INT32 dfa9_T164[] =
    {
	209
    };static const ANTLR3_INT32 dfa9_T165[] =
    {
	347
    };static const ANTLR3_INT32 dfa9_T166[] =
    {
	353
    };static const ANTLR3_INT32 dfa9_T167[] =
    {
	146
    };static const ANTLR3_INT32 dfa9_T168[] =
    {
	226
    };static const ANTLR3_INT32 dfa9_T169[] =
    {
	360
    };static const ANTLR3_INT32 dfa9_T170[] =
    {
	147
    };static const ANTLR3_INT32 dfa9_T171[] =
    {
	159
    };static const ANTLR3_INT32 dfa9_T172[] =
    {
	235
    };static const ANTLR3_INT32 dfa9_T173[] =
    {
	382
    };static const ANTLR3_INT32 dfa9_T174[] =
    {
	179
    };static const ANTLR3_INT32 dfa9_T175[] =
    {
	298
    };static const ANTLR3_INT32 dfa9_T176[] =
    {
	325
    };static const ANTLR3_INT32 dfa9_T177[] =
    {
	119
    };static const ANTLR3_INT32 dfa9_T178[] =
    {
	186
    };static const ANTLR3_INT32 dfa9_T179[] =
    {
	39, -1, -1, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, -1, 
	-1, -1, -1, -1, -1, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 63, 39, 39, 39, 39, 64, 39, 39, 39, 39, 39, -1, -1, -1, -1, 39, 
	-1, 61, 39, 39, 39, 107, 39, 39, 39, 62, 39, 60, 58, 59, 39, 39, 91, 39, 
	56, 39, 39, 92, 39, 57, 39, 39, 39, -1, -1, -1, -1, -1, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39
    };static const ANTLR3_INT32 dfa9_T180[] =
    {
	87
    };static const ANTLR3_INT32 dfa9_T181[] =
    {
	124
    };static const ANTLR3_INT32 dfa9_T182[] =
    {
	370
    };static const ANTLR3_INT32 dfa9_T183[] =
    {
	346
    };static const ANTLR3_INT32 dfa9_T184[] =
    {
	126, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 87
    };static const ANTLR3_INT32 dfa9_T185[] =
    {
	144
    };static const ANTLR3_INT32 dfa9_T186[] =
    {
	137
    };static const ANTLR3_INT32 dfa9_T187[] =
    {
	378
    };static const ANTLR3_INT32 dfa9_T188[] =
    {
	39, -1, -1, 39, 39, 39, 39, 39, 39, 39, 39, 39, 263, 39, 39, 39, 39, -1, 
	-1, -1, -1, -1, -1, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, -1, -1, -1, -1, 39, 
	-1, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, -1, -1, -1, -1, -1, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39
    };static const ANTLR3_INT32 dfa9_T189[] =
    {
	142
    };static const ANTLR3_INT32 dfa9_T190[] =
    {
	242
    };static const ANTLR3_INT32 dfa9_T191[] =
    {
	313
    };static const ANTLR3_INT32 dfa9_T192[] =
    {
	127
    };static const ANTLR3_INT32 dfa9_T193[] =
    {
	270
    };static const ANTLR3_INT32 dfa9_T194[] =
    {
	104, -1, 103, -1, -1, -1, -1, -1, -1, -1, -1, 105, -1, -1, -1, -1, -1, 
	106
    };static const ANTLR3_INT32 dfa9_T195[] =
    {
	80, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 81, -1, 79, 
	-1, -1, -1, -1, -1, 78
    };static const ANTLR3_INT32 dfa9_T196[] =
    {
	236
    };static const ANTLR3_INT32 dfa9_T197[] =
    {
	391
    };static const ANTLR3_INT32 dfa9_T198[] =
    {
	145
    };static const ANTLR3_INT32 dfa9_T199[] =
    {
	280
    };static const ANTLR3_INT32 dfa9_T200[] =
    {
	260
    };static const ANTLR3_INT32 dfa9_T201[] =
    {
	109
    };static const ANTLR3_INT32 dfa9_T202[] =
    {
	165
    };static const ANTLR3_INT32 dfa9_T203[] =
    {
	210
    };static const ANTLR3_INT32 dfa9_T204[] =
    {
	340
    };static const ANTLR3_INT32 dfa9_T205[] =
    {
	342
    };static const ANTLR3_INT32 dfa9_T206[] =
    {
	247
    };static const ANTLR3_INT32 dfa9_T207[] =
    {
	375
    };static const ANTLR3_INT32 dfa9_T208[] =
    {
	219
    };static const ANTLR3_INT32 dfa9_T209[] =
    {
	320
    };static const ANTLR3_INT32 dfa9_T210[] =
    {
	199
    };static const ANTLR3_INT32 dfa9_T211[] =
    {
	262
    };static const ANTLR3_INT32 dfa9_T212[] =
    {
	250
    };static const ANTLR3_INT32 dfa9_T213[] =
    {
	70, -1, -1, -1, -1, -1, -1, -1, -1, 69, -1, 68, -1, -1, -1, 67, -1, -1, 
	-1, -1, -1, 71
    };static const ANTLR3_INT32 dfa9_T214[] =
    {
	143
    };static const ANTLR3_INT32 dfa9_T215[] =
    {
	95
    };static const ANTLR3_INT32 dfa9_T216[] =
    {
	131
    };static const ANTLR3_INT32 dfa9_T217[] =
    {
	97, -1, -1, -1, -1, -1, 96
    };static const ANTLR3_INT32 dfa9_T218[] =
    {
	135
    };static const ANTLR3_INT32 dfa9_T219[] =
    {
	174
    };static const ANTLR3_INT32 dfa9_T220[] =
    {
	315
    };static const ANTLR3_INT32 dfa9_T221[] =
    {
	333
    };static const ANTLR3_INT32 dfa9_T222[] =
    {
	157
    };static const ANTLR3_INT32 dfa9_T223[] =
    {
	379
    };static const ANTLR3_INT32 dfa9_T224[] =
    {
	221
    };static const ANTLR3_INT32 dfa9_T225[] =
    {
	198
    };static const ANTLR3_INT32 dfa9_T226[] =
    {
	39, -1, -1, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, -1, 
	-1, -1, -1, -1, -1, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 63, 39, 39, 39, 39, 64, 39, 39, 39, 39, 39, -1, -1, -1, -1, 39, 
	-1, 61, 39, 39, 39, 39, 39, 39, 39, 62, 39, 60, 58, 59, 39, 39, 91, 39, 
	56, 39, 39, 92, 39, 164, 39, 39, 39, -1, -1, -1, -1, -1, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39
    };static const ANTLR3_INT32 dfa9_T227[] =
    {
	367
    };static const ANTLR3_INT32 dfa9_T228[] =
    {
	326
    };static const ANTLR3_INT32 dfa9_T229[] =
    {
	39, -1, -1, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, -1, 
	-1, -1, -1, -1, -1, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, -1, -1, -1, -1, 39, 
	-1, 39, 39, 39, 39, 356, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, -1, -1, -1, -1, -1, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39
    };static const ANTLR3_INT32 dfa9_T230[] =
    {
	176
    };static const ANTLR3_INT32 dfa9_T231[] =
    {
	133, 132
    };static const ANTLR3_INT32 dfa9_T232[] =
    {
	230
    };static const ANTLR3_INT32 dfa9_T233[] =
    {
	311
    };static const ANTLR3_INT32 dfa9_T234[] =
    {
	84, -1, -1, -1, -1, -1, -1, -1, 83, -1, 82, -1, 86, -1, -1, -1, -1, -1, 
	85
    };static const ANTLR3_INT32 dfa9_T235[] =
    {
	249
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa9_transitions[] =
{
    dfa9_T41, dfa9_T128, dfa9_T115, dfa9_T60, dfa9_T154, dfa9_T213, dfa9_T62, 
    dfa9_T33, dfa9_T195, dfa9_T_empty, dfa9_T234, dfa9_T11, dfa9_T35, dfa9_T127, 
    dfa9_T215, dfa9_T217, dfa9_T81, dfa9_T119, dfa9_T194, dfa9_T179, dfa9_T_empty, 
    dfa9_T111, dfa9_T_empty, dfa9_T_empty, dfa9_T_empty, dfa9_T_empty, dfa9_T_empty, 
    dfa9_T201, dfa9_T53, dfa9_T_empty, dfa9_T_empty, dfa9_T_empty, dfa9_T_empty, 
    dfa9_T_empty, dfa9_T_empty, dfa9_T_empty, dfa9_T59, dfa9_T34, dfa9_T45, 
    dfa9_T_empty, dfa9_T_empty, dfa9_T104, dfa9_T37, dfa9_T8, dfa9_T136, 
    dfa9_T177, dfa9_T152, dfa9_T49, dfa9_T108, dfa9_T71, dfa9_T181, dfa9_T7, 
    dfa9_T184, dfa9_T192, dfa9_T131, dfa9_T_empty, dfa9_T59, dfa9_T59, dfa9_T59, 
    dfa9_T59, dfa9_T59, dfa9_T59, dfa9_T123, dfa9_T34, dfa9_T45, dfa9_T142, 
    dfa9_T149, dfa9_T216, dfa9_T231, dfa9_T112, dfa9_T218, dfa9_T147, dfa9_T186, 
    dfa9_T92, dfa9_T16, dfa9_T76, dfa9_T189, dfa9_T214, dfa9_T59, dfa9_T185, 
    dfa9_T198, dfa9_T167, dfa9_T170, dfa9_T121, dfa9_T8, dfa9_T59, dfa9_T65, 
    dfa9_T59, dfa9_T80, dfa9_T15, dfa9_T89, dfa9_T82, dfa9_T180, dfa9_T48, 
    dfa9_T222, dfa9_T8, dfa9_T171, dfa9_T98, dfa9_T163, dfa9_T113, dfa9_T63, 
    dfa9_T226, dfa9_T202, dfa9_T79, dfa9_T66, dfa9_T28, dfa9_T122, dfa9_T2, 
    dfa9_T57, dfa9_T_empty, dfa9_T_empty, dfa9_T_empty, dfa9_T_empty, dfa9_T59, 
    dfa9_T59, dfa9_T219, dfa9_T8, dfa9_T_empty, dfa9_T230, dfa9_T43, dfa9_T46, 
    dfa9_T174, dfa9_T8, dfa9_T0, dfa9_T126, dfa9_T8, dfa9_T23, dfa9_T178, 
    dfa9_T19, dfa9_T12, dfa9_T8, dfa9_T160, dfa9_T32, dfa9_T97, dfa9_T9, 
    dfa9_T107, dfa9_T36, dfa9_T70, dfa9_T159, dfa9_T225, dfa9_T210, dfa9_T125, 
    dfa9_T74, dfa9_T14, dfa9_T68, dfa9_T75, dfa9_T20, dfa9_T8, dfa9_T84, 
    dfa9_T6, dfa9_T_empty, dfa9_T164, dfa9_T203, dfa9_T8, dfa9_T83, dfa9_T102, 
    dfa9_T129, dfa9_T8, dfa9_T_empty, dfa9_T58, dfa9_T208, dfa9_T8, dfa9_T224, 
    dfa9_T8, dfa9_T59, dfa9_T88, dfa9_T42, dfa9_T168, dfa9_T18, dfa9_T137, 
    dfa9_T8, dfa9_T232, dfa9_T8, dfa9_T67, dfa9_T8, dfa9_T_empty, dfa9_T85, 
    dfa9_T172, dfa9_T196, dfa9_T8, dfa9_T_empty, dfa9_T124, dfa9_T21, dfa9_T38, 
    dfa9_T_empty, dfa9_T158, dfa9_T190, dfa9_T8, dfa9_T133, dfa9_T_empty, 
    dfa9_T24, dfa9_T151, dfa9_T206, dfa9_T8, dfa9_T235, dfa9_T212, dfa9_T145, 
    dfa9_T99, dfa9_T51, dfa9_T114, dfa9_T10, dfa9_T50, dfa9_T135, dfa9_T134, 
    dfa9_T200, dfa9_T162, dfa9_T_empty, dfa9_T211, dfa9_T188, dfa9_T8, dfa9_T54, 
    dfa9_T_empty, dfa9_T8, dfa9_T140, dfa9_T106, dfa9_T193, dfa9_T72, dfa9_T_empty, 
    dfa9_T156, dfa9_T105, dfa9_T_empty, dfa9_T8, dfa9_T_empty, dfa9_T_empty, 
    dfa9_T8, dfa9_T143, dfa9_T8, dfa9_T139, dfa9_T8, dfa9_T_empty, dfa9_T199, 
    dfa9_T_empty, dfa9_T86, dfa9_T_empty, dfa9_T8, dfa9_T8, dfa9_T73, dfa9_T_empty, 
    dfa9_T5, dfa9_T148, dfa9_T155, dfa9_T8, dfa9_T90, dfa9_T_empty, dfa9_T52, 
    dfa9_T8, dfa9_T120, dfa9_T39, dfa9_T_empty, dfa9_T95, dfa9_T26, dfa9_T17, 
    dfa9_T8, dfa9_T175, dfa9_T1, dfa9_T103, dfa9_T141, dfa9_T91, dfa9_T3, 
    dfa9_T13, dfa9_T87, dfa9_T8, dfa9_T96, dfa9_T8, dfa9_T_empty, dfa9_T_empty, 
    dfa9_T8, dfa9_T_empty, dfa9_T47, dfa9_T233, dfa9_T78, dfa9_T191, dfa9_T29, 
    dfa9_T220, dfa9_T_empty, dfa9_T_empty, dfa9_T64, dfa9_T_empty, dfa9_T61, 
    dfa9_T_empty, dfa9_T117, dfa9_T8, dfa9_T_empty, dfa9_T_empty, dfa9_T209, 
    dfa9_T153, dfa9_T8, dfa9_T8, dfa9_T_empty, dfa9_T8, dfa9_T176, dfa9_T_empty, 
    dfa9_T228, dfa9_T150, dfa9_T8, dfa9_T8, dfa9_T138, dfa9_T_empty, dfa9_T56, 
    dfa9_T25, dfa9_T221, dfa9_T22, dfa9_T40, dfa9_T144, dfa9_T100, dfa9_T8, 
    dfa9_T_empty, dfa9_T130, dfa9_T_empty, dfa9_T_empty, dfa9_T204, dfa9_T116, 
    dfa9_T205, dfa9_T8, dfa9_T8, dfa9_T110, dfa9_T183, dfa9_T165, dfa9_T8, 
    dfa9_T_empty, dfa9_T93, dfa9_T27, dfa9_T_empty, dfa9_T_empty, dfa9_T_empty, 
    dfa9_T8, dfa9_T4, dfa9_T166, dfa9_T_empty, dfa9_T_empty, dfa9_T44, dfa9_T8, 
    dfa9_T229, dfa9_T157, dfa9_T146, dfa9_T169, dfa9_T101, dfa9_T8, dfa9_T_empty, 
    dfa9_T8, dfa9_T8, dfa9_T8, dfa9_T8, dfa9_T_empty, dfa9_T_empty, dfa9_T227, 
    dfa9_T69, dfa9_T55, dfa9_T_empty, dfa9_T182, dfa9_T132, dfa9_T_empty, 
    dfa9_T8, dfa9_T8, dfa9_T8, dfa9_T_empty, dfa9_T207, dfa9_T_empty, dfa9_T30, 
    dfa9_T8, dfa9_T187, dfa9_T223, dfa9_T_empty, dfa9_T_empty, dfa9_T_empty, 
    dfa9_T_empty, dfa9_T_empty, dfa9_T118, dfa9_T8, dfa9_T173, dfa9_T8, 
    dfa9_T8, dfa9_T_empty, dfa9_T_empty, dfa9_T_empty, dfa9_T8, dfa9_T8, 
    dfa9_T_empty, dfa9_T94, dfa9_T109, dfa9_T8, dfa9_T_empty, dfa9_T8, dfa9_T_empty, 
    dfa9_T_empty, dfa9_T_empty, dfa9_T_empty, dfa9_T197, dfa9_T8, dfa9_T_empty, 
    dfa9_T_empty, dfa9_T77, dfa9_T_empty, dfa9_T31, dfa9_T161, dfa9_T8, 
    dfa9_T_empty	
};


/* Declare tracking structure for Cyclic DFA 9
 */
static
ANTLR3_CYCLIC_DFA cdfa9
    =	{
	    9,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"1:1: Tokens : ( T32 | T33 | T34 | T35 | T36 | T37 | T38 | T39 | T40 | T41 | T42 | T43 | T44 | T45 | T46 | T47 | T48 | T49 | T50 | T51 | T52 | T53 | T54 | T55 | T56 | T57 | T58 | T59 | T60 | T61 | T62 | T63 | T64 | T65 | T66 | T67 | T68 | T69 | T70 | T71 | T72 | T73 | T74 | T75 | T76 | T77 | T78 | T79 | T80 | T81 | T82 | T83 | T84 | T85 | T86 | T87 | T88 | T89 | T90 | T91 | T92 | T93 | T94 | T95 | T96 | T97 | NEWLINE | LESS_THAN | GREATER_THAN | LEFT_BRACE | RIGHT_BRACE | AT | DOLLAR | LEFT_PAREN | RIGHT_PAREN | PLUS | EQUALS | COMMENT_OR_INCLUDE | INCLUDE | QUOTED_STRING | UNQUOTED_PATH | LIST_VAR_START | BOOL_VAR_START | RULE | IDENT | WS );",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa9_eot,	    /* EOT table			    */
	    dfa9_eof,	    /* EOF table			    */
	    dfa9_min,	    /* Minimum tokens for each state    */
	    dfa9_max,	    /* Maximum tokens for each state    */
	    dfa9_accept,	/* Accept table			    */
	    dfa9_special,	/* Special transition states	    */
	    dfa9_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 9
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the lexer
 */ 

/* =========================================================================
 * Functions to match the lexer grammar defined tokens from the input stream
 */

//   Comes from: 84:5: ( 'true' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T32
 *
 * Looks to match the characters the constitute the token T32
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT32(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T32;
       
    
    // AppArmor.g:84:5: ( 'true' )
    // AppArmor.g:84:7: 'true'
    {
        MATCHS(lit_1); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT32Ex; /* Prevent compiler warnings */
    ruleT32Ex: ;

}
// $ANTLR end T32

//   Comes from: 85:5: ( 'false' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T33
 *
 * Looks to match the characters the constitute the token T33
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT33(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T33;
       
    
    // AppArmor.g:85:5: ( 'false' )
    // AppArmor.g:85:7: 'false'
    {
        MATCHS(lit_2); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT33Ex; /* Prevent compiler warnings */
    ruleT33Ex: ;

}
// $ANTLR end T33

//   Comes from: 86:5: ( 'audit' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T34
 *
 * Looks to match the characters the constitute the token T34
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT34(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T34;
       
    
    // AppArmor.g:86:5: ( 'audit' )
    // AppArmor.g:86:7: 'audit'
    {
        MATCHS(lit_3); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT34Ex; /* Prevent compiler warnings */
    ruleT34Ex: ;

}
// $ANTLR end T34

//   Comes from: 87:5: ( 'version' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T35
 *
 * Looks to match the characters the constitute the token T35
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT35(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T35;
       
    
    // AppArmor.g:87:5: ( 'version' )
    // AppArmor.g:87:7: 'version'
    {
        MATCHS(lit_4); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT35Ex; /* Prevent compiler warnings */
    ruleT35Ex: ;

}
// $ANTLR end T35

//   Comes from: 88:5: ( 'encoding' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T36
 *
 * Looks to match the characters the constitute the token T36
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT36(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T36;
       
    
    // AppArmor.g:88:5: ( 'encoding' )
    // AppArmor.g:88:7: 'encoding'
    {
        MATCHS(lit_5); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT36Ex; /* Prevent compiler warnings */
    ruleT36Ex: ;

}
// $ANTLR end T36

//   Comes from: 89:5: ( 'disabled' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T37
 *
 * Looks to match the characters the constitute the token T37
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT37(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T37;
       
    
    // AppArmor.g:89:5: ( 'disabled' )
    // AppArmor.g:89:7: 'disabled'
    {
        MATCHS(lit_6); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT37Ex; /* Prevent compiler warnings */
    ruleT37Ex: ;

}
// $ANTLR end T37

//   Comes from: 90:5: ( 'complain' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T38
 *
 * Looks to match the characters the constitute the token T38
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT38(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T38;
       
    
    // AppArmor.g:90:5: ( 'complain' )
    // AppArmor.g:90:7: 'complain'
    {
        MATCHS(lit_7); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT38Ex; /* Prevent compiler warnings */
    ruleT38Ex: ;

}
// $ANTLR end T38

//   Comes from: 91:5: ( 'profile' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T39
 *
 * Looks to match the characters the constitute the token T39
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT39(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T39;
       
    
    // AppArmor.g:91:5: ( 'profile' )
    // AppArmor.g:91:7: 'profile'
    {
        MATCHS(lit_8); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT39Ex; /* Prevent compiler warnings */
    ruleT39Ex: ;

}
// $ANTLR end T39

//   Comes from: 92:5: ( 'flags' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T40
 *
 * Looks to match the characters the constitute the token T40
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT40(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T40;
       
    
    // AppArmor.g:92:5: ( 'flags' )
    // AppArmor.g:92:7: 'flags'
    {
        MATCHS(lit_9); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT40Ex; /* Prevent compiler warnings */
    ruleT40Ex: ;

}
// $ANTLR end T40

//   Comes from: 93:5: ( 'fold_hats' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T41
 *
 * Looks to match the characters the constitute the token T41
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT41(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T41;
       
    
    // AppArmor.g:93:5: ( 'fold_hats' )
    // AppArmor.g:93:7: 'fold_hats'
    {
        MATCHS(lit_10); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT41Ex; /* Prevent compiler warnings */
    ruleT41Ex: ;

}
// $ANTLR end T41

//   Comes from: 94:5: ( ',' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T42
 *
 * Looks to match the characters the constitute the token T42
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT42(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T42;
       
    
    // AppArmor.g:94:5: ( ',' )
    // AppArmor.g:94:7: ','
    {
        MATCHC(','); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT42Ex; /* Prevent compiler warnings */
    ruleT42Ex: ;

}
// $ANTLR end T42

//   Comes from: 95:5: ( 'change_profile' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T43
 *
 * Looks to match the characters the constitute the token T43
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT43(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T43;
       
    
    // AppArmor.g:95:5: ( 'change_profile' )
    // AppArmor.g:95:7: 'change_profile'
    {
        MATCHS(lit_11); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT43Ex; /* Prevent compiler warnings */
    ruleT43Ex: ;

}
// $ANTLR end T43

//   Comes from: 96:5: ( 'capability' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T44
 *
 * Looks to match the characters the constitute the token T44
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT44(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T44;
       
    
    // AppArmor.g:96:5: ( 'capability' )
    // AppArmor.g:96:7: 'capability'
    {
        MATCHS(lit_12); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT44Ex; /* Prevent compiler warnings */
    ruleT44Ex: ;

}
// $ANTLR end T44

//   Comes from: 97:5: ( 'if' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T45
 *
 * Looks to match the characters the constitute the token T45
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT45(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T45;
       
    
    // AppArmor.g:97:5: ( 'if' )
    // AppArmor.g:97:7: 'if'
    {
        MATCHS(lit_13); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT45Ex; /* Prevent compiler warnings */
    ruleT45Ex: ;

}
// $ANTLR end T45

//   Comes from: 98:5: ( 'else' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T46
 *
 * Looks to match the characters the constitute the token T46
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT46(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T46;
       
    
    // AppArmor.g:98:5: ( 'else' )
    // AppArmor.g:98:7: 'else'
    {
        MATCHS(lit_14); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT46Ex; /* Prevent compiler warnings */
    ruleT46Ex: ;

}
// $ANTLR end T46

//   Comes from: 99:5: ( 'error' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T47
 *
 * Looks to match the characters the constitute the token T47
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT47(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T47;
       
    
    // AppArmor.g:99:5: ( 'error' )
    // AppArmor.g:99:7: 'error'
    {
        MATCHS(lit_15); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT47Ex; /* Prevent compiler warnings */
    ruleT47Ex: ;

}
// $ANTLR end T47

//   Comes from: 100:5: ( 'undef' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T48
 *
 * Looks to match the characters the constitute the token T48
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT48(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T48;
       
    
    // AppArmor.g:100:5: ( 'undef' )
    // AppArmor.g:100:7: 'undef'
    {
        MATCHS(lit_16); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT48Ex; /* Prevent compiler warnings */
    ruleT48Ex: ;

}
// $ANTLR end T48

//   Comes from: 101:5: ( 'warn' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T49
 *
 * Looks to match the characters the constitute the token T49
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT49(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T49;
       
    
    // AppArmor.g:101:5: ( 'warn' )
    // AppArmor.g:101:7: 'warn'
    {
        MATCHS(lit_17); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT49Ex; /* Prevent compiler warnings */
    ruleT49Ex: ;

}
// $ANTLR end T49

//   Comes from: 102:5: ( 'not' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T50
 *
 * Looks to match the characters the constitute the token T50
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT50(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T50;
       
    
    // AppArmor.g:102:5: ( 'not' )
    // AppArmor.g:102:7: 'not'
    {
        MATCHS(lit_18); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT50Ex; /* Prevent compiler warnings */
    ruleT50Ex: ;

}
// $ANTLR end T50

//   Comes from: 103:5: ( 'exists' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T51
 *
 * Looks to match the characters the constitute the token T51
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT51(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T51;
       
    
    // AppArmor.g:103:5: ( 'exists' )
    // AppArmor.g:103:7: 'exists'
    {
        MATCHS(lit_19); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT51Ex; /* Prevent compiler warnings */
    ruleT51Ex: ;

}
// $ANTLR end T51

//   Comes from: 104:5: ( 'defined' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T52
 *
 * Looks to match the characters the constitute the token T52
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT52(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T52;
       
    
    // AppArmor.g:104:5: ( 'defined' )
    // AppArmor.g:104:7: 'defined'
    {
        MATCHS(lit_20); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT52Ex; /* Prevent compiler warnings */
    ruleT52Ex: ;

}
// $ANTLR end T52

//   Comes from: 105:5: ( 'and' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T53
 *
 * Looks to match the characters the constitute the token T53
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT53(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T53;
       
    
    // AppArmor.g:105:5: ( 'and' )
    // AppArmor.g:105:7: 'and'
    {
        MATCHS(lit_21); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT53Ex; /* Prevent compiler warnings */
    ruleT53Ex: ;

}
// $ANTLR end T53

//   Comes from: 106:5: ( 'or' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T54
 *
 * Looks to match the characters the constitute the token T54
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT54(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T54;
       
    
    // AppArmor.g:106:5: ( 'or' )
    // AppArmor.g:106:7: 'or'
    {
        MATCHS(lit_22); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT54Ex; /* Prevent compiler warnings */
    ruleT54Ex: ;

}
// $ANTLR end T54

//   Comes from: 107:5: ( 'network' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T55
 *
 * Looks to match the characters the constitute the token T55
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT55(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T55;
       
    
    // AppArmor.g:107:5: ( 'network' )
    // AppArmor.g:107:7: 'network'
    {
        MATCHS(lit_23); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT55Ex; /* Prevent compiler warnings */
    ruleT55Ex: ;

}
// $ANTLR end T55

//   Comes from: 108:5: ( 'conntrack' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T56
 *
 * Looks to match the characters the constitute the token T56
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT56(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T56;
       
    
    // AppArmor.g:108:5: ( 'conntrack' )
    // AppArmor.g:108:7: 'conntrack'
    {
        MATCHS(lit_24); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT56Ex; /* Prevent compiler warnings */
    ruleT56Ex: ;

}
// $ANTLR end T56

//   Comes from: 109:5: ( 'inet' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T57
 *
 * Looks to match the characters the constitute the token T57
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT57(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T57;
       
    
    // AppArmor.g:109:5: ( 'inet' )
    // AppArmor.g:109:7: 'inet'
    {
        MATCHS(lit_25); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT57Ex; /* Prevent compiler warnings */
    ruleT57Ex: ;

}
// $ANTLR end T57

//   Comes from: 110:5: ( 'ax25' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T58
 *
 * Looks to match the characters the constitute the token T58
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT58(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T58;
       
    
    // AppArmor.g:110:5: ( 'ax25' )
    // AppArmor.g:110:7: 'ax25'
    {
        MATCHS(lit_26); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT58Ex; /* Prevent compiler warnings */
    ruleT58Ex: ;

}
// $ANTLR end T58

//   Comes from: 111:5: ( 'netrom' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T59
 *
 * Looks to match the characters the constitute the token T59
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT59(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T59;
       
    
    // AppArmor.g:111:5: ( 'netrom' )
    // AppArmor.g:111:7: 'netrom'
    {
        MATCHS(lit_27); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT59Ex; /* Prevent compiler warnings */
    ruleT59Ex: ;

}
// $ANTLR end T59

//   Comes from: 112:5: ( 'bridge' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T60
 *
 * Looks to match the characters the constitute the token T60
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT60(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T60;
       
    
    // AppArmor.g:112:5: ( 'bridge' )
    // AppArmor.g:112:7: 'bridge'
    {
        MATCHS(lit_28); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT60Ex; /* Prevent compiler warnings */
    ruleT60Ex: ;

}
// $ANTLR end T60

//   Comes from: 113:5: ( 'atmpvc' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T61
 *
 * Looks to match the characters the constitute the token T61
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT61(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T61;
       
    
    // AppArmor.g:113:5: ( 'atmpvc' )
    // AppArmor.g:113:7: 'atmpvc'
    {
        MATCHS(lit_29); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT61Ex; /* Prevent compiler warnings */
    ruleT61Ex: ;

}
// $ANTLR end T61

//   Comes from: 114:5: ( 'x25' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T62
 *
 * Looks to match the characters the constitute the token T62
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT62(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T62;
       
    
    // AppArmor.g:114:5: ( 'x25' )
    // AppArmor.g:114:7: 'x25'
    {
        MATCHS(lit_30); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT62Ex; /* Prevent compiler warnings */
    ruleT62Ex: ;

}
// $ANTLR end T62

//   Comes from: 115:5: ( 'inet6' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T63
 *
 * Looks to match the characters the constitute the token T63
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT63(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T63;
       
    
    // AppArmor.g:115:5: ( 'inet6' )
    // AppArmor.g:115:7: 'inet6'
    {
        MATCHS(lit_31); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT63Ex; /* Prevent compiler warnings */
    ruleT63Ex: ;

}
// $ANTLR end T63

//   Comes from: 116:5: ( 'rose' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T64
 *
 * Looks to match the characters the constitute the token T64
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT64(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T64;
       
    
    // AppArmor.g:116:5: ( 'rose' )
    // AppArmor.g:116:7: 'rose'
    {
        MATCHS(lit_32); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT64Ex; /* Prevent compiler warnings */
    ruleT64Ex: ;

}
// $ANTLR end T64

//   Comes from: 117:5: ( 'netbeui' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T65
 *
 * Looks to match the characters the constitute the token T65
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT65(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T65;
       
    
    // AppArmor.g:117:5: ( 'netbeui' )
    // AppArmor.g:117:7: 'netbeui'
    {
        MATCHS(lit_33); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT65Ex; /* Prevent compiler warnings */
    ruleT65Ex: ;

}
// $ANTLR end T65

//   Comes from: 118:5: ( 'security' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T66
 *
 * Looks to match the characters the constitute the token T66
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT66(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T66;
       
    
    // AppArmor.g:118:5: ( 'security' )
    // AppArmor.g:118:7: 'security'
    {
        MATCHS(lit_34); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT66Ex; /* Prevent compiler warnings */
    ruleT66Ex: ;

}
// $ANTLR end T66

//   Comes from: 119:5: ( 'key' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T67
 *
 * Looks to match the characters the constitute the token T67
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT67(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T67;
       
    
    // AppArmor.g:119:5: ( 'key' )
    // AppArmor.g:119:7: 'key'
    {
        MATCHS(lit_35); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT67Ex; /* Prevent compiler warnings */
    ruleT67Ex: ;

}
// $ANTLR end T67

//   Comes from: 120:5: ( 'packet' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T68
 *
 * Looks to match the characters the constitute the token T68
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT68(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T68;
       
    
    // AppArmor.g:120:5: ( 'packet' )
    // AppArmor.g:120:7: 'packet'
    {
        MATCHS(lit_36); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT68Ex; /* Prevent compiler warnings */
    ruleT68Ex: ;

}
// $ANTLR end T68

//   Comes from: 121:5: ( 'ash' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T69
 *
 * Looks to match the characters the constitute the token T69
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT69(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T69;
       
    
    // AppArmor.g:121:5: ( 'ash' )
    // AppArmor.g:121:7: 'ash'
    {
        MATCHS(lit_37); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT69Ex; /* Prevent compiler warnings */
    ruleT69Ex: ;

}
// $ANTLR end T69

//   Comes from: 122:5: ( 'econet' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T70
 *
 * Looks to match the characters the constitute the token T70
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT70(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T70;
       
    
    // AppArmor.g:122:5: ( 'econet' )
    // AppArmor.g:122:7: 'econet'
    {
        MATCHS(lit_38); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT70Ex; /* Prevent compiler warnings */
    ruleT70Ex: ;

}
// $ANTLR end T70

//   Comes from: 123:5: ( 'atmsvc' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T71
 *
 * Looks to match the characters the constitute the token T71
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT71(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T71;
       
    
    // AppArmor.g:123:5: ( 'atmsvc' )
    // AppArmor.g:123:7: 'atmsvc'
    {
        MATCHS(lit_39); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT71Ex; /* Prevent compiler warnings */
    ruleT71Ex: ;

}
// $ANTLR end T71

//   Comes from: 124:5: ( 'sna' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T72
 *
 * Looks to match the characters the constitute the token T72
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT72(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T72;
       
    
    // AppArmor.g:124:5: ( 'sna' )
    // AppArmor.g:124:7: 'sna'
    {
        MATCHS(lit_40); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT72Ex; /* Prevent compiler warnings */
    ruleT72Ex: ;

}
// $ANTLR end T72

//   Comes from: 125:5: ( 'irda' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T73
 *
 * Looks to match the characters the constitute the token T73
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT73(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T73;
       
    
    // AppArmor.g:125:5: ( 'irda' )
    // AppArmor.g:125:7: 'irda'
    {
        MATCHS(lit_41); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT73Ex; /* Prevent compiler warnings */
    ruleT73Ex: ;

}
// $ANTLR end T73

//   Comes from: 126:5: ( 'pppox' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T74
 *
 * Looks to match the characters the constitute the token T74
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT74(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T74;
       
    
    // AppArmor.g:126:5: ( 'pppox' )
    // AppArmor.g:126:7: 'pppox'
    {
        MATCHS(lit_42); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT74Ex; /* Prevent compiler warnings */
    ruleT74Ex: ;

}
// $ANTLR end T74

//   Comes from: 127:5: ( 'wanpipe' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T75
 *
 * Looks to match the characters the constitute the token T75
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT75(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T75;
       
    
    // AppArmor.g:127:5: ( 'wanpipe' )
    // AppArmor.g:127:7: 'wanpipe'
    {
        MATCHS(lit_43); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT75Ex; /* Prevent compiler warnings */
    ruleT75Ex: ;

}
// $ANTLR end T75

//   Comes from: 128:5: ( 'bluetooth' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T76
 *
 * Looks to match the characters the constitute the token T76
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT76(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T76;
       
    
    // AppArmor.g:128:5: ( 'bluetooth' )
    // AppArmor.g:128:7: 'bluetooth'
    {
        MATCHS(lit_44); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT76Ex; /* Prevent compiler warnings */
    ruleT76Ex: ;

}
// $ANTLR end T76

//   Comes from: 129:5: ( 'stream' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T77
 *
 * Looks to match the characters the constitute the token T77
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT77(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T77;
       
    
    // AppArmor.g:129:5: ( 'stream' )
    // AppArmor.g:129:7: 'stream'
    {
        MATCHS(lit_45); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT77Ex; /* Prevent compiler warnings */
    ruleT77Ex: ;

}
// $ANTLR end T77

//   Comes from: 130:5: ( 'dgram' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T78
 *
 * Looks to match the characters the constitute the token T78
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT78(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T78;
       
    
    // AppArmor.g:130:5: ( 'dgram' )
    // AppArmor.g:130:7: 'dgram'
    {
        MATCHS(lit_46); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT78Ex; /* Prevent compiler warnings */
    ruleT78Ex: ;

}
// $ANTLR end T78

//   Comes from: 131:5: ( 'seqpacket' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T79
 *
 * Looks to match the characters the constitute the token T79
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT79(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T79;
       
    
    // AppArmor.g:131:5: ( 'seqpacket' )
    // AppArmor.g:131:7: 'seqpacket'
    {
        MATCHS(lit_47); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT79Ex; /* Prevent compiler warnings */
    ruleT79Ex: ;

}
// $ANTLR end T79

//   Comes from: 132:5: ( 'rdm' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T80
 *
 * Looks to match the characters the constitute the token T80
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT80(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T80;
       
    
    // AppArmor.g:132:5: ( 'rdm' )
    // AppArmor.g:132:7: 'rdm'
    {
        MATCHS(lit_48); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT80Ex; /* Prevent compiler warnings */
    ruleT80Ex: ;

}
// $ANTLR end T80

//   Comes from: 133:5: ( 'raw' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T81
 *
 * Looks to match the characters the constitute the token T81
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT81(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T81;
       
    
    // AppArmor.g:133:5: ( 'raw' )
    // AppArmor.g:133:7: 'raw'
    {
        MATCHS(lit_49); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT81Ex; /* Prevent compiler warnings */
    ruleT81Ex: ;

}
// $ANTLR end T81

//   Comes from: 134:5: ( 'tcp' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T82
 *
 * Looks to match the characters the constitute the token T82
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT82(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T82;
       
    
    // AppArmor.g:134:5: ( 'tcp' )
    // AppArmor.g:134:7: 'tcp'
    {
        MATCHS(lit_50); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT82Ex; /* Prevent compiler warnings */
    ruleT82Ex: ;

}
// $ANTLR end T82

//   Comes from: 135:5: ( 'udp' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T83
 *
 * Looks to match the characters the constitute the token T83
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT83(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T83;
       
    
    // AppArmor.g:135:5: ( 'udp' )
    // AppArmor.g:135:7: 'udp'
    {
        MATCHS(lit_51); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT83Ex; /* Prevent compiler warnings */
    ruleT83Ex: ;

}
// $ANTLR end T83

//   Comes from: 136:5: ( 'ipx' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T84
 *
 * Looks to match the characters the constitute the token T84
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT84(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T84;
       
    
    // AppArmor.g:136:5: ( 'ipx' )
    // AppArmor.g:136:7: 'ipx'
    {
        MATCHS(lit_52); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT84Ex; /* Prevent compiler warnings */
    ruleT84Ex: ;

}
// $ANTLR end T84

//   Comes from: 137:5: ( 'appletalk' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T85
 *
 * Looks to match the characters the constitute the token T85
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT85(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T85;
       
    
    // AppArmor.g:137:5: ( 'appletalk' )
    // AppArmor.g:137:7: 'appletalk'
    {
        MATCHS(lit_53); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT85Ex; /* Prevent compiler warnings */
    ruleT85Ex: ;

}
// $ANTLR end T85

//   Comes from: 138:5: ( 'sctp' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T86
 *
 * Looks to match the characters the constitute the token T86
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT86(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T86;
       
    
    // AppArmor.g:138:5: ( 'sctp' )
    // AppArmor.g:138:7: 'sctp'
    {
        MATCHS(lit_54); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT86Ex; /* Prevent compiler warnings */
    ruleT86Ex: ;

}
// $ANTLR end T86

//   Comes from: 139:5: ( '&' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T87
 *
 * Looks to match the characters the constitute the token T87
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT87(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T87;
       
    
    // AppArmor.g:139:5: ( '&' )
    // AppArmor.g:139:7: '&'
    {
        MATCHC('&'); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT87Ex; /* Prevent compiler warnings */
    ruleT87Ex: ;

}
// $ANTLR end T87

//   Comes from: 140:5: ( 'connect' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T88
 *
 * Looks to match the characters the constitute the token T88
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT88(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T88;
       
    
    // AppArmor.g:140:5: ( 'connect' )
    // AppArmor.g:140:7: 'connect'
    {
        MATCHS(lit_55); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT88Ex; /* Prevent compiler warnings */
    ruleT88Ex: ;

}
// $ANTLR end T88

//   Comes from: 141:5: ( 'accept' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T89
 *
 * Looks to match the characters the constitute the token T89
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT89(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T89;
       
    
    // AppArmor.g:141:5: ( 'accept' )
    // AppArmor.g:141:7: 'accept'
    {
        MATCHS(lit_56); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT89Ex; /* Prevent compiler warnings */
    ruleT89Ex: ;

}
// $ANTLR end T89

//   Comes from: 142:5: ( 'connected' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T90
 *
 * Looks to match the characters the constitute the token T90
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT90(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T90;
       
    
    // AppArmor.g:142:5: ( 'connected' )
    // AppArmor.g:142:7: 'connected'
    {
        MATCHS(lit_57); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT90Ex; /* Prevent compiler warnings */
    ruleT90Ex: ;

}
// $ANTLR end T90

//   Comes from: 143:5: ( 'send' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T91
 *
 * Looks to match the characters the constitute the token T91
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT91(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T91;
       
    
    // AppArmor.g:143:5: ( 'send' )
    // AppArmor.g:143:7: 'send'
    {
        MATCHS(lit_58); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT91Ex; /* Prevent compiler warnings */
    ruleT91Ex: ;

}
// $ANTLR end T91

//   Comes from: 144:5: ( 'recv' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T92
 *
 * Looks to match the characters the constitute the token T92
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT92(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T92;
       
    
    // AppArmor.g:144:5: ( 'recv' )
    // AppArmor.g:144:7: 'recv'
    {
        MATCHS(lit_59); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT92Ex; /* Prevent compiler warnings */
    ruleT92Ex: ;

}
// $ANTLR end T92

//   Comes from: 145:5: ( 'to' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T93
 *
 * Looks to match the characters the constitute the token T93
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT93(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T93;
       
    
    // AppArmor.g:145:5: ( 'to' )
    // AppArmor.g:145:7: 'to'
    {
        MATCHS(lit_60); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT93Ex; /* Prevent compiler warnings */
    ruleT93Ex: ;

}
// $ANTLR end T93

//   Comes from: 146:5: ( 'from' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T94
 *
 * Looks to match the characters the constitute the token T94
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT94(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T94;
       
    
    // AppArmor.g:146:5: ( 'from' )
    // AppArmor.g:146:7: 'from'
    {
        MATCHS(lit_61); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT94Ex; /* Prevent compiler warnings */
    ruleT94Ex: ;

}
// $ANTLR end T94

//   Comes from: 147:5: ( 'endpoint' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T95
 *
 * Looks to match the characters the constitute the token T95
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT95(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T95;
       
    
    // AppArmor.g:147:5: ( 'endpoint' )
    // AppArmor.g:147:7: 'endpoint'
    {
        MATCHS(lit_62); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT95Ex; /* Prevent compiler warnings */
    ruleT95Ex: ;

}
// $ANTLR end T95

//   Comes from: 148:5: ( 'via' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T96
 *
 * Looks to match the characters the constitute the token T96
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT96(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T96;
       
    
    // AppArmor.g:148:5: ( 'via' )
    // AppArmor.g:148:7: 'via'
    {
        MATCHS(lit_63); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT96Ex; /* Prevent compiler warnings */
    ruleT96Ex: ;

}
// $ANTLR end T96

//   Comes from: 149:5: ( 'limit' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T97
 *
 * Looks to match the characters the constitute the token T97
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT97(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T97;
       
    
    // AppArmor.g:149:5: ( 'limit' )
    // AppArmor.g:149:7: 'limit'
    {
        MATCHS(lit_64); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT97Ex; /* Prevent compiler warnings */
    ruleT97Ex: ;

}
// $ANTLR end T97

//   Comes from: 1319:2: ( ( '\\r\\n' | '\\r' | '\\n' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NEWLINE
 *
 * Looks to match the characters the constitute the token NEWLINE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNEWLINE(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = NEWLINE;
       
    
    // AppArmor.g:1319:2: ( ( '\\r\\n' | '\\r' | '\\n' ) )
    // AppArmor.g:1319:3: ( '\\r\\n' | '\\r' | '\\n' )
    {

        // AppArmor.g:1319:3: ( '\\r\\n' | '\\r' | '\\n' )
        {
            int alt1=3;

            {
                int LA1_0 = LA(1);
                if ( (LA1_0 == '\r') ) 
                {

                    {
                        int LA1_1 = LA(2);
                        if ( (LA1_1 == '\n') ) 
                        {
                            alt1=1;
                        }
                        else 
                        {
                            alt1=2;    }
                    }
                }
                else if ( (LA1_0 == '\n') ) 
                {
                    alt1=3;
                }
                else 
                {
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE; 
                        return ;
                    }
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = "1319:3: ( '\\r\\n' | '\\r' | '\\n' )";
                    EXCEPTION->decisionNum  = 1;
                    EXCEPTION->state        = 0;

                
                    goto ruleNEWLINEEx;
                }
            }
            switch (alt1) 
            {
        	case 1:
        	    // AppArmor.g:1319:4: '\\r\\n'
        	    {
        	        MATCHS(lit_65); 
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // AppArmor.g:1320:12: '\\r'
        	    {
        	        MATCHC('\r'); 
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 3:
        	    // AppArmor.g:1321:12: '\\n'
        	    {
        	        MATCHC('\n'); 
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
        if ( BACKTRACKING == 0 ) 
        {

            	  	if (((inVariable == 1) && (equalSign == 1)) 
            		   || (startOfLine == 0))
            		{
            		  	_type = NEWLINE;
            		}
            		else
            		{
            			LEXER->channel = HIDDEN;
            		}
            		startOfLine = 0;
            		equalSign = 0;
            		inVariable = 0;
            	  
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleNEWLINEEx; /* Prevent compiler warnings */
    ruleNEWLINEEx: ;

    if ( BACKTRACKING == 0 ) 
    {

        		
        		if (inInclude == 1)
        		{
        		/* Load the new input stream  */
        			inInclude = 0;
        			startOfLine = 0;
        			equalSign = 0;
        			inVariable = 0;
        			
        			int lexerLen = strlen(lexerIncludeFile);
        			int dirLen = strlen(AA_PROFILE_DIR);
        			char *tmp = (char *) malloc (lexerLen + dirLen + 1);
        			snprintf(tmp, lexerLen + dirLen + 1, 
        				"%s%s", AA_PROFILE_DIR, lexerIncludeFile);
        			free(lexerIncludeFile);
        			lexerIncludeFile = tmp;
        			
        			LEXER->channel = HIDDEN;
        			if (access(tmp, R_OK) != 0)
        			{
        				printf("Exception\n");
        				CONSTRUCTEX();
        				EXCEPTION->type = 33;
        				EXCEPTION->name = "Invalid Include";
        				EXCEPTION->message = tmp;
        				//free(tmp);
        				goto ruleNEWLINEEx;
        			}
        			
        			pANTLR3_INPUT_STREAM input;
        			input = antlr3AsciiFileStreamNew((pANTLR3_UINT8) tmp);
        			free(tmp);
        			streamVector->add(streamVector, input, NULL);
        			PUSHSTREAM(input);
        			
        		}
        	
    }
}
// $ANTLR end NEWLINE

//   Comes from: 1339:11: ( '<' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LESS_THAN
 *
 * Looks to match the characters the constitute the token LESS_THAN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLESS_THAN(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = LESS_THAN;
       
    
    // AppArmor.g:1339:11: ( '<' )
    // AppArmor.g:1339:13: '<'
    {
        if ( BACKTRACKING == 0 ) 
        {
             startOfLine = 1; 
        }
        MATCHC('<'); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleLESS_THANEx; /* Prevent compiler warnings */
    ruleLESS_THANEx: ;

}
// $ANTLR end LESS_THAN

//   Comes from: 1340:14: ( '>' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start GREATER_THAN
 *
 * Looks to match the characters the constitute the token GREATER_THAN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mGREATER_THAN(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = GREATER_THAN;
       
    
    // AppArmor.g:1340:14: ( '>' )
    // AppArmor.g:1340:16: '>'
    {
        if ( BACKTRACKING == 0 ) 
        {
             startOfLine = 1; 
        }
        MATCHC('>'); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleGREATER_THANEx; /* Prevent compiler warnings */
    ruleGREATER_THANEx: ;

}
// $ANTLR end GREATER_THAN

//   Comes from: 1341:12: ( '{' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LEFT_BRACE
 *
 * Looks to match the characters the constitute the token LEFT_BRACE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLEFT_BRACE(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = LEFT_BRACE;
       
    
    // AppArmor.g:1341:12: ( '{' )
    // AppArmor.g:1341:14: '{'
    {
        if ( BACKTRACKING == 0 ) 
        {
             startOfLine = 1; 
        }
        MATCHC('{'); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleLEFT_BRACEEx; /* Prevent compiler warnings */
    ruleLEFT_BRACEEx: ;

}
// $ANTLR end LEFT_BRACE

//   Comes from: 1342:13: ( '}' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RIGHT_BRACE
 *
 * Looks to match the characters the constitute the token RIGHT_BRACE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mRIGHT_BRACE(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = RIGHT_BRACE;
       
    
    // AppArmor.g:1342:13: ( '}' )
    // AppArmor.g:1342:15: '}'
    {
        if ( BACKTRACKING == 0 ) 
        {
             startOfLine = 1; 
        }
        MATCHC('}'); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleRIGHT_BRACEEx; /* Prevent compiler warnings */
    ruleRIGHT_BRACEEx: ;

}
// $ANTLR end RIGHT_BRACE

//   Comes from: 1343:5: ( '@' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start AT
 *
 * Looks to match the characters the constitute the token AT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mAT(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = AT;
       
    
    // AppArmor.g:1343:5: ( '@' )
    // AppArmor.g:1343:7: '@'
    {
        if ( BACKTRACKING == 0 ) 
        {
             startOfLine = 1; 
        }
        MATCHC('@'); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleATEx; /* Prevent compiler warnings */
    ruleATEx: ;

}
// $ANTLR end AT

//   Comes from: 1344:9: ( '$' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DOLLAR
 *
 * Looks to match the characters the constitute the token DOLLAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDOLLAR(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = DOLLAR;
       
    
    // AppArmor.g:1344:9: ( '$' )
    // AppArmor.g:1344:11: '$'
    {
        if ( BACKTRACKING == 0 ) 
        {
             startOfLine = 1; 
        }
        MATCHC('$'); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleDOLLAREx; /* Prevent compiler warnings */
    ruleDOLLAREx: ;

}
// $ANTLR end DOLLAR

//   Comes from: 1345:12: ( '(' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LEFT_PAREN
 *
 * Looks to match the characters the constitute the token LEFT_PAREN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLEFT_PAREN(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = LEFT_PAREN;
       
    
    // AppArmor.g:1345:12: ( '(' )
    // AppArmor.g:1345:14: '('
    {
        if ( BACKTRACKING == 0 ) 
        {
             startOfLine = 1; 
        }
        MATCHC('('); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleLEFT_PARENEx; /* Prevent compiler warnings */
    ruleLEFT_PARENEx: ;

}
// $ANTLR end LEFT_PAREN

//   Comes from: 1346:13: ( ')' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RIGHT_PAREN
 *
 * Looks to match the characters the constitute the token RIGHT_PAREN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mRIGHT_PAREN(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = RIGHT_PAREN;
       
    
    // AppArmor.g:1346:13: ( ')' )
    // AppArmor.g:1346:15: ')'
    {
        if ( BACKTRACKING == 0 ) 
        {
             startOfLine = 1; 
        }
        MATCHC(')'); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleRIGHT_PARENEx; /* Prevent compiler warnings */
    ruleRIGHT_PARENEx: ;

}
// $ANTLR end RIGHT_PAREN

//   Comes from: 1347:7: ( '+' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLUS
 *
 * Looks to match the characters the constitute the token PLUS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPLUS(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = PLUS;
       
    
    // AppArmor.g:1347:7: ( '+' )
    // AppArmor.g:1347:9: '+'
    {
        MATCHC('+'); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto rulePLUSEx; /* Prevent compiler warnings */
    rulePLUSEx: ;

}
// $ANTLR end PLUS

//   Comes from: 1348:9: ( '=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EQUALS
 *
 * Looks to match the characters the constitute the token EQUALS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEQUALS(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = EQUALS;
       
    
    // AppArmor.g:1348:9: ( '=' )
    // AppArmor.g:1348:11: '='
    {
        if ( BACKTRACKING == 0 ) 
        {
             equalSign = 1; 
        }
        MATCHC('='); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleEQUALSEx; /* Prevent compiler warnings */
    ruleEQUALSEx: ;

}
// $ANTLR end EQUALS

//   Comes from: 1352:2: ( '#' ( ( ( 'include ' )=> 'include ' ) | COMMENT ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COMMENT_OR_INCLUDE
 *
 * Looks to match the characters the constitute the token COMMENT_OR_INCLUDE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCOMMENT_OR_INCLUDE(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = COMMENT_OR_INCLUDE;
       
    
    // AppArmor.g:1352:2: ( '#' ( ( ( 'include ' )=> 'include ' ) | COMMENT ) )
    // AppArmor.g:1352:4: '#' ( ( ( 'include ' )=> 'include ' ) | COMMENT )
    {
        MATCHC('#'); 
        if (HASFAILED())
        {
            return ;
        }

        // AppArmor.g:1353:2: ( ( ( 'include ' )=> 'include ' ) | COMMENT )
        {
            int alt2=2;

            {
                int LA2_0 = LA(1);
                if ( (LA2_0 == 'i') ) 
                {

                    {
                        int LA2_1 = LA(2);
                        if ( (LA2_1 == 'n') ) 
                        {

                            {
                                int LA2_3 = LA(3);
                                if ( (LA2_3 == 'c') ) 
                                {

                                    {
                                        int LA2_4 = LA(4);
                                        if ( (LA2_4 == 'l') ) 
                                        {

                                            {
                                                int LA2_5 = LA(5);
                                                if ( (LA2_5 == 'u') ) 
                                                {

                                                    {
                                                        int LA2_6 = LA(6);
                                                        if ( (LA2_6 == 'd') ) 
                                                        {

                                                            {
                                                                int LA2_7 = LA(7);
                                                                if ( (LA2_7 == 'e') ) 
                                                                {

                                                                    {
                                                                        int LA2_8 = LA(8);
                                                                        if ( (LA2_8 == ' ') ) 
                                                                        {

                                                                            {
                                                                                int LA2_9 = LA(9);
                                                                                if ( (synpred1(ctx)) ) 
                                                                                {
                                                                                    alt2=1;
                                                                                }
                                                                                else if ( (ANTLR3_TRUE) ) 
                                                                                {
                                                                                    alt2=2;
                                                                                }
                                                                                else 
                                                                                {
                                                                                    if (BACKTRACKING>0)
                                                                                    {
                                                                                        FAILEDFLAG = ANTLR3_TRUE; 
                                                                                        return ;
                                                                                    }
                                                                                
                                                                                    CONSTRUCTEX();
                                                                                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                                    EXCEPTION->message      = "1353:2: ( ( ( 'include ' )=> 'include ' ) | COMMENT )";
                                                                                    EXCEPTION->decisionNum  = 2;
                                                                                    EXCEPTION->state        = 9;

                                                                                
                                                                                    goto ruleCOMMENT_OR_INCLUDEEx;
                                                                                }
                                                                            }
                                                                        }
                                                                        else 
                                                                        {
                                                                            alt2=2;    }
                                                                    }
                                                                }
                                                                else 
                                                                {
                                                                    alt2=2;    }
                                                            }
                                                        }
                                                        else 
                                                        {
                                                            alt2=2;    }
                                                    }
                                                }
                                                else 
                                                {
                                                    alt2=2;    }
                                            }
                                        }
                                        else 
                                        {
                                            alt2=2;    }
                                    }
                                }
                                else 
                                {
                                    alt2=2;    }
                            }
                        }
                        else 
                        {
                            alt2=2;    }
                    }
                }
                else 
                {
                    alt2=2;    }
            }
            switch (alt2) 
            {
        	case 1:
        	    // AppArmor.g:1354:4: ( ( 'include ' )=> 'include ' )
        	    {
        	        // AppArmor.g:1354:4: ( ( 'include ' )=> 'include ' )
        	        // AppArmor.g:1354:5: ( 'include ' )=> 'include '
        	        {
        	            MATCHS(lit_66); 
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }


        	        }

        	        if ( BACKTRACKING == 0 ) 
        	        {
        	             _type=INCLUDE; inInclude = 1; 
        	        }

        	    }
        	    break;
        	case 2:
        	    // AppArmor.g:1356:4: COMMENT
        	    {
        	        /* 1356:4: COMMENT */
        	        mCOMMENT(ctx ); 
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING == 0 ) 
        	        {

        	            			if (startOfLine == 1)
        	            			{
        	            				_type=EOL_COMMENT;
        	            			}
        	            			else
        	            			{
        	            				startOfLine = 1;
        	            				_type=SOL_COMMENT;
        	            			}
        	            		
        	        }

        	    }
        	    break;

            }
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleCOMMENT_OR_INCLUDEEx; /* Prevent compiler warnings */
    ruleCOMMENT_OR_INCLUDEEx: ;

}
// $ANTLR end COMMENT_OR_INCLUDE

//   Comes from: 1372:2: ( 'include' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start INCLUDE
 *
 * Looks to match the characters the constitute the token INCLUDE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mINCLUDE(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = INCLUDE;
       
    
    // AppArmor.g:1372:2: ( 'include' )
    // AppArmor.g:1372:4: 'include'
    {
        MATCHS(lit_67); 
        if (HASFAILED())
        {
            return ;
        }

        if ( BACKTRACKING == 0 ) 
        {
             _type=INCLUDE; inInclude = 1;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleINCLUDEEx; /* Prevent compiler warnings */
    ruleINCLUDEEx: ;

}
// $ANTLR end INCLUDE

//   Comes from: 1381:13: ( '#' COMMENT )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SOL_COMMENT
 *
 * Looks to match the characters the constitute the token SOL_COMMENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSOL_COMMENT(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // AppArmor.g:1381:13: ( '#' COMMENT )
    // AppArmor.g:1381:15: '#' COMMENT
    {
        MATCHC('#'); 
        if (HASFAILED())
        {
            return ;
        }
        /* 1381:15: '#' COMMENT */
        mCOMMENT(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleSOL_COMMENTEx; /* Prevent compiler warnings */
    ruleSOL_COMMENTEx: ;

}
// $ANTLR end SOL_COMMENT

//   Comes from: 1385:13: ( '#' COMMENT )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EOL_COMMENT
 *
 * Looks to match the characters the constitute the token EOL_COMMENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEOL_COMMENT(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // AppArmor.g:1385:13: ( '#' COMMENT )
    // AppArmor.g:1385:15: '#' COMMENT
    {
        MATCHC('#'); 
        if (HASFAILED())
        {
            return ;
        }
        /* 1385:15: '#' COMMENT */
        mCOMMENT(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleEOL_COMMENTEx; /* Prevent compiler warnings */
    ruleEOL_COMMENTEx: ;

}
// $ANTLR end EOL_COMMENT

//   Comes from: 1393:2: ( (~ ( '\\n' | '\\r' ) )* )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COMMENT
 *
 * Looks to match the characters the constitute the token COMMENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCOMMENT(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // AppArmor.g:1393:2: ( (~ ( '\\n' | '\\r' ) )* )
    // AppArmor.g:1393:4: (~ ( '\\n' | '\\r' ) )*
    {

        // AppArmor.g:1393:4: (~ ( '\\n' | '\\r' ) )*

        for (;;)
        {
            int alt3=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA3_0 = LA(1);
                if ( (((LA3_0 >= 0x0000) && (LA3_0 <= '\t')) || ((LA3_0 >= 0x000B) && (LA3_0 <= '\f')) || ((LA3_0 >= 0x000E) && (LA3_0 <= 0xFFFE))) ) 
                {
                    alt3=1;
                }

            }
            switch (alt3) 
            {
        	case 1:
        	    // AppArmor.g:1393:5: ~ ( '\\n' | '\\r' )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '\t')) || ((LA(1) >= 0x000B) && (LA(1) <= '\f')) || ((LA(1) >= 0x000E) && (LA(1) <= 0xFFFE)) )
        	        {
        	            CONSUME();
        	        FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else 
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE; 
        	                return ;
        	            }
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleCOMMENTEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop3;	/* break out of the loop */
        	    break;
            }
        }
        loop3: ; /* Jump out to here if this rule does not match */


    }



    // This is where rules clean up and exit
    //
    goto ruleCOMMENTEx; /* Prevent compiler warnings */
    ruleCOMMENTEx: ;

}
// $ANTLR end COMMENT

//   Comes from: 1398:2: ( (~ '\"' )* )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ANYTHING_NOT_QUOTED
 *
 * Looks to match the characters the constitute the token ANYTHING_NOT_QUOTED
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mANYTHING_NOT_QUOTED(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // AppArmor.g:1398:2: ( (~ '\"' )* )
    // AppArmor.g:1398:4: (~ '\"' )*
    {

        // AppArmor.g:1398:4: (~ '\"' )*

        for (;;)
        {
            int alt4=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA4_0 = LA(1);
                if ( (((LA4_0 >= 0x0000) && (LA4_0 <= '!')) || ((LA4_0 >= '#') && (LA4_0 <= 0xFFFE))) ) 
                {
                    alt4=1;
                }

            }
            switch (alt4) 
            {
        	case 1:
        	    // AppArmor.g:1398:5: ~ '\"'
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '!')) || ((LA(1) >= '#') && (LA(1) <= 0xFFFE)) )
        	        {
        	            CONSUME();
        	        FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else 
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE; 
        	                return ;
        	            }
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleANYTHING_NOT_QUOTEDEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop4;	/* break out of the loop */
        	    break;
            }
        }
        loop4: ; /* Jump out to here if this rule does not match */


    }



    // This is where rules clean up and exit
    //
    goto ruleANYTHING_NOT_QUOTEDEx; /* Prevent compiler warnings */
    ruleANYTHING_NOT_QUOTEDEx: ;

}
// $ANTLR end ANYTHING_NOT_QUOTED

//   Comes from: 1402:2: ( '\"' f= ANYTHING_NOT_QUOTED '\"' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QUOTED_STRING
 *
 * Looks to match the characters the constitute the token QUOTED_STRING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mQUOTED_STRING(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;
    pANTLR3_COMMON_TOKEN f;


   
    f = NULL;

    _type	    = QUOTED_STRING;
       
    
    // AppArmor.g:1402:2: ( '\"' f= ANYTHING_NOT_QUOTED '\"' )
    // AppArmor.g:1402:4: '\"' f= ANYTHING_NOT_QUOTED '\"'
    {
        MATCHC('"'); 
        if (HASFAILED())
        {
            return ;
        }
        /* 1402:4: '\"' f= ANYTHING_NOT_QUOTED '\"' */
        {
            ANTLR3_UINT64 fStart878 = GETCHARINDEX();
            mANYTHING_NOT_QUOTED(ctx ); 
            if (HASFAILED())
            {
                return ;
            }
            f = LEXER->tokFactory->newToken(LEXER->tokFactory);
            f->setType(f, ANTLR3_TOKEN_INVALID);
            f->setStartIndex(f, fStart878);
            f->setStopIndex(f, GETCHARINDEX()-1);
            f->input = INPUT;
        }
        MATCHC('"'); 
        if (HASFAILED())
        {
            return ;
        }
        if ( BACKTRACKING == 0 ) 
        {

            		_type = QUOTED_STRING;
            		/* If it's an include file, save the token text for NEWLINE */
            		if (inInclude == 1)
            			lexerIncludeFile=strdup((char *) f->getText(f)->chars);
            		startOfLine = 1;
            	
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleQUOTED_STRINGEx; /* Prevent compiler warnings */
    ruleQUOTED_STRINGEx: ;

    f = NULL;

}
// $ANTLR end QUOTED_STRING

//   Comes from: 1414:2: ( '/' ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '*' | '[' | ']' | '0' .. '9' | '-' | '.' | '/' | '\\u0080' .. '\\u00ff' )* )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PATH
 *
 * Looks to match the characters the constitute the token PATH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPATH(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // AppArmor.g:1414:2: ( '/' ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '*' | '[' | ']' | '0' .. '9' | '-' | '.' | '/' | '\\u0080' .. '\\u00ff' )* )
    // AppArmor.g:1414:4: '/' ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '*' | '[' | ']' | '0' .. '9' | '-' | '.' | '/' | '\\u0080' .. '\\u00ff' )*
    {
        MATCHC('/'); 
        if (HASFAILED())
        {
            return ;
        }

        // AppArmor.g:1414:8: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '*' | '[' | ']' | '0' .. '9' | '-' | '.' | '/' | '\\u0080' .. '\\u00ff' )*

        for (;;)
        {
            int alt5=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA5_0 = LA(1);
                if ( (LA5_0 == '*' || ((LA5_0 >= '-') && (LA5_0 <= '9')) || ((LA5_0 >= 'A') && (LA5_0 <= '[')) || LA5_0 == ']' || LA5_0 == '_' || ((LA5_0 >= 'a') && (LA5_0 <= 'z')) || ((LA5_0 >= 0x0080) && (LA5_0 <= 0x00FF))) ) 
                {
                    alt5=1;
                }

            }
            switch (alt5) 
            {
        	case 1:
        	    // AppArmor.g:
        	    {
        	        if ( LA(1) == '*' || ((LA(1) >= '-') && (LA(1) <= '9')) || ((LA(1) >= 'A') && (LA(1) <= '[')) || LA(1) == ']' || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) || ((LA(1) >= 0x0080) && (LA(1) <= 0x00FF)) )
        	        {
        	            CONSUME();
        	        FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else 
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE; 
        	                return ;
        	            }
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto rulePATHEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop5;	/* break out of the loop */
        	    break;
            }
        }
        loop5: ; /* Jump out to here if this rule does not match */

        if ( BACKTRACKING == 0 ) 
        {
             startOfLine = 1; 
        }

    }



    // This is where rules clean up and exit
    //
    goto rulePATHEx; /* Prevent compiler warnings */
    rulePATHEx: ;

}
// $ANTLR end PATH

//   Comes from: 1420:2: (p= PATH )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UNQUOTED_PATH
 *
 * Looks to match the characters the constitute the token UNQUOTED_PATH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mUNQUOTED_PATH(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;
    pANTLR3_COMMON_TOKEN p;


   
    p = NULL;

    _type	    = UNQUOTED_PATH;
       
    
    // AppArmor.g:1420:2: (p= PATH )
    // AppArmor.g:1420:4: p= PATH
    {
        /* 1420:4: p= PATH */
        {
            ANTLR3_UINT64 pStart956 = GETCHARINDEX();
            mPATH(ctx ); 
            if (HASFAILED())
            {
                return ;
            }
            p = LEXER->tokFactory->newToken(LEXER->tokFactory);
            p->setType(p, ANTLR3_TOKEN_INVALID);
            p->setStartIndex(p, pStart956);
            p->setStopIndex(p, GETCHARINDEX()-1);
            p->input = INPUT;
        }
        if ( BACKTRACKING == 0 ) 
        {

            		if (inInclude == 1)
            			lexerIncludeFile=strdup((char *) p->getText(p)->chars);	
            	
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleUNQUOTED_PATHEx; /* Prevent compiler warnings */
    ruleUNQUOTED_PATHEx: ;

    p = NULL;

}
// $ANTLR end UNQUOTED_PATH

//   Comes from: 1434:2: ( '@' '{' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LIST_VAR_START
 *
 * Looks to match the characters the constitute the token LIST_VAR_START
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLIST_VAR_START(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = LIST_VAR_START;
       
    
    // AppArmor.g:1434:2: ( '@' '{' )
    // AppArmor.g:1434:4: '@' '{'
    {
        MATCHC('@'); 
        if (HASFAILED())
        {
            return ;
        }
        MATCHC('{'); 
        if (HASFAILED())
        {
            return ;
        }
        if ( BACKTRACKING == 0 ) 
        {
             startOfLine = 1; inVariable = 1; 
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleLIST_VAR_STARTEx; /* Prevent compiler warnings */
    ruleLIST_VAR_STARTEx: ;

}
// $ANTLR end LIST_VAR_START

//   Comes from: 1439:2: ( '$' '{' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BOOL_VAR_START
 *
 * Looks to match the characters the constitute the token BOOL_VAR_START
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBOOL_VAR_START(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = BOOL_VAR_START;
       
    
    // AppArmor.g:1439:2: ( '$' '{' )
    // AppArmor.g:1439:4: '$' '{'
    {
        MATCHC('$'); 
        if (HASFAILED())
        {
            return ;
        }
        MATCHC('{'); 
        if (HASFAILED())
        {
            return ;
        }
        if ( BACKTRACKING == 0 ) 
        {
             startOfLine = 1; inVariable = 1; 
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleBOOL_VAR_STARTEx; /* Prevent compiler warnings */
    ruleBOOL_VAR_STARTEx: ;

}
// $ANTLR end BOOL_VAR_START

//   Comes from: 1444:2: ( ( 'r' | 'w' | 'l' | 'm' | 'k' | 'a' | 'i' 'x' | 'p' 'x' | 'u' 'x' | 'P' 'x' | 'U' 'x' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RULE
 *
 * Looks to match the characters the constitute the token RULE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mRULE(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = RULE;
       
    
    // AppArmor.g:1444:2: ( ( 'r' | 'w' | 'l' | 'm' | 'k' | 'a' | 'i' 'x' | 'p' 'x' | 'u' 'x' | 'P' 'x' | 'U' 'x' )+ )
    // AppArmor.g:1444:5: ( 'r' | 'w' | 'l' | 'm' | 'k' | 'a' | 'i' 'x' | 'p' 'x' | 'u' 'x' | 'P' 'x' | 'U' 'x' )+
    {
        // AppArmor.g:1444:5: ( 'r' | 'w' | 'l' | 'm' | 'k' | 'a' | 'i' 'x' | 'p' 'x' | 'u' 'x' | 'P' 'x' | 'U' 'x' )+
        {
            int cnt6=0;

            for (;;)
            {
                int alt6=12;
        	switch ( LA(1) ) 
        	{
        	case 'r':
        		{
        			alt6=1;
        		}
        	    break;
        	case 'w':
        		{
        			alt6=2;
        		}
        	    break;
        	case 'l':
        		{
        			alt6=3;
        		}
        	    break;
        	case 'm':
        		{
        			alt6=4;
        		}
        	    break;
        	case 'k':
        		{
        			alt6=5;
        		}
        	    break;
        	case 'a':
        		{
        			alt6=6;
        		}
        	    break;
        	case 'i':
        		{
        			alt6=7;
        		}
        	    break;
        	case 'p':
        		{
        			alt6=8;
        		}
        	    break;
        	case 'u':
        		{
        			alt6=9;
        		}
        	    break;
        	case 'P':
        		{
        			alt6=10;
        		}
        	    break;
        	case 'U':
        		{
        			alt6=11;
        		}
        	    break;

        	}

        	switch (alt6) 
        	{
        	    case 1:
        	        // AppArmor.g:1444:6: 'r'
        	        {
        	            MATCHC('r'); 
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }
        	        break;
        	    case 2:
        	        // AppArmor.g:1445:4: 'w'
        	        {
        	            MATCHC('w'); 
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }
        	        break;
        	    case 3:
        	        // AppArmor.g:1446:4: 'l'
        	        {
        	            MATCHC('l'); 
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }
        	        break;
        	    case 4:
        	        // AppArmor.g:1447:4: 'm'
        	        {
        	            MATCHC('m'); 
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }
        	        break;
        	    case 5:
        	        // AppArmor.g:1448:4: 'k'
        	        {
        	            MATCHC('k'); 
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }
        	        break;
        	    case 6:
        	        // AppArmor.g:1449:4: 'a'
        	        {
        	            MATCHC('a'); 
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }
        	        break;
        	    case 7:
        	        // AppArmor.g:1450:4: 'i' 'x'
        	        {
        	            MATCHC('i'); 
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }
        	            MATCHC('x'); 
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }
        	        break;
        	    case 8:
        	        // AppArmor.g:1451:4: 'p' 'x'
        	        {
        	            MATCHC('p'); 
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }
        	            MATCHC('x'); 
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }
        	        break;
        	    case 9:
        	        // AppArmor.g:1452:4: 'u' 'x'
        	        {
        	            MATCHC('u'); 
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }
        	            MATCHC('x'); 
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }
        	        break;
        	    case 10:
        	        // AppArmor.g:1453:4: 'P' 'x'
        	        {
        	            MATCHC('P'); 
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }
        	            MATCHC('x'); 
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }
        	        break;
        	    case 11:
        	        // AppArmor.g:1454:4: 'U' 'x'
        	        {
        	            MATCHC('U'); 
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }
        	            MATCHC('x'); 
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }
        	        break;

        	    default:
        	    
        		if ( cnt6 >= 1 )
        		{
        		    goto loop6;
        		}
        		if (BACKTRACKING>0)
        		{
        		    FAILEDFLAG = ANTLR3_TRUE; 
        		    return ;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = ANTLR3_EARLY_EXIT_NAME;


        		goto ruleRULEEx;
        	}
        	cnt6++;
            }
            loop6: ;	/* Jump to here if this rule does not match */
        }
        if ( BACKTRACKING == 0 ) 
        {
             startOfLine = 1; 
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleRULEEx; /* Prevent compiler warnings */
    ruleRULEEx: ;

}
// $ANTLR end RULE

//   Comes from: 1460:2: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' | '\\u0080' .. '\\u00ff' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start IDENT_START
 *
 * Looks to match the characters the constitute the token IDENT_START
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mIDENT_START(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // AppArmor.g:1460:2: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' | '\\u0080' .. '\\u00ff' )
    // AppArmor.g:
    {
        if ( ((LA(1) >= '0') && (LA(1) <= '9')) || ((LA(1) >= 'A') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) || ((LA(1) >= 0x0080) && (LA(1) <= 0x00FF)) )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleIDENT_STARTEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleIDENT_STARTEx; /* Prevent compiler warnings */
    ruleIDENT_STARTEx: ;

}
// $ANTLR end IDENT_START

//   Comes from: 1469:2: ( IDENT_START | '*' | '.' | '-' | ':' | '/' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start IDENT_CONTINUE
 *
 * Looks to match the characters the constitute the token IDENT_CONTINUE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mIDENT_CONTINUE(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // AppArmor.g:1469:2: ( IDENT_START | '*' | '.' | '-' | ':' | '/' )
    // AppArmor.g:
    {
        if ( LA(1) == '*' || ((LA(1) >= '-') && (LA(1) <= ':')) || ((LA(1) >= 'A') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) || ((LA(1) >= 0x0080) && (LA(1) <= 0x00FF)) )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleIDENT_CONTINUEEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleIDENT_CONTINUEEx; /* Prevent compiler warnings */
    ruleIDENT_CONTINUEEx: ;

}
// $ANTLR end IDENT_CONTINUE

//   Comes from: 1479:2: ( IDENT_START ( IDENT_CONTINUE )* )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start REAL_IDENT
 *
 * Looks to match the characters the constitute the token REAL_IDENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mREAL_IDENT(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // AppArmor.g:1479:2: ( IDENT_START ( IDENT_CONTINUE )* )
    // AppArmor.g:1479:4: IDENT_START ( IDENT_CONTINUE )*
    {
        /* 1479:4: IDENT_START ( IDENT_CONTINUE )* */
        mIDENT_START(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

        // AppArmor.g:1479:16: ( IDENT_CONTINUE )*

        for (;;)
        {
            int alt7=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA7_0 = LA(1);
                if ( (LA7_0 == '*' || ((LA7_0 >= '-') && (LA7_0 <= ':')) || ((LA7_0 >= 'A') && (LA7_0 <= 'Z')) || LA7_0 == '_' || ((LA7_0 >= 'a') && (LA7_0 <= 'z')) || ((LA7_0 >= 0x0080) && (LA7_0 <= 0x00FF))) ) 
                {
                    alt7=1;
                }

            }
            switch (alt7) 
            {
        	case 1:
        	    // AppArmor.g:1479:18: IDENT_CONTINUE
        	    {
        	        /* 1479:18: IDENT_CONTINUE */
        	        mIDENT_CONTINUE(ctx ); 
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

        	default:
        	    goto loop7;	/* break out of the loop */
        	    break;
            }
        }
        loop7: ; /* Jump out to here if this rule does not match */


    }



    // This is where rules clean up and exit
    //
    goto ruleREAL_IDENTEx; /* Prevent compiler warnings */
    ruleREAL_IDENTEx: ;

}
// $ANTLR end REAL_IDENT

//   Comes from: 1482:2: (f= REAL_IDENT )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start IDENT
 *
 * Looks to match the characters the constitute the token IDENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mIDENT(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;
    pANTLR3_COMMON_TOKEN f;


   
    f = NULL;

    _type	    = IDENT;
       
    
    // AppArmor.g:1482:2: (f= REAL_IDENT )
    // AppArmor.g:1482:4: f= REAL_IDENT
    {
        /* 1482:4: f= REAL_IDENT */
        {
            ANTLR3_UINT64 fStart1190 = GETCHARINDEX();
            mREAL_IDENT(ctx ); 
            if (HASFAILED())
            {
                return ;
            }
            f = LEXER->tokFactory->newToken(LEXER->tokFactory);
            f->setType(f, ANTLR3_TOKEN_INVALID);
            f->setStartIndex(f, fStart1190);
            f->setStopIndex(f, GETCHARINDEX()-1);
            f->input = INPUT;
        }
        if ( BACKTRACKING == 0 ) 
        {

            		if (inInclude == 1)
            			lexerIncludeFile=strdup((char *) f->getText(f)->chars);
            		startOfLine = 1;
            		_type = IDENT; 
            	
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleIDENTEx; /* Prevent compiler warnings */
    ruleIDENTEx: ;

    f = NULL;

}
// $ANTLR end IDENT

//   Comes from: 1492:3: ( ( ' ' | '\\t' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WS
 *
 * Looks to match the characters the constitute the token WS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mWS(pAppArmorLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = WS;
       
    
    // AppArmor.g:1492:3: ( ( ' ' | '\\t' )+ )
    // AppArmor.g:1492:5: ( ' ' | '\\t' )+
    {
        // AppArmor.g:1492:5: ( ' ' | '\\t' )+
        {
            int cnt8=0;

            for (;;)
            {
                int alt8=2;
        	{
        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	    */
        	    int LA8_0 = LA(1);
        	    if ( (LA8_0 == '\t' || LA8_0 == ' ') ) 
        	    {
        	        alt8=1;
        	    }

        	}
        	switch (alt8) 
        	{
        	    case 1:
        	        // AppArmor.g:
        	        {
        	            if ( LA(1) == '\t' || LA(1) == ' ' )
        	            {
        	                CONSUME();
        	            FAILEDFLAG=ANTLR3_FALSE;

        	            }
        	            else 
        	            {
        	                if (BACKTRACKING>0)
        	                {
        	                    FAILEDFLAG = ANTLR3_TRUE; 
        	                    return ;
        	                }
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	                EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

        	                LRECOVER();    goto ruleWSEx;
        	            }


        	        }
        	        break;

        	    default:
        	    
        		if ( cnt8 >= 1 )
        		{
        		    goto loop8;
        		}
        		if (BACKTRACKING>0)
        		{
        		    FAILEDFLAG = ANTLR3_TRUE; 
        		    return ;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = ANTLR3_EARLY_EXIT_NAME;


        		goto ruleWSEx;
        	}
        	cnt8++;
            }
            loop8: ;	/* Jump to here if this rule does not match */
        }
        if ( BACKTRACKING == 0 ) 
        {
             LEXER->channel = HIDDEN; 
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleWSEx; /* Prevent compiler warnings */
    ruleWSEx: ;

}
// $ANTLR end WS

/** This is the entry point in to the lexer from an object that
 *  wants to generate the next token, such as a pCOMMON_TOKEN_STREAM
 */
static void 
mTokens(pAppArmorLexer ctx)
{
    {
        //  AppArmor.g:1:8: ( T32 | T33 | T34 | T35 | T36 | T37 | T38 | T39 | T40 | T41 | T42 | T43 | T44 | T45 | T46 | T47 | T48 | T49 | T50 | T51 | T52 | T53 | T54 | T55 | T56 | T57 | T58 | T59 | T60 | T61 | T62 | T63 | T64 | T65 | T66 | T67 | T68 | T69 | T70 | T71 | T72 | T73 | T74 | T75 | T76 | T77 | T78 | T79 | T80 | T81 | T82 | T83 | T84 | T85 | T86 | T87 | T88 | T89 | T90 | T91 | T92 | T93 | T94 | T95 | T96 | T97 | NEWLINE | LESS_THAN | GREATER_THAN | LEFT_BRACE | RIGHT_BRACE | AT | DOLLAR | LEFT_PAREN | RIGHT_PAREN | PLUS | EQUALS | COMMENT_OR_INCLUDE | INCLUDE | QUOTED_STRING | UNQUOTED_PATH | LIST_VAR_START | BOOL_VAR_START | RULE | IDENT | WS )
        
        ANTLR3_UINT32 alt9;

        alt9=86;

        alt9 = cdfa9.predict(ctx, RECOGNIZER, INPUT->istream, &cdfa9);
        switch (alt9) 
        {
    	case 1:
    	    // AppArmor.g:1:10: T32
    	    {
    	        /* 1:10: T32 */
    	        mT32(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 2:
    	    // AppArmor.g:1:14: T33
    	    {
    	        /* 1:14: T33 */
    	        mT33(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 3:
    	    // AppArmor.g:1:18: T34
    	    {
    	        /* 1:18: T34 */
    	        mT34(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 4:
    	    // AppArmor.g:1:22: T35
    	    {
    	        /* 1:22: T35 */
    	        mT35(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 5:
    	    // AppArmor.g:1:26: T36
    	    {
    	        /* 1:26: T36 */
    	        mT36(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 6:
    	    // AppArmor.g:1:30: T37
    	    {
    	        /* 1:30: T37 */
    	        mT37(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 7:
    	    // AppArmor.g:1:34: T38
    	    {
    	        /* 1:34: T38 */
    	        mT38(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 8:
    	    // AppArmor.g:1:38: T39
    	    {
    	        /* 1:38: T39 */
    	        mT39(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 9:
    	    // AppArmor.g:1:42: T40
    	    {
    	        /* 1:42: T40 */
    	        mT40(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 10:
    	    // AppArmor.g:1:46: T41
    	    {
    	        /* 1:46: T41 */
    	        mT41(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 11:
    	    // AppArmor.g:1:50: T42
    	    {
    	        /* 1:50: T42 */
    	        mT42(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 12:
    	    // AppArmor.g:1:54: T43
    	    {
    	        /* 1:54: T43 */
    	        mT43(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 13:
    	    // AppArmor.g:1:58: T44
    	    {
    	        /* 1:58: T44 */
    	        mT44(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 14:
    	    // AppArmor.g:1:62: T45
    	    {
    	        /* 1:62: T45 */
    	        mT45(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 15:
    	    // AppArmor.g:1:66: T46
    	    {
    	        /* 1:66: T46 */
    	        mT46(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 16:
    	    // AppArmor.g:1:70: T47
    	    {
    	        /* 1:70: T47 */
    	        mT47(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 17:
    	    // AppArmor.g:1:74: T48
    	    {
    	        /* 1:74: T48 */
    	        mT48(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 18:
    	    // AppArmor.g:1:78: T49
    	    {
    	        /* 1:78: T49 */
    	        mT49(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 19:
    	    // AppArmor.g:1:82: T50
    	    {
    	        /* 1:82: T50 */
    	        mT50(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 20:
    	    // AppArmor.g:1:86: T51
    	    {
    	        /* 1:86: T51 */
    	        mT51(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 21:
    	    // AppArmor.g:1:90: T52
    	    {
    	        /* 1:90: T52 */
    	        mT52(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 22:
    	    // AppArmor.g:1:94: T53
    	    {
    	        /* 1:94: T53 */
    	        mT53(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 23:
    	    // AppArmor.g:1:98: T54
    	    {
    	        /* 1:98: T54 */
    	        mT54(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 24:
    	    // AppArmor.g:1:102: T55
    	    {
    	        /* 1:102: T55 */
    	        mT55(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 25:
    	    // AppArmor.g:1:106: T56
    	    {
    	        /* 1:106: T56 */
    	        mT56(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 26:
    	    // AppArmor.g:1:110: T57
    	    {
    	        /* 1:110: T57 */
    	        mT57(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 27:
    	    // AppArmor.g:1:114: T58
    	    {
    	        /* 1:114: T58 */
    	        mT58(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 28:
    	    // AppArmor.g:1:118: T59
    	    {
    	        /* 1:118: T59 */
    	        mT59(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 29:
    	    // AppArmor.g:1:122: T60
    	    {
    	        /* 1:122: T60 */
    	        mT60(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 30:
    	    // AppArmor.g:1:126: T61
    	    {
    	        /* 1:126: T61 */
    	        mT61(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 31:
    	    // AppArmor.g:1:130: T62
    	    {
    	        /* 1:130: T62 */
    	        mT62(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 32:
    	    // AppArmor.g:1:134: T63
    	    {
    	        /* 1:134: T63 */
    	        mT63(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 33:
    	    // AppArmor.g:1:138: T64
    	    {
    	        /* 1:138: T64 */
    	        mT64(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 34:
    	    // AppArmor.g:1:142: T65
    	    {
    	        /* 1:142: T65 */
    	        mT65(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 35:
    	    // AppArmor.g:1:146: T66
    	    {
    	        /* 1:146: T66 */
    	        mT66(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 36:
    	    // AppArmor.g:1:150: T67
    	    {
    	        /* 1:150: T67 */
    	        mT67(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 37:
    	    // AppArmor.g:1:154: T68
    	    {
    	        /* 1:154: T68 */
    	        mT68(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 38:
    	    // AppArmor.g:1:158: T69
    	    {
    	        /* 1:158: T69 */
    	        mT69(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 39:
    	    // AppArmor.g:1:162: T70
    	    {
    	        /* 1:162: T70 */
    	        mT70(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 40:
    	    // AppArmor.g:1:166: T71
    	    {
    	        /* 1:166: T71 */
    	        mT71(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 41:
    	    // AppArmor.g:1:170: T72
    	    {
    	        /* 1:170: T72 */
    	        mT72(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 42:
    	    // AppArmor.g:1:174: T73
    	    {
    	        /* 1:174: T73 */
    	        mT73(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 43:
    	    // AppArmor.g:1:178: T74
    	    {
    	        /* 1:178: T74 */
    	        mT74(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 44:
    	    // AppArmor.g:1:182: T75
    	    {
    	        /* 1:182: T75 */
    	        mT75(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 45:
    	    // AppArmor.g:1:186: T76
    	    {
    	        /* 1:186: T76 */
    	        mT76(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 46:
    	    // AppArmor.g:1:190: T77
    	    {
    	        /* 1:190: T77 */
    	        mT77(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 47:
    	    // AppArmor.g:1:194: T78
    	    {
    	        /* 1:194: T78 */
    	        mT78(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 48:
    	    // AppArmor.g:1:198: T79
    	    {
    	        /* 1:198: T79 */
    	        mT79(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 49:
    	    // AppArmor.g:1:202: T80
    	    {
    	        /* 1:202: T80 */
    	        mT80(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 50:
    	    // AppArmor.g:1:206: T81
    	    {
    	        /* 1:206: T81 */
    	        mT81(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 51:
    	    // AppArmor.g:1:210: T82
    	    {
    	        /* 1:210: T82 */
    	        mT82(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 52:
    	    // AppArmor.g:1:214: T83
    	    {
    	        /* 1:214: T83 */
    	        mT83(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 53:
    	    // AppArmor.g:1:218: T84
    	    {
    	        /* 1:218: T84 */
    	        mT84(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 54:
    	    // AppArmor.g:1:222: T85
    	    {
    	        /* 1:222: T85 */
    	        mT85(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 55:
    	    // AppArmor.g:1:226: T86
    	    {
    	        /* 1:226: T86 */
    	        mT86(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 56:
    	    // AppArmor.g:1:230: T87
    	    {
    	        /* 1:230: T87 */
    	        mT87(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 57:
    	    // AppArmor.g:1:234: T88
    	    {
    	        /* 1:234: T88 */
    	        mT88(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 58:
    	    // AppArmor.g:1:238: T89
    	    {
    	        /* 1:238: T89 */
    	        mT89(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 59:
    	    // AppArmor.g:1:242: T90
    	    {
    	        /* 1:242: T90 */
    	        mT90(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 60:
    	    // AppArmor.g:1:246: T91
    	    {
    	        /* 1:246: T91 */
    	        mT91(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 61:
    	    // AppArmor.g:1:250: T92
    	    {
    	        /* 1:250: T92 */
    	        mT92(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 62:
    	    // AppArmor.g:1:254: T93
    	    {
    	        /* 1:254: T93 */
    	        mT93(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 63:
    	    // AppArmor.g:1:258: T94
    	    {
    	        /* 1:258: T94 */
    	        mT94(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 64:
    	    // AppArmor.g:1:262: T95
    	    {
    	        /* 1:262: T95 */
    	        mT95(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 65:
    	    // AppArmor.g:1:266: T96
    	    {
    	        /* 1:266: T96 */
    	        mT96(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 66:
    	    // AppArmor.g:1:270: T97
    	    {
    	        /* 1:270: T97 */
    	        mT97(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 67:
    	    // AppArmor.g:1:274: NEWLINE
    	    {
    	        /* 1:274: NEWLINE */
    	        mNEWLINE(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 68:
    	    // AppArmor.g:1:282: LESS_THAN
    	    {
    	        /* 1:282: LESS_THAN */
    	        mLESS_THAN(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 69:
    	    // AppArmor.g:1:292: GREATER_THAN
    	    {
    	        /* 1:292: GREATER_THAN */
    	        mGREATER_THAN(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 70:
    	    // AppArmor.g:1:305: LEFT_BRACE
    	    {
    	        /* 1:305: LEFT_BRACE */
    	        mLEFT_BRACE(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 71:
    	    // AppArmor.g:1:316: RIGHT_BRACE
    	    {
    	        /* 1:316: RIGHT_BRACE */
    	        mRIGHT_BRACE(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 72:
    	    // AppArmor.g:1:328: AT
    	    {
    	        /* 1:328: AT */
    	        mAT(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 73:
    	    // AppArmor.g:1:331: DOLLAR
    	    {
    	        /* 1:331: DOLLAR */
    	        mDOLLAR(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 74:
    	    // AppArmor.g:1:338: LEFT_PAREN
    	    {
    	        /* 1:338: LEFT_PAREN */
    	        mLEFT_PAREN(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 75:
    	    // AppArmor.g:1:349: RIGHT_PAREN
    	    {
    	        /* 1:349: RIGHT_PAREN */
    	        mRIGHT_PAREN(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 76:
    	    // AppArmor.g:1:361: PLUS
    	    {
    	        /* 1:361: PLUS */
    	        mPLUS(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 77:
    	    // AppArmor.g:1:366: EQUALS
    	    {
    	        /* 1:366: EQUALS */
    	        mEQUALS(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 78:
    	    // AppArmor.g:1:373: COMMENT_OR_INCLUDE
    	    {
    	        /* 1:373: COMMENT_OR_INCLUDE */
    	        mCOMMENT_OR_INCLUDE(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 79:
    	    // AppArmor.g:1:392: INCLUDE
    	    {
    	        /* 1:392: INCLUDE */
    	        mINCLUDE(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 80:
    	    // AppArmor.g:1:400: QUOTED_STRING
    	    {
    	        /* 1:400: QUOTED_STRING */
    	        mQUOTED_STRING(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 81:
    	    // AppArmor.g:1:414: UNQUOTED_PATH
    	    {
    	        /* 1:414: UNQUOTED_PATH */
    	        mUNQUOTED_PATH(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 82:
    	    // AppArmor.g:1:428: LIST_VAR_START
    	    {
    	        /* 1:428: LIST_VAR_START */
    	        mLIST_VAR_START(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 83:
    	    // AppArmor.g:1:443: BOOL_VAR_START
    	    {
    	        /* 1:443: BOOL_VAR_START */
    	        mBOOL_VAR_START(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 84:
    	    // AppArmor.g:1:458: RULE
    	    {
    	        /* 1:458: RULE */
    	        mRULE(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 85:
    	    // AppArmor.g:1:463: IDENT
    	    {
    	        /* 1:463: IDENT */
    	        mIDENT(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 86:
    	    // AppArmor.g:1:469: WS
    	    {
    	        /* 1:469: WS */
    	        mWS(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;

        }
    }

    
    goto ruleTokensEx; /* Prevent compiler warnings */
ruleTokensEx: ;
}

// $ANTLR start synpred1
static void synpred1_fragment(pAppArmorLexer ctx ) 
{   
    // AppArmor.g:1354:5: ( 'include ' )
    // AppArmor.g:1354:6: 'include '
    {
        MATCHS(lit_66); 
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred1Ex; /* Prevent compiler warnings */
rulesynpred1Ex: ;

}
// $ANTLR end synpred1

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */

/* =========================================================================
 * Lexer syntactic predicates
 */
static ANTLR3_BOOLEAN synpred1(pAppArmorLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}

/* =========================================================================
 * Lexer syntactic predicates end.
 * =========================================================================
 */
/* End of Lexer code
 * ================================================
 * ================================================
 */ 


/* End of code
 * =============================================================================
 */
