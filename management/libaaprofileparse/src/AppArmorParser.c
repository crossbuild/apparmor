/** \file
 *  This C source file was generated by $ANTLR version 3.0.1
 *
 *     -  From the grammar source file : AppArmor.g
 *     -                            On : 2007-08-19 11:55:22
 *     -                for the parser : AppArmorParserParser *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 * View this file with tabs set to 8 (:set ts=8 in gvim) and indent at 4 (:set sw=4 in gvim)
 *
*/

/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

	#include "libaaprofileparse.h"
	#include "AppArmorLexer.h"
	#include "Exceptions.h"
	#include <stdio.h>

/* End of Header action.
 * =============================================================================
 */
/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "AppArmorParser.h"
/* ----------------------------------------- */



/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pAppArmorParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pAppArmorParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pAppArmorParser_##scope##Top
#define	SCOPE_SIZE(scope)			(ctx->SCOPE_STACK(scope)->size(ctx->SCOPE_STACK(scope)))
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always refering to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritence.
 */
/* Macros for accessing things in the parser
 */
 
#undef	    PARSER		    
#undef	    RECOGNIZER		    
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK

#define	    PARSER							ctx->pParser  
#define	    RECOGNIZER						PARSER->rec
#define	    HAVEPARSEDRULE(r)				RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define		MEMOIZE(ri,si)					RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT							PARSER->tstream
#define	    STRSTREAM						INPUT
#define		INDEX()							INPUT->istream->index(INPUT->istream)
#define	    HASEXCEPTION()					(RECOGNIZER->error == ANTLR3_TRUE)
#define	    EXCEPTION						RECOGNIZER->exception
#define	    MATCHT(t, fs)					RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()						RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK					    RECOGNIZER->following
#define	    FOLLOWPUSH(x)					FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()						FOLLOWSTACK->pop(FOLLOWSTACK)
#define	    PRECOVER()						RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()					RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)							INPUT->istream->_LA(INPUT->istream, n)
#define	    LT(n)							INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()					RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()						INPUT->istream->consume(INPUT->istream)
#define	    MARK()							INPUT->istream->mark(INPUT->istream)
#define	    REWIND(m)						INPUT->istream->rewind(INPUT->istream, m)
#define	    REWINDLAST()					INPUT->istream->rewindLast(INPUT->istream)
#define		SEEK(n)							INPUT->istream->seek(INPUT->istream, n)
#define	    PERRORRECOVERY					RECOGNIZER->errorRecovery
#define	    _fsp							RECOGNIZER->_fsp
#define	    FAILEDFLAG						RECOGNIZER->failed
#define	    HASFAILED()						(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING					RECOGNIZER->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
static pANTLR3_UINT8   AppArmorParserTokenNames[]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>", 
        (pANTLR3_UINT8) "<UP>", 
        (pANTLR3_UINT8) "SOL_COMMENT",
        (pANTLR3_UINT8) "EOL_COMMENT",
        (pANTLR3_UINT8) "NEWLINE",
        (pANTLR3_UINT8) "INCLUDE",
        (pANTLR3_UINT8) "LESS_THAN",
        (pANTLR3_UINT8) "IDENT",
        (pANTLR3_UINT8) "UNQUOTED_PATH",
        (pANTLR3_UINT8) "GREATER_THAN",
        (pANTLR3_UINT8) "QUOTED_STRING",
        (pANTLR3_UINT8) "LIST_VAR_START",
        (pANTLR3_UINT8) "RIGHT_BRACE",
        (pANTLR3_UINT8) "PLUS",
        (pANTLR3_UINT8) "EQUALS",
        (pANTLR3_UINT8) "BOOL_VAR_START",
        (pANTLR3_UINT8) "LEFT_PAREN",
        (pANTLR3_UINT8) "RIGHT_PAREN",
        (pANTLR3_UINT8) "LEFT_BRACE",
        (pANTLR3_UINT8) "RULE",
        (pANTLR3_UINT8) "AT",
        (pANTLR3_UINT8) "DOLLAR",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "COMMENT_OR_INCLUDE",
        (pANTLR3_UINT8) "ANYTHING_NOT_QUOTED",
        (pANTLR3_UINT8) "PATH",
        (pANTLR3_UINT8) "IDENT_START",
        (pANTLR3_UINT8) "IDENT_CONTINUE",
        (pANTLR3_UINT8) "REAL_IDENT",
        (pANTLR3_UINT8) "WS",
        (pANTLR3_UINT8) "'true'",
        (pANTLR3_UINT8) "'false'",
        (pANTLR3_UINT8) "'audit'",
        (pANTLR3_UINT8) "'version'",
        (pANTLR3_UINT8) "'encoding'",
        (pANTLR3_UINT8) "'disabled'",
        (pANTLR3_UINT8) "'complain'",
        (pANTLR3_UINT8) "'profile'",
        (pANTLR3_UINT8) "'flags'",
        (pANTLR3_UINT8) "'fold_hats'",
        (pANTLR3_UINT8) "','",
        (pANTLR3_UINT8) "'change_profile'",
        (pANTLR3_UINT8) "'capability'",
        (pANTLR3_UINT8) "'if'",
        (pANTLR3_UINT8) "'else'",
        (pANTLR3_UINT8) "'error'",
        (pANTLR3_UINT8) "'undef'",
        (pANTLR3_UINT8) "'warn'",
        (pANTLR3_UINT8) "'not'",
        (pANTLR3_UINT8) "'exists'",
        (pANTLR3_UINT8) "'defined'",
        (pANTLR3_UINT8) "'and'",
        (pANTLR3_UINT8) "'or'",
        (pANTLR3_UINT8) "'network'",
        (pANTLR3_UINT8) "'conntrack'",
        (pANTLR3_UINT8) "'inet'",
        (pANTLR3_UINT8) "'ax25'",
        (pANTLR3_UINT8) "'netrom'",
        (pANTLR3_UINT8) "'bridge'",
        (pANTLR3_UINT8) "'atmpvc'",
        (pANTLR3_UINT8) "'x25'",
        (pANTLR3_UINT8) "'inet6'",
        (pANTLR3_UINT8) "'rose'",
        (pANTLR3_UINT8) "'netbeui'",
        (pANTLR3_UINT8) "'security'",
        (pANTLR3_UINT8) "'key'",
        (pANTLR3_UINT8) "'packet'",
        (pANTLR3_UINT8) "'ash'",
        (pANTLR3_UINT8) "'econet'",
        (pANTLR3_UINT8) "'atmsvc'",
        (pANTLR3_UINT8) "'sna'",
        (pANTLR3_UINT8) "'irda'",
        (pANTLR3_UINT8) "'pppox'",
        (pANTLR3_UINT8) "'wanpipe'",
        (pANTLR3_UINT8) "'bluetooth'",
        (pANTLR3_UINT8) "'stream'",
        (pANTLR3_UINT8) "'dgram'",
        (pANTLR3_UINT8) "'seqpacket'",
        (pANTLR3_UINT8) "'rdm'",
        (pANTLR3_UINT8) "'raw'",
        (pANTLR3_UINT8) "'tcp'",
        (pANTLR3_UINT8) "'udp'",
        (pANTLR3_UINT8) "'ipx'",
        (pANTLR3_UINT8) "'appletalk'",
        (pANTLR3_UINT8) "'sctp'",
        (pANTLR3_UINT8) "'&'",
        (pANTLR3_UINT8) "'connect'",
        (pANTLR3_UINT8) "'accept'",
        (pANTLR3_UINT8) "'connected'",
        (pANTLR3_UINT8) "'send'",
        (pANTLR3_UINT8) "'recv'",
        (pANTLR3_UINT8) "'to'",
        (pANTLR3_UINT8) "'from'",
        (pANTLR3_UINT8) "'endpoint'",
        (pANTLR3_UINT8) "'via'",
        (pANTLR3_UINT8) "'limit'"
       };


        

/* Forward declare the locally static matching functions we have generated.
 */
static ParseNode *	startParse    (pAppArmorParser ctx);
static void	appArmorProfile    (pAppArmorParser ctx);
static void	newlineRule    (pAppArmorParser ctx);
static void	startOfLineComment    (pAppArmorParser ctx);
static void	endOfLineComment    (pAppArmorParser ctx, Comment *a);
static void	includeExpr    (pAppArmorParser ctx);
static void	variableAssign    (pAppArmorParser ctx);
static void	optionExpr    (pAppArmorParser ctx);
static void	profileExpr    (pAppArmorParser ctx);
static ParseNode *	ruleExpr    (pAppArmorParser ctx);
static ParseNode *	accessRule    (pAppArmorParser ctx);
static AppArmorParser_accessPath_return	accessPath    (pAppArmorParser ctx);
static ParseNode *	changeProfileRule    (pAppArmorParser ctx);
static ParseNode *	capabilityRule    (pAppArmorParser ctx);
static ParseNode *	capabilitiesSubExpr    (pAppArmorParser ctx);
static ParseNode *	auditRule    (pAppArmorParser ctx);
static ParseNode *	conditionalIfExpr    (pAppArmorParser ctx);
static ParseNode *	conditionalElseExpr    (pAppArmorParser ctx);
static ParseNode *	conditionalRules    (pAppArmorParser ctx);
static ParseNode *	builtInFunctions    (pAppArmorParser ctx);
static AppArmorParser_ifExpr_return	ifExpr    (pAppArmorParser ctx);
static AppArmorParser_variableOrFunction_return	variableOrFunction    (pAppArmorParser ctx);
static AppArmorParser_andNotExpr_return	andNotExpr    (pAppArmorParser ctx);
static ParseNode *	networkRule    (pAppArmorParser ctx);
static char *	domainRule    (pAppArmorParser ctx);
static char *	typeRule    (pAppArmorParser ctx);
static char *	protocolRule    (pAppArmorParser ctx);
static AppArmorParser_networkActionRule_return	networkActionRule    (pAppArmorParser ctx);
static char *	tcpRule    (pAppArmorParser ctx);
static char *	udpRule    (pAppArmorParser ctx);
static AppArmorParser_networkHostRule_return	networkHostRule    (pAppArmorParser ctx);
static char *	ipRule    (pAppArmorParser ctx);
static char *	ifaceRule    (pAppArmorParser ctx);
static char *	limitRule    (pAppArmorParser ctx);
static void	AppArmorParserFree(pAppArmorParser ctx);

/* Function to initialize bitset APIs
 */
static	void AppArmorParserLoadFollowSets();

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed. 
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the gramar file that generated this code
 */
static unsigned char fileName[] = "AppArmor.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static unsigned char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new AppArmorParser parser and retrun a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pAppArmorParser
AppArmorParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
    pAppArmorParser ctx;	    /* Context structure we will build and return   */
    
    ctx	= (pAppArmorParser) ANTLR3_MALLOC(sizeof(AppArmorParser));
    
    if	(ctx == NULL)
    {
	/* Failed to allocate memory for parser context */
        return  (pAppArmorParser)ANTLR3_ERR_NOMEM;
    }
    
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We intialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in AppArmorParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream);
    /* Install the implementation of our AppArmorParser interface
     */
    ctx->startParse	= startParse;
    ctx->appArmorProfile	= appArmorProfile;
    ctx->newlineRule	= newlineRule;
    ctx->startOfLineComment	= startOfLineComment;
    ctx->endOfLineComment	= endOfLineComment;
    ctx->includeExpr	= includeExpr;
    ctx->variableAssign	= variableAssign;
    ctx->optionExpr	= optionExpr;
    ctx->profileExpr	= profileExpr;
    ctx->ruleExpr	= ruleExpr;
    ctx->accessRule	= accessRule;
    ctx->accessPath	= accessPath;
    ctx->changeProfileRule	= changeProfileRule;
    ctx->capabilityRule	= capabilityRule;
    ctx->capabilitiesSubExpr	= capabilitiesSubExpr;
    ctx->auditRule	= auditRule;
    ctx->conditionalIfExpr	= conditionalIfExpr;
    ctx->conditionalElseExpr	= conditionalElseExpr;
    ctx->conditionalRules	= conditionalRules;
    ctx->builtInFunctions	= builtInFunctions;
    ctx->ifExpr	= ifExpr;
    ctx->variableOrFunction	= variableOrFunction;
    ctx->andNotExpr	= andNotExpr;
    ctx->networkRule	= networkRule;
    ctx->domainRule	= domainRule;
    ctx->typeRule	= typeRule;
    ctx->protocolRule	= protocolRule;
    ctx->networkActionRule	= networkActionRule;
    ctx->tcpRule	= tcpRule;
    ctx->udpRule	= udpRule;
    ctx->networkHostRule	= networkHostRule;
    ctx->ipRule	= ipRule;
    ctx->ifaceRule	= ifaceRule;
    ctx->limitRule	= limitRule;

    ctx->free			= AppArmorParserFree;
    ctx->getGrammarFileName	= getGrammarFileName;
    
    /* Install the scope pushing methods.
     */

        
    
	
    /* Install the token table
     */
    RECOGNIZER->tokenNames   = AppArmorParserTokenNames;
    
    /* Initialize the follow bit sets
     */
    AppArmorParserLoadFollowSets();
    
    /* Return the newly built parser to the caller
     */
    return  ctx;
}

/** Free the parser resources
 */
 static void
 AppArmorParserFree(pAppArmorParser ctx)
 {
    /* Free any scope memory
     */
    
        
    ctx->pParser->free(ctx->pParser);
    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }
 
/** Return token names used by this parser
 *
 * The returned pointer is used as an index into the token names table (using the token 
 * number as the index).
 * 
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames() 
{
        return AppArmorParserTokenNames; 
}


    	ParseNode *mpTree;
    	Comment *mpCommentBlock;
    	int mNewlineCount;
    	pANTLR3_STRING_FACTORY factory;
    		
    	void AttachCommentBlock(ParseNode *node)
    	{
    		if (mpCommentBlock != NULL)
    		{
    			node->pCommentBlock = mpCommentBlock;
    			mpCommentBlock = NULL;
    		}		
    	}

    
/* Declare the bitsets
 */

/** Bitset defining follow set for error recovery in rule state: FOLLOW_appArmorProfile_in_startParse101  */
static	ANTLR3_BITWORD FOLLOW_appArmorProfile_in_startParse101_bits[]	= { ANTLR3_UINT64_LIT(0x000000FC000234D0) };
static  ANTLR3_BITSET FOLLOW_appArmorProfile_in_startParse101	= { FOLLOW_appArmorProfile_in_startParse101_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EOF_in_startParse106  */
static	ANTLR3_BITWORD FOLLOW_EOF_in_startParse106_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_EOF_in_startParse106	= { FOLLOW_EOF_in_startParse106_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_newlineRule_in_appArmorProfile122  */
static	ANTLR3_BITWORD FOLLOW_newlineRule_in_appArmorProfile122_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_newlineRule_in_appArmorProfile122	= { FOLLOW_newlineRule_in_appArmorProfile122_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_includeExpr_in_appArmorProfile131  */
static	ANTLR3_BITWORD FOLLOW_includeExpr_in_appArmorProfile131_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_includeExpr_in_appArmorProfile131	= { FOLLOW_includeExpr_in_appArmorProfile131_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_startOfLineComment_in_appArmorProfile142  */
static	ANTLR3_BITWORD FOLLOW_startOfLineComment_in_appArmorProfile142_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_startOfLineComment_in_appArmorProfile142	= { FOLLOW_startOfLineComment_in_appArmorProfile142_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_optionExpr_in_appArmorProfile153  */
static	ANTLR3_BITWORD FOLLOW_optionExpr_in_appArmorProfile153_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_optionExpr_in_appArmorProfile153	= { FOLLOW_optionExpr_in_appArmorProfile153_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_profileExpr_in_appArmorProfile164  */
static	ANTLR3_BITWORD FOLLOW_profileExpr_in_appArmorProfile164_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_profileExpr_in_appArmorProfile164	= { FOLLOW_profileExpr_in_appArmorProfile164_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_variableAssign_in_appArmorProfile175  */
static	ANTLR3_BITWORD FOLLOW_variableAssign_in_appArmorProfile175_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_variableAssign_in_appArmorProfile175	= { FOLLOW_variableAssign_in_appArmorProfile175_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NEWLINE_in_newlineRule193  */
static	ANTLR3_BITWORD FOLLOW_NEWLINE_in_newlineRule193_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_NEWLINE_in_newlineRule193	= { FOLLOW_NEWLINE_in_newlineRule193_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SOL_COMMENT_in_startOfLineComment211  */
static	ANTLR3_BITWORD FOLLOW_SOL_COMMENT_in_startOfLineComment211_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_SOL_COMMENT_in_startOfLineComment211	= { FOLLOW_SOL_COMMENT_in_startOfLineComment211_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EOL_COMMENT_in_endOfLineComment230  */
static	ANTLR3_BITWORD FOLLOW_EOL_COMMENT_in_endOfLineComment230_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_EOL_COMMENT_in_endOfLineComment230	= { FOLLOW_EOL_COMMENT_in_endOfLineComment230_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INCLUDE_in_includeExpr252  */
static	ANTLR3_BITWORD FOLLOW_INCLUDE_in_includeExpr252_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001100) };
static  ANTLR3_BITSET FOLLOW_INCLUDE_in_includeExpr252	= { FOLLOW_INCLUDE_in_includeExpr252_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LESS_THAN_in_includeExpr255  */
static	ANTLR3_BITWORD FOLLOW_LESS_THAN_in_includeExpr255_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000600) };
static  ANTLR3_BITSET FOLLOW_LESS_THAN_in_includeExpr255	= { FOLLOW_LESS_THAN_in_includeExpr255_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_includeExpr260  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_includeExpr260_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET FOLLOW_IDENT_in_includeExpr260	= { FOLLOW_IDENT_in_includeExpr260_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UNQUOTED_PATH_in_includeExpr264  */
static	ANTLR3_BITWORD FOLLOW_UNQUOTED_PATH_in_includeExpr264_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET FOLLOW_UNQUOTED_PATH_in_includeExpr264	= { FOLLOW_UNQUOTED_PATH_in_includeExpr264_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GREATER_THAN_in_includeExpr267  */
static	ANTLR3_BITWORD FOLLOW_GREATER_THAN_in_includeExpr267_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET FOLLOW_GREATER_THAN_in_includeExpr267	= { FOLLOW_GREATER_THAN_in_includeExpr267_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_QUOTED_STRING_in_includeExpr274  */
static	ANTLR3_BITWORD FOLLOW_QUOTED_STRING_in_includeExpr274_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET FOLLOW_QUOTED_STRING_in_includeExpr274	= { FOLLOW_QUOTED_STRING_in_includeExpr274_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_endOfLineComment_in_includeExpr280  */
static	ANTLR3_BITWORD FOLLOW_endOfLineComment_in_includeExpr280_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_endOfLineComment_in_includeExpr280	= { FOLLOW_endOfLineComment_in_includeExpr280_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LIST_VAR_START_in_variableAssign309  */
static	ANTLR3_BITWORD FOLLOW_LIST_VAR_START_in_variableAssign309_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET FOLLOW_LIST_VAR_START_in_variableAssign309	= { FOLLOW_LIST_VAR_START_in_variableAssign309_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_variableAssign313  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_variableAssign313_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET FOLLOW_IDENT_in_variableAssign313	= { FOLLOW_IDENT_in_variableAssign313_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RIGHT_BRACE_in_variableAssign315  */
static	ANTLR3_BITWORD FOLLOW_RIGHT_BRACE_in_variableAssign315_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000018000) };
static  ANTLR3_BITSET FOLLOW_RIGHT_BRACE_in_variableAssign315	= { FOLLOW_RIGHT_BRACE_in_variableAssign315_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PLUS_in_variableAssign325  */
static	ANTLR3_BITWORD FOLLOW_PLUS_in_variableAssign325_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET FOLLOW_PLUS_in_variableAssign325	= { FOLLOW_PLUS_in_variableAssign325_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUALS_in_variableAssign333  */
static	ANTLR3_BITWORD FOLLOW_EQUALS_in_variableAssign333_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000003660) };
static  ANTLR3_BITSET FOLLOW_EQUALS_in_variableAssign333	= { FOLLOW_EQUALS_in_variableAssign333_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_variableAssign350  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_variableAssign350_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000003660) };
static  ANTLR3_BITSET FOLLOW_IDENT_in_variableAssign350	= { FOLLOW_IDENT_in_variableAssign350_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_QUOTED_STRING_in_variableAssign354  */
static	ANTLR3_BITWORD FOLLOW_QUOTED_STRING_in_variableAssign354_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000003660) };
static  ANTLR3_BITSET FOLLOW_QUOTED_STRING_in_variableAssign354	= { FOLLOW_QUOTED_STRING_in_variableAssign354_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UNQUOTED_PATH_in_variableAssign358  */
static	ANTLR3_BITWORD FOLLOW_UNQUOTED_PATH_in_variableAssign358_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000003660) };
static  ANTLR3_BITSET FOLLOW_UNQUOTED_PATH_in_variableAssign358	= { FOLLOW_UNQUOTED_PATH_in_variableAssign358_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LIST_VAR_START_in_variableAssign367  */
static	ANTLR3_BITWORD FOLLOW_LIST_VAR_START_in_variableAssign367_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET FOLLOW_LIST_VAR_START_in_variableAssign367	= { FOLLOW_LIST_VAR_START_in_variableAssign367_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_variableAssign371  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_variableAssign371_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET FOLLOW_IDENT_in_variableAssign371	= { FOLLOW_IDENT_in_variableAssign371_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RIGHT_BRACE_in_variableAssign373  */
static	ANTLR3_BITWORD FOLLOW_RIGHT_BRACE_in_variableAssign373_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000003660) };
static  ANTLR3_BITSET FOLLOW_RIGHT_BRACE_in_variableAssign373	= { FOLLOW_RIGHT_BRACE_in_variableAssign373_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BOOL_VAR_START_in_variableAssign389  */
static	ANTLR3_BITWORD FOLLOW_BOOL_VAR_START_in_variableAssign389_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET FOLLOW_BOOL_VAR_START_in_variableAssign389	= { FOLLOW_BOOL_VAR_START_in_variableAssign389_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_variableAssign393  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_variableAssign393_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET FOLLOW_IDENT_in_variableAssign393	= { FOLLOW_IDENT_in_variableAssign393_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RIGHT_BRACE_in_variableAssign395  */
static	ANTLR3_BITWORD FOLLOW_RIGHT_BRACE_in_variableAssign395_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET FOLLOW_RIGHT_BRACE_in_variableAssign395	= { FOLLOW_RIGHT_BRACE_in_variableAssign395_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUALS_in_variableAssign403  */
static	ANTLR3_BITWORD FOLLOW_EQUALS_in_variableAssign403_bits[]	= { ANTLR3_UINT64_LIT(0x0000000300000000) };
static  ANTLR3_BITSET FOLLOW_EQUALS_in_variableAssign403	= { FOLLOW_EQUALS_in_variableAssign403_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_32_in_variableAssign409  */
static	ANTLR3_BITWORD FOLLOW_32_in_variableAssign409_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000060) };
static  ANTLR3_BITSET FOLLOW_32_in_variableAssign409	= { FOLLOW_32_in_variableAssign409_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_variableAssign419  */
static	ANTLR3_BITWORD FOLLOW_33_in_variableAssign419_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000060) };
static  ANTLR3_BITSET FOLLOW_33_in_variableAssign419	= { FOLLOW_33_in_variableAssign419_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NEWLINE_in_variableAssign438  */
static	ANTLR3_BITWORD FOLLOW_NEWLINE_in_variableAssign438_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_NEWLINE_in_variableAssign438	= { FOLLOW_NEWLINE_in_variableAssign438_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_endOfLineComment_in_variableAssign442  */
static	ANTLR3_BITWORD FOLLOW_endOfLineComment_in_variableAssign442_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_endOfLineComment_in_variableAssign442	= { FOLLOW_endOfLineComment_in_variableAssign442_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_34_in_optionExpr470  */
static	ANTLR3_BITWORD FOLLOW_34_in_optionExpr470_bits[]	= { ANTLR3_UINT64_LIT(0x0000000300000000) };
static  ANTLR3_BITSET FOLLOW_34_in_optionExpr470	= { FOLLOW_34_in_optionExpr470_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_32_in_optionExpr473  */
static	ANTLR3_BITWORD FOLLOW_32_in_optionExpr473_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET FOLLOW_32_in_optionExpr473	= { FOLLOW_32_in_optionExpr473_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_optionExpr483  */
static	ANTLR3_BITWORD FOLLOW_33_in_optionExpr483_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET FOLLOW_33_in_optionExpr483	= { FOLLOW_33_in_optionExpr483_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_35_in_optionExpr495  */
static	ANTLR3_BITWORD FOLLOW_35_in_optionExpr495_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001200) };
static  ANTLR3_BITSET FOLLOW_35_in_optionExpr495	= { FOLLOW_35_in_optionExpr495_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_optionExpr500  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_optionExpr500_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET FOLLOW_IDENT_in_optionExpr500	= { FOLLOW_IDENT_in_optionExpr500_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_QUOTED_STRING_in_optionExpr506  */
static	ANTLR3_BITWORD FOLLOW_QUOTED_STRING_in_optionExpr506_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET FOLLOW_QUOTED_STRING_in_optionExpr506	= { FOLLOW_QUOTED_STRING_in_optionExpr506_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_36_in_optionExpr515  */
static	ANTLR3_BITWORD FOLLOW_36_in_optionExpr515_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001200) };
static  ANTLR3_BITSET FOLLOW_36_in_optionExpr515	= { FOLLOW_36_in_optionExpr515_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_optionExpr520  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_optionExpr520_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET FOLLOW_IDENT_in_optionExpr520	= { FOLLOW_IDENT_in_optionExpr520_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_QUOTED_STRING_in_optionExpr526  */
static	ANTLR3_BITWORD FOLLOW_QUOTED_STRING_in_optionExpr526_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET FOLLOW_QUOTED_STRING_in_optionExpr526	= { FOLLOW_QUOTED_STRING_in_optionExpr526_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_37_in_optionExpr535  */
static	ANTLR3_BITWORD FOLLOW_37_in_optionExpr535_bits[]	= { ANTLR3_UINT64_LIT(0x0000000300000000) };
static  ANTLR3_BITSET FOLLOW_37_in_optionExpr535	= { FOLLOW_37_in_optionExpr535_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_32_in_optionExpr538  */
static	ANTLR3_BITWORD FOLLOW_32_in_optionExpr538_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET FOLLOW_32_in_optionExpr538	= { FOLLOW_32_in_optionExpr538_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_optionExpr550  */
static	ANTLR3_BITWORD FOLLOW_33_in_optionExpr550_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET FOLLOW_33_in_optionExpr550	= { FOLLOW_33_in_optionExpr550_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_38_in_optionExpr562  */
static	ANTLR3_BITWORD FOLLOW_38_in_optionExpr562_bits[]	= { ANTLR3_UINT64_LIT(0x0000000300000000) };
static  ANTLR3_BITSET FOLLOW_38_in_optionExpr562	= { FOLLOW_38_in_optionExpr562_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_32_in_optionExpr565  */
static	ANTLR3_BITWORD FOLLOW_32_in_optionExpr565_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET FOLLOW_32_in_optionExpr565	= { FOLLOW_32_in_optionExpr565_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_optionExpr577  */
static	ANTLR3_BITWORD FOLLOW_33_in_optionExpr577_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET FOLLOW_33_in_optionExpr577	= { FOLLOW_33_in_optionExpr577_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_endOfLineComment_in_optionExpr593  */
static	ANTLR3_BITWORD FOLLOW_endOfLineComment_in_optionExpr593_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_endOfLineComment_in_optionExpr593	= { FOLLOW_endOfLineComment_in_optionExpr593_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UNQUOTED_PATH_in_profileExpr627  */
static	ANTLR3_BITWORD FOLLOW_UNQUOTED_PATH_in_profileExpr627_bits[]	= { ANTLR3_UINT64_LIT(0x0000010000140020) };
static  ANTLR3_BITSET FOLLOW_UNQUOTED_PATH_in_profileExpr627	= { FOLLOW_UNQUOTED_PATH_in_profileExpr627_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_QUOTED_STRING_in_profileExpr631  */
static	ANTLR3_BITWORD FOLLOW_QUOTED_STRING_in_profileExpr631_bits[]	= { ANTLR3_UINT64_LIT(0x0000010000140020) };
static  ANTLR3_BITSET FOLLOW_QUOTED_STRING_in_profileExpr631	= { FOLLOW_QUOTED_STRING_in_profileExpr631_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_39_in_profileExpr645  */
static	ANTLR3_BITWORD FOLLOW_39_in_profileExpr645_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET FOLLOW_39_in_profileExpr645	= { FOLLOW_39_in_profileExpr645_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_profileExpr649  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_profileExpr649_bits[]	= { ANTLR3_UINT64_LIT(0x0000010000140020) };
static  ANTLR3_BITSET FOLLOW_IDENT_in_profileExpr649	= { FOLLOW_IDENT_in_profileExpr649_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_40_in_profileExpr673  */
static	ANTLR3_BITWORD FOLLOW_40_in_profileExpr673_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET FOLLOW_40_in_profileExpr673	= { FOLLOW_40_in_profileExpr673_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUALS_in_profileExpr675  */
static	ANTLR3_BITWORD FOLLOW_EQUALS_in_profileExpr675_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET FOLLOW_EQUALS_in_profileExpr675	= { FOLLOW_EQUALS_in_profileExpr675_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEFT_PAREN_in_profileExpr679  */
static	ANTLR3_BITWORD FOLLOW_LEFT_PAREN_in_profileExpr679_bits[]	= { ANTLR3_UINT64_LIT(0x0000026400080000) };
static  ANTLR3_BITSET FOLLOW_LEFT_PAREN_in_profileExpr679	= { FOLLOW_LEFT_PAREN_in_profileExpr679_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_38_in_profileExpr685  */
static	ANTLR3_BITWORD FOLLOW_38_in_profileExpr685_bits[]	= { ANTLR3_UINT64_LIT(0x0000026400080000) };
static  ANTLR3_BITSET FOLLOW_38_in_profileExpr685	= { FOLLOW_38_in_profileExpr685_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_37_in_profileExpr693  */
static	ANTLR3_BITWORD FOLLOW_37_in_profileExpr693_bits[]	= { ANTLR3_UINT64_LIT(0x0000026400080000) };
static  ANTLR3_BITSET FOLLOW_37_in_profileExpr693	= { FOLLOW_37_in_profileExpr693_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_34_in_profileExpr701  */
static	ANTLR3_BITWORD FOLLOW_34_in_profileExpr701_bits[]	= { ANTLR3_UINT64_LIT(0x0000026400080000) };
static  ANTLR3_BITSET FOLLOW_34_in_profileExpr701	= { FOLLOW_34_in_profileExpr701_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_41_in_profileExpr709  */
static	ANTLR3_BITWORD FOLLOW_41_in_profileExpr709_bits[]	= { ANTLR3_UINT64_LIT(0x0000026400080000) };
static  ANTLR3_BITSET FOLLOW_41_in_profileExpr709	= { FOLLOW_41_in_profileExpr709_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RIGHT_PAREN_in_profileExpr717  */
static	ANTLR3_BITWORD FOLLOW_RIGHT_PAREN_in_profileExpr717_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100020) };
static  ANTLR3_BITSET FOLLOW_RIGHT_PAREN_in_profileExpr717	= { FOLLOW_RIGHT_PAREN_in_profileExpr717_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_endOfLineComment_in_profileExpr726  */
static	ANTLR3_BITWORD FOLLOW_endOfLineComment_in_profileExpr726_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET FOLLOW_endOfLineComment_in_profileExpr726	= { FOLLOW_endOfLineComment_in_profileExpr726_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEFT_BRACE_in_profileExpr733  */
static	ANTLR3_BITWORD FOLLOW_LEFT_BRACE_in_profileExpr733_bits[]	= { ANTLR3_UINT64_LIT(0x00807804002074F0) };
static  ANTLR3_BITSET FOLLOW_LEFT_BRACE_in_profileExpr733	= { FOLLOW_LEFT_BRACE_in_profileExpr733_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_endOfLineComment_in_profileExpr737  */
static	ANTLR3_BITWORD FOLLOW_endOfLineComment_in_profileExpr737_bits[]	= { ANTLR3_UINT64_LIT(0x00807804002074D0) };
static  ANTLR3_BITSET FOLLOW_endOfLineComment_in_profileExpr737	= { FOLLOW_endOfLineComment_in_profileExpr737_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ruleExpr_in_profileExpr746  */
static	ANTLR3_BITWORD FOLLOW_ruleExpr_in_profileExpr746_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET FOLLOW_ruleExpr_in_profileExpr746	= { FOLLOW_ruleExpr_in_profileExpr746_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RIGHT_BRACE_in_profileExpr752  */
static	ANTLR3_BITWORD FOLLOW_RIGHT_BRACE_in_profileExpr752_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET FOLLOW_RIGHT_BRACE_in_profileExpr752	= { FOLLOW_RIGHT_BRACE_in_profileExpr752_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_endOfLineComment_in_profileExpr756  */
static	ANTLR3_BITWORD FOLLOW_endOfLineComment_in_profileExpr756_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_endOfLineComment_in_profileExpr756	= { FOLLOW_endOfLineComment_in_profileExpr756_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_newlineRule_in_ruleExpr785  */
static	ANTLR3_BITWORD FOLLOW_newlineRule_in_ruleExpr785_bits[]	= { ANTLR3_UINT64_LIT(0x00807804002034D2) };
static  ANTLR3_BITSET FOLLOW_newlineRule_in_ruleExpr785	= { FOLLOW_newlineRule_in_ruleExpr785_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_startOfLineComment_in_ruleExpr790  */
static	ANTLR3_BITWORD FOLLOW_startOfLineComment_in_ruleExpr790_bits[]	= { ANTLR3_UINT64_LIT(0x00807804002034D2) };
static  ANTLR3_BITSET FOLLOW_startOfLineComment_in_ruleExpr790	= { FOLLOW_startOfLineComment_in_ruleExpr790_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_includeExpr_in_ruleExpr795  */
static	ANTLR3_BITWORD FOLLOW_includeExpr_in_ruleExpr795_bits[]	= { ANTLR3_UINT64_LIT(0x00807804002034D2) };
static  ANTLR3_BITSET FOLLOW_includeExpr_in_ruleExpr795	= { FOLLOW_includeExpr_in_ruleExpr795_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_accessRule_in_ruleExpr806  */
static	ANTLR3_BITWORD FOLLOW_accessRule_in_ruleExpr806_bits[]	= { ANTLR3_UINT64_LIT(0x00807804002034D2) };
static  ANTLR3_BITSET FOLLOW_accessRule_in_ruleExpr806	= { FOLLOW_accessRule_in_ruleExpr806_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_capabilityRule_in_ruleExpr817  */
static	ANTLR3_BITWORD FOLLOW_capabilityRule_in_ruleExpr817_bits[]	= { ANTLR3_UINT64_LIT(0x00807804002034D2) };
static  ANTLR3_BITSET FOLLOW_capabilityRule_in_ruleExpr817	= { FOLLOW_capabilityRule_in_ruleExpr817_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_auditRule_in_ruleExpr829  */
static	ANTLR3_BITWORD FOLLOW_auditRule_in_ruleExpr829_bits[]	= { ANTLR3_UINT64_LIT(0x00807804002034D2) };
static  ANTLR3_BITSET FOLLOW_auditRule_in_ruleExpr829	= { FOLLOW_auditRule_in_ruleExpr829_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_changeProfileRule_in_ruleExpr840  */
static	ANTLR3_BITWORD FOLLOW_changeProfileRule_in_ruleExpr840_bits[]	= { ANTLR3_UINT64_LIT(0x00807804002034D2) };
static  ANTLR3_BITSET FOLLOW_changeProfileRule_in_ruleExpr840	= { FOLLOW_changeProfileRule_in_ruleExpr840_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_networkRule_in_ruleExpr851  */
static	ANTLR3_BITWORD FOLLOW_networkRule_in_ruleExpr851_bits[]	= { ANTLR3_UINT64_LIT(0x00807804002034D2) };
static  ANTLR3_BITSET FOLLOW_networkRule_in_ruleExpr851	= { FOLLOW_networkRule_in_ruleExpr851_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_conditionalIfExpr_in_ruleExpr866  */
static	ANTLR3_BITWORD FOLLOW_conditionalIfExpr_in_ruleExpr866_bits[]	= { ANTLR3_UINT64_LIT(0x00807804002034D2) };
static  ANTLR3_BITSET FOLLOW_conditionalIfExpr_in_ruleExpr866	= { FOLLOW_conditionalIfExpr_in_ruleExpr866_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_conditionalElseExpr_in_ruleExpr881  */
static	ANTLR3_BITWORD FOLLOW_conditionalElseExpr_in_ruleExpr881_bits[]	= { ANTLR3_UINT64_LIT(0x00807804002034D2) };
static  ANTLR3_BITSET FOLLOW_conditionalElseExpr_in_ruleExpr881	= { FOLLOW_conditionalElseExpr_in_ruleExpr881_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_accessPath_in_accessRule920  */
static	ANTLR3_BITWORD FOLLOW_accessPath_in_accessRule920_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET FOLLOW_accessPath_in_accessRule920	= { FOLLOW_accessPath_in_accessRule920_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RULE_in_accessRule924  */
static	ANTLR3_BITWORD FOLLOW_RULE_in_accessRule924_bits[]	= { ANTLR3_UINT64_LIT(0x0000040000000000) };
static  ANTLR3_BITSET FOLLOW_RULE_in_accessRule924	= { FOLLOW_RULE_in_accessRule924_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_42_in_accessRule926  */
static	ANTLR3_BITWORD FOLLOW_42_in_accessRule926_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET FOLLOW_42_in_accessRule926	= { FOLLOW_42_in_accessRule926_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RULE_in_accessRule933  */
static	ANTLR3_BITWORD FOLLOW_RULE_in_accessRule933_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000003400) };
static  ANTLR3_BITSET FOLLOW_RULE_in_accessRule933	= { FOLLOW_RULE_in_accessRule933_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_accessPath_in_accessRule937  */
static	ANTLR3_BITWORD FOLLOW_accessPath_in_accessRule937_bits[]	= { ANTLR3_UINT64_LIT(0x0000040000000000) };
static  ANTLR3_BITSET FOLLOW_accessPath_in_accessRule937	= { FOLLOW_accessPath_in_accessRule937_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_42_in_accessRule939  */
static	ANTLR3_BITWORD FOLLOW_42_in_accessRule939_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET FOLLOW_42_in_accessRule939	= { FOLLOW_42_in_accessRule939_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_endOfLineComment_in_accessRule949  */
static	ANTLR3_BITWORD FOLLOW_endOfLineComment_in_accessRule949_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_endOfLineComment_in_accessRule949	= { FOLLOW_endOfLineComment_in_accessRule949_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_QUOTED_STRING_in_accessPath979  */
static	ANTLR3_BITWORD FOLLOW_QUOTED_STRING_in_accessPath979_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_QUOTED_STRING_in_accessPath979	= { FOLLOW_QUOTED_STRING_in_accessPath979_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LIST_VAR_START_in_accessPath990  */
static	ANTLR3_BITWORD FOLLOW_LIST_VAR_START_in_accessPath990_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET FOLLOW_LIST_VAR_START_in_accessPath990	= { FOLLOW_LIST_VAR_START_in_accessPath990_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_accessPath994  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_accessPath994_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET FOLLOW_IDENT_in_accessPath994	= { FOLLOW_IDENT_in_accessPath994_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RIGHT_BRACE_in_accessPath996  */
static	ANTLR3_BITWORD FOLLOW_RIGHT_BRACE_in_accessPath996_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002402) };
static  ANTLR3_BITSET FOLLOW_RIGHT_BRACE_in_accessPath996	= { FOLLOW_RIGHT_BRACE_in_accessPath996_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UNQUOTED_PATH_in_accessPath1012  */
static	ANTLR3_BITWORD FOLLOW_UNQUOTED_PATH_in_accessPath1012_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002402) };
static  ANTLR3_BITSET FOLLOW_UNQUOTED_PATH_in_accessPath1012	= { FOLLOW_UNQUOTED_PATH_in_accessPath1012_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_43_in_changeProfileRule1048  */
static	ANTLR3_BITWORD FOLLOW_43_in_changeProfileRule1048_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET FOLLOW_43_in_changeProfileRule1048	= { FOLLOW_43_in_changeProfileRule1048_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UNQUOTED_PATH_in_changeProfileRule1052  */
static	ANTLR3_BITWORD FOLLOW_UNQUOTED_PATH_in_changeProfileRule1052_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_UNQUOTED_PATH_in_changeProfileRule1052	= { FOLLOW_UNQUOTED_PATH_in_changeProfileRule1052_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_44_in_capabilityRule1078  */
static	ANTLR3_BITWORD FOLLOW_44_in_capabilityRule1078_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001200) };
static  ANTLR3_BITSET FOLLOW_44_in_capabilityRule1078	= { FOLLOW_44_in_capabilityRule1078_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_capabilitiesSubExpr_in_capabilityRule1087  */
static	ANTLR3_BITWORD FOLLOW_capabilitiesSubExpr_in_capabilityRule1087_bits[]	= { ANTLR3_UINT64_LIT(0x0000040000001200) };
static  ANTLR3_BITSET FOLLOW_capabilitiesSubExpr_in_capabilityRule1087	= { FOLLOW_capabilitiesSubExpr_in_capabilityRule1087_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_42_in_capabilityRule1096  */
static	ANTLR3_BITWORD FOLLOW_42_in_capabilityRule1096_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET FOLLOW_42_in_capabilityRule1096	= { FOLLOW_42_in_capabilityRule1096_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_endOfLineComment_in_capabilityRule1101  */
static	ANTLR3_BITWORD FOLLOW_endOfLineComment_in_capabilityRule1101_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_endOfLineComment_in_capabilityRule1101	= { FOLLOW_endOfLineComment_in_capabilityRule1101_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_capabilitiesSubExpr1132  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_capabilitiesSubExpr1132_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_IDENT_in_capabilitiesSubExpr1132	= { FOLLOW_IDENT_in_capabilitiesSubExpr1132_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_QUOTED_STRING_in_capabilitiesSubExpr1138  */
static	ANTLR3_BITWORD FOLLOW_QUOTED_STRING_in_capabilitiesSubExpr1138_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_QUOTED_STRING_in_capabilitiesSubExpr1138	= { FOLLOW_QUOTED_STRING_in_capabilitiesSubExpr1138_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_34_in_auditRule1165  */
static	ANTLR3_BITWORD FOLLOW_34_in_auditRule1165_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100020) };
static  ANTLR3_BITSET FOLLOW_34_in_auditRule1165	= { FOLLOW_34_in_auditRule1165_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_endOfLineComment_in_auditRule1169  */
static	ANTLR3_BITWORD FOLLOW_endOfLineComment_in_auditRule1169_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET FOLLOW_endOfLineComment_in_auditRule1169	= { FOLLOW_endOfLineComment_in_auditRule1169_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEFT_BRACE_in_auditRule1177  */
static	ANTLR3_BITWORD FOLLOW_LEFT_BRACE_in_auditRule1177_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000207420) };
static  ANTLR3_BITSET FOLLOW_LEFT_BRACE_in_auditRule1177	= { FOLLOW_LEFT_BRACE_in_auditRule1177_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_endOfLineComment_in_auditRule1181  */
static	ANTLR3_BITWORD FOLLOW_endOfLineComment_in_auditRule1181_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000207400) };
static  ANTLR3_BITSET FOLLOW_endOfLineComment_in_auditRule1181	= { FOLLOW_endOfLineComment_in_auditRule1181_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_accessRule_in_auditRule1192  */
static	ANTLR3_BITWORD FOLLOW_accessRule_in_auditRule1192_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000207400) };
static  ANTLR3_BITSET FOLLOW_accessRule_in_auditRule1192	= { FOLLOW_accessRule_in_auditRule1192_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RIGHT_BRACE_in_auditRule1204  */
static	ANTLR3_BITWORD FOLLOW_RIGHT_BRACE_in_auditRule1204_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET FOLLOW_RIGHT_BRACE_in_auditRule1204	= { FOLLOW_RIGHT_BRACE_in_auditRule1204_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_endOfLineComment_in_auditRule1208  */
static	ANTLR3_BITWORD FOLLOW_endOfLineComment_in_auditRule1208_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_endOfLineComment_in_auditRule1208	= { FOLLOW_endOfLineComment_in_auditRule1208_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_45_in_conditionalIfExpr1239  */
static	ANTLR3_BITWORD FOLLOW_45_in_conditionalIfExpr1239_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET FOLLOW_45_in_conditionalIfExpr1239	= { FOLLOW_45_in_conditionalIfExpr1239_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEFT_PAREN_in_conditionalIfExpr1241  */
static	ANTLR3_BITWORD FOLLOW_LEFT_PAREN_in_conditionalIfExpr1241_bits[]	= { ANTLR3_UINT64_LIT(0x001C000000020000) };
static  ANTLR3_BITSET FOLLOW_LEFT_PAREN_in_conditionalIfExpr1241	= { FOLLOW_LEFT_PAREN_in_conditionalIfExpr1241_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ifExpr_in_conditionalIfExpr1245  */
static	ANTLR3_BITWORD FOLLOW_ifExpr_in_conditionalIfExpr1245_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET FOLLOW_ifExpr_in_conditionalIfExpr1245	= { FOLLOW_ifExpr_in_conditionalIfExpr1245_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RIGHT_PAREN_in_conditionalIfExpr1247  */
static	ANTLR3_BITWORD FOLLOW_RIGHT_PAREN_in_conditionalIfExpr1247_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100020) };
static  ANTLR3_BITSET FOLLOW_RIGHT_PAREN_in_conditionalIfExpr1247	= { FOLLOW_RIGHT_PAREN_in_conditionalIfExpr1247_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_endOfLineComment_in_conditionalIfExpr1257  */
static	ANTLR3_BITWORD FOLLOW_endOfLineComment_in_conditionalIfExpr1257_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET FOLLOW_endOfLineComment_in_conditionalIfExpr1257	= { FOLLOW_endOfLineComment_in_conditionalIfExpr1257_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEFT_BRACE_in_conditionalIfExpr1264  */
static	ANTLR3_BITWORD FOLLOW_LEFT_BRACE_in_conditionalIfExpr1264_bits[]	= { ANTLR3_UINT64_LIT(0x0003900400207470) };
static  ANTLR3_BITSET FOLLOW_LEFT_BRACE_in_conditionalIfExpr1264	= { FOLLOW_LEFT_BRACE_in_conditionalIfExpr1264_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_endOfLineComment_in_conditionalIfExpr1268  */
static	ANTLR3_BITWORD FOLLOW_endOfLineComment_in_conditionalIfExpr1268_bits[]	= { ANTLR3_UINT64_LIT(0x0003900400207450) };
static  ANTLR3_BITSET FOLLOW_endOfLineComment_in_conditionalIfExpr1268	= { FOLLOW_endOfLineComment_in_conditionalIfExpr1268_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_conditionalRules_in_conditionalIfExpr1277  */
static	ANTLR3_BITWORD FOLLOW_conditionalRules_in_conditionalIfExpr1277_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET FOLLOW_conditionalRules_in_conditionalIfExpr1277	= { FOLLOW_conditionalRules_in_conditionalIfExpr1277_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RIGHT_BRACE_in_conditionalIfExpr1283  */
static	ANTLR3_BITWORD FOLLOW_RIGHT_BRACE_in_conditionalIfExpr1283_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET FOLLOW_RIGHT_BRACE_in_conditionalIfExpr1283	= { FOLLOW_RIGHT_BRACE_in_conditionalIfExpr1283_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_endOfLineComment_in_conditionalIfExpr1287  */
static	ANTLR3_BITWORD FOLLOW_endOfLineComment_in_conditionalIfExpr1287_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_endOfLineComment_in_conditionalIfExpr1287	= { FOLLOW_endOfLineComment_in_conditionalIfExpr1287_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_46_in_conditionalElseExpr1312  */
static	ANTLR3_BITWORD FOLLOW_46_in_conditionalElseExpr1312_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100020) };
static  ANTLR3_BITSET FOLLOW_46_in_conditionalElseExpr1312	= { FOLLOW_46_in_conditionalElseExpr1312_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_endOfLineComment_in_conditionalElseExpr1316  */
static	ANTLR3_BITWORD FOLLOW_endOfLineComment_in_conditionalElseExpr1316_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET FOLLOW_endOfLineComment_in_conditionalElseExpr1316	= { FOLLOW_endOfLineComment_in_conditionalElseExpr1316_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEFT_BRACE_in_conditionalElseExpr1322  */
static	ANTLR3_BITWORD FOLLOW_LEFT_BRACE_in_conditionalElseExpr1322_bits[]	= { ANTLR3_UINT64_LIT(0x0003900400207470) };
static  ANTLR3_BITSET FOLLOW_LEFT_BRACE_in_conditionalElseExpr1322	= { FOLLOW_LEFT_BRACE_in_conditionalElseExpr1322_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_endOfLineComment_in_conditionalElseExpr1327  */
static	ANTLR3_BITWORD FOLLOW_endOfLineComment_in_conditionalElseExpr1327_bits[]	= { ANTLR3_UINT64_LIT(0x0003900400207450) };
static  ANTLR3_BITSET FOLLOW_endOfLineComment_in_conditionalElseExpr1327	= { FOLLOW_endOfLineComment_in_conditionalElseExpr1327_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_conditionalRules_in_conditionalElseExpr1336  */
static	ANTLR3_BITWORD FOLLOW_conditionalRules_in_conditionalElseExpr1336_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET FOLLOW_conditionalRules_in_conditionalElseExpr1336	= { FOLLOW_conditionalRules_in_conditionalElseExpr1336_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RIGHT_BRACE_in_conditionalElseExpr1342  */
static	ANTLR3_BITWORD FOLLOW_RIGHT_BRACE_in_conditionalElseExpr1342_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET FOLLOW_RIGHT_BRACE_in_conditionalElseExpr1342	= { FOLLOW_RIGHT_BRACE_in_conditionalElseExpr1342_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_endOfLineComment_in_conditionalElseExpr1346  */
static	ANTLR3_BITWORD FOLLOW_endOfLineComment_in_conditionalElseExpr1346_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_endOfLineComment_in_conditionalElseExpr1346	= { FOLLOW_endOfLineComment_in_conditionalElseExpr1346_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_newlineRule_in_conditionalRules1374  */
static	ANTLR3_BITWORD FOLLOW_newlineRule_in_conditionalRules1374_bits[]	= { ANTLR3_UINT64_LIT(0x0003900400203452) };
static  ANTLR3_BITSET FOLLOW_newlineRule_in_conditionalRules1374	= { FOLLOW_newlineRule_in_conditionalRules1374_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_startOfLineComment_in_conditionalRules1379  */
static	ANTLR3_BITWORD FOLLOW_startOfLineComment_in_conditionalRules1379_bits[]	= { ANTLR3_UINT64_LIT(0x0003900400203452) };
static  ANTLR3_BITSET FOLLOW_startOfLineComment_in_conditionalRules1379	= { FOLLOW_startOfLineComment_in_conditionalRules1379_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_accessRule_in_conditionalRules1388  */
static	ANTLR3_BITWORD FOLLOW_accessRule_in_conditionalRules1388_bits[]	= { ANTLR3_UINT64_LIT(0x0003900400203452) };
static  ANTLR3_BITSET FOLLOW_accessRule_in_conditionalRules1388	= { FOLLOW_accessRule_in_conditionalRules1388_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_capabilityRule_in_conditionalRules1397  */
static	ANTLR3_BITWORD FOLLOW_capabilityRule_in_conditionalRules1397_bits[]	= { ANTLR3_UINT64_LIT(0x0003900400203452) };
static  ANTLR3_BITSET FOLLOW_capabilityRule_in_conditionalRules1397	= { FOLLOW_capabilityRule_in_conditionalRules1397_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_auditRule_in_conditionalRules1406  */
static	ANTLR3_BITWORD FOLLOW_auditRule_in_conditionalRules1406_bits[]	= { ANTLR3_UINT64_LIT(0x0003900400203452) };
static  ANTLR3_BITSET FOLLOW_auditRule_in_conditionalRules1406	= { FOLLOW_auditRule_in_conditionalRules1406_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_builtInFunctions_in_conditionalRules1415  */
static	ANTLR3_BITWORD FOLLOW_builtInFunctions_in_conditionalRules1415_bits[]	= { ANTLR3_UINT64_LIT(0x0003900400203452) };
static  ANTLR3_BITSET FOLLOW_builtInFunctions_in_conditionalRules1415	= { FOLLOW_builtInFunctions_in_conditionalRules1415_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_47_in_builtInFunctions1450  */
static	ANTLR3_BITWORD FOLLOW_47_in_builtInFunctions1450_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET FOLLOW_47_in_builtInFunctions1450	= { FOLLOW_47_in_builtInFunctions1450_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEFT_PAREN_in_builtInFunctions1452  */
static	ANTLR3_BITWORD FOLLOW_LEFT_PAREN_in_builtInFunctions1452_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET FOLLOW_LEFT_PAREN_in_builtInFunctions1452	= { FOLLOW_LEFT_PAREN_in_builtInFunctions1452_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_QUOTED_STRING_in_builtInFunctions1456  */
static	ANTLR3_BITWORD FOLLOW_QUOTED_STRING_in_builtInFunctions1456_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET FOLLOW_QUOTED_STRING_in_builtInFunctions1456	= { FOLLOW_QUOTED_STRING_in_builtInFunctions1456_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RIGHT_PAREN_in_builtInFunctions1458  */
static	ANTLR3_BITWORD FOLLOW_RIGHT_PAREN_in_builtInFunctions1458_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET FOLLOW_RIGHT_PAREN_in_builtInFunctions1458	= { FOLLOW_RIGHT_PAREN_in_builtInFunctions1458_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_48_in_builtInFunctions1467  */
static	ANTLR3_BITWORD FOLLOW_48_in_builtInFunctions1467_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET FOLLOW_48_in_builtInFunctions1467	= { FOLLOW_48_in_builtInFunctions1467_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEFT_PAREN_in_builtInFunctions1469  */
static	ANTLR3_BITWORD FOLLOW_LEFT_PAREN_in_builtInFunctions1469_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET FOLLOW_LEFT_PAREN_in_builtInFunctions1469	= { FOLLOW_LEFT_PAREN_in_builtInFunctions1469_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LIST_VAR_START_in_builtInFunctions1471  */
static	ANTLR3_BITWORD FOLLOW_LIST_VAR_START_in_builtInFunctions1471_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET FOLLOW_LIST_VAR_START_in_builtInFunctions1471	= { FOLLOW_LIST_VAR_START_in_builtInFunctions1471_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_builtInFunctions1475  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_builtInFunctions1475_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET FOLLOW_IDENT_in_builtInFunctions1475	= { FOLLOW_IDENT_in_builtInFunctions1475_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RIGHT_BRACE_in_builtInFunctions1477  */
static	ANTLR3_BITWORD FOLLOW_RIGHT_BRACE_in_builtInFunctions1477_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET FOLLOW_RIGHT_BRACE_in_builtInFunctions1477	= { FOLLOW_RIGHT_BRACE_in_builtInFunctions1477_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RIGHT_PAREN_in_builtInFunctions1479  */
static	ANTLR3_BITWORD FOLLOW_RIGHT_PAREN_in_builtInFunctions1479_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET FOLLOW_RIGHT_PAREN_in_builtInFunctions1479	= { FOLLOW_RIGHT_PAREN_in_builtInFunctions1479_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_49_in_builtInFunctions1488  */
static	ANTLR3_BITWORD FOLLOW_49_in_builtInFunctions1488_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET FOLLOW_49_in_builtInFunctions1488	= { FOLLOW_49_in_builtInFunctions1488_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEFT_PAREN_in_builtInFunctions1490  */
static	ANTLR3_BITWORD FOLLOW_LEFT_PAREN_in_builtInFunctions1490_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET FOLLOW_LEFT_PAREN_in_builtInFunctions1490	= { FOLLOW_LEFT_PAREN_in_builtInFunctions1490_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_QUOTED_STRING_in_builtInFunctions1495  */
static	ANTLR3_BITWORD FOLLOW_QUOTED_STRING_in_builtInFunctions1495_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET FOLLOW_QUOTED_STRING_in_builtInFunctions1495	= { FOLLOW_QUOTED_STRING_in_builtInFunctions1495_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RIGHT_PAREN_in_builtInFunctions1497  */
static	ANTLR3_BITWORD FOLLOW_RIGHT_PAREN_in_builtInFunctions1497_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET FOLLOW_RIGHT_PAREN_in_builtInFunctions1497	= { FOLLOW_RIGHT_PAREN_in_builtInFunctions1497_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_endOfLineComment_in_builtInFunctions1512  */
static	ANTLR3_BITWORD FOLLOW_endOfLineComment_in_builtInFunctions1512_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_endOfLineComment_in_builtInFunctions1512	= { FOLLOW_endOfLineComment_in_builtInFunctions1512_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_50_in_ifExpr1541  */
static	ANTLR3_BITWORD FOLLOW_50_in_ifExpr1541_bits[]	= { ANTLR3_UINT64_LIT(0x0018000000020000) };
static  ANTLR3_BITSET FOLLOW_50_in_ifExpr1541	= { FOLLOW_50_in_ifExpr1541_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_variableOrFunction_in_ifExpr1554  */
static	ANTLR3_BITWORD FOLLOW_variableOrFunction_in_ifExpr1554_bits[]	= { ANTLR3_UINT64_LIT(0x0060000000000002) };
static  ANTLR3_BITSET FOLLOW_variableOrFunction_in_ifExpr1554	= { FOLLOW_variableOrFunction_in_ifExpr1554_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_andNotExpr_in_ifExpr1564  */
static	ANTLR3_BITWORD FOLLOW_andNotExpr_in_ifExpr1564_bits[]	= { ANTLR3_UINT64_LIT(0x0060000000000002) };
static  ANTLR3_BITSET FOLLOW_andNotExpr_in_ifExpr1564	= { FOLLOW_andNotExpr_in_ifExpr1564_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BOOL_VAR_START_in_variableOrFunction1596  */
static	ANTLR3_BITWORD FOLLOW_BOOL_VAR_START_in_variableOrFunction1596_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET FOLLOW_BOOL_VAR_START_in_variableOrFunction1596	= { FOLLOW_BOOL_VAR_START_in_variableOrFunction1596_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_variableOrFunction1600  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_variableOrFunction1600_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET FOLLOW_IDENT_in_variableOrFunction1600	= { FOLLOW_IDENT_in_variableOrFunction1600_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RIGHT_BRACE_in_variableOrFunction1602  */
static	ANTLR3_BITWORD FOLLOW_RIGHT_BRACE_in_variableOrFunction1602_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_RIGHT_BRACE_in_variableOrFunction1602	= { FOLLOW_RIGHT_BRACE_in_variableOrFunction1602_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_51_in_variableOrFunction1610  */
static	ANTLR3_BITWORD FOLLOW_51_in_variableOrFunction1610_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET FOLLOW_51_in_variableOrFunction1610	= { FOLLOW_51_in_variableOrFunction1610_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEFT_PAREN_in_variableOrFunction1612  */
static	ANTLR3_BITWORD FOLLOW_LEFT_PAREN_in_variableOrFunction1612_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001400) };
static  ANTLR3_BITSET FOLLOW_LEFT_PAREN_in_variableOrFunction1612	= { FOLLOW_LEFT_PAREN_in_variableOrFunction1612_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_QUOTED_STRING_in_variableOrFunction1617  */
static	ANTLR3_BITWORD FOLLOW_QUOTED_STRING_in_variableOrFunction1617_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET FOLLOW_QUOTED_STRING_in_variableOrFunction1617	= { FOLLOW_QUOTED_STRING_in_variableOrFunction1617_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UNQUOTED_PATH_in_variableOrFunction1621  */
static	ANTLR3_BITWORD FOLLOW_UNQUOTED_PATH_in_variableOrFunction1621_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET FOLLOW_UNQUOTED_PATH_in_variableOrFunction1621	= { FOLLOW_UNQUOTED_PATH_in_variableOrFunction1621_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RIGHT_PAREN_in_variableOrFunction1624  */
static	ANTLR3_BITWORD FOLLOW_RIGHT_PAREN_in_variableOrFunction1624_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_RIGHT_PAREN_in_variableOrFunction1624	= { FOLLOW_RIGHT_PAREN_in_variableOrFunction1624_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_52_in_variableOrFunction1638  */
static	ANTLR3_BITWORD FOLLOW_52_in_variableOrFunction1638_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET FOLLOW_52_in_variableOrFunction1638	= { FOLLOW_52_in_variableOrFunction1638_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEFT_PAREN_in_variableOrFunction1640  */
static	ANTLR3_BITWORD FOLLOW_LEFT_PAREN_in_variableOrFunction1640_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000022000) };
static  ANTLR3_BITSET FOLLOW_LEFT_PAREN_in_variableOrFunction1640	= { FOLLOW_LEFT_PAREN_in_variableOrFunction1640_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LIST_VAR_START_in_variableOrFunction1649  */
static	ANTLR3_BITWORD FOLLOW_LIST_VAR_START_in_variableOrFunction1649_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET FOLLOW_LIST_VAR_START_in_variableOrFunction1649	= { FOLLOW_LIST_VAR_START_in_variableOrFunction1649_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_variableOrFunction1653  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_variableOrFunction1653_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET FOLLOW_IDENT_in_variableOrFunction1653	= { FOLLOW_IDENT_in_variableOrFunction1653_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BOOL_VAR_START_in_variableOrFunction1663  */
static	ANTLR3_BITWORD FOLLOW_BOOL_VAR_START_in_variableOrFunction1663_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET FOLLOW_BOOL_VAR_START_in_variableOrFunction1663	= { FOLLOW_BOOL_VAR_START_in_variableOrFunction1663_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_variableOrFunction1667  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_variableOrFunction1667_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET FOLLOW_IDENT_in_variableOrFunction1667	= { FOLLOW_IDENT_in_variableOrFunction1667_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RIGHT_BRACE_in_variableOrFunction1679  */
static	ANTLR3_BITWORD FOLLOW_RIGHT_BRACE_in_variableOrFunction1679_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET FOLLOW_RIGHT_BRACE_in_variableOrFunction1679	= { FOLLOW_RIGHT_BRACE_in_variableOrFunction1679_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RIGHT_PAREN_in_variableOrFunction1681  */
static	ANTLR3_BITWORD FOLLOW_RIGHT_PAREN_in_variableOrFunction1681_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_RIGHT_PAREN_in_variableOrFunction1681	= { FOLLOW_RIGHT_PAREN_in_variableOrFunction1681_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_53_in_andNotExpr1711  */
static	ANTLR3_BITWORD FOLLOW_53_in_andNotExpr1711_bits[]	= { ANTLR3_UINT64_LIT(0x001C000000020000) };
static  ANTLR3_BITSET FOLLOW_53_in_andNotExpr1711	= { FOLLOW_53_in_andNotExpr1711_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_50_in_andNotExpr1714  */
static	ANTLR3_BITWORD FOLLOW_50_in_andNotExpr1714_bits[]	= { ANTLR3_UINT64_LIT(0x0018000000020000) };
static  ANTLR3_BITSET FOLLOW_50_in_andNotExpr1714	= { FOLLOW_50_in_andNotExpr1714_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_variableOrFunction_in_andNotExpr1723  */
static	ANTLR3_BITWORD FOLLOW_variableOrFunction_in_andNotExpr1723_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_variableOrFunction_in_andNotExpr1723	= { FOLLOW_variableOrFunction_in_andNotExpr1723_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_andNotExpr1733  */
static	ANTLR3_BITWORD FOLLOW_54_in_andNotExpr1733_bits[]	= { ANTLR3_UINT64_LIT(0x001C000000020000) };
static  ANTLR3_BITSET FOLLOW_54_in_andNotExpr1733	= { FOLLOW_54_in_andNotExpr1733_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_50_in_andNotExpr1736  */
static	ANTLR3_BITWORD FOLLOW_50_in_andNotExpr1736_bits[]	= { ANTLR3_UINT64_LIT(0x0018000000020000) };
static  ANTLR3_BITSET FOLLOW_50_in_andNotExpr1736	= { FOLLOW_50_in_andNotExpr1736_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_variableOrFunction_in_andNotExpr1745  */
static	ANTLR3_BITWORD FOLLOW_variableOrFunction_in_andNotExpr1745_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_variableOrFunction_in_andNotExpr1745	= { FOLLOW_variableOrFunction_in_andNotExpr1745_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_55_in_networkRule1777  */
static	ANTLR3_BITWORD FOLLOW_55_in_networkRule1777_bits[]	= { ANTLR3_UINT64_LIT(0xFF00040000000000), ANTLR3_UINT64_LIT(0x00000003FF7FFFFF) };
static  ANTLR3_BITSET FOLLOW_55_in_networkRule1777	= { FOLLOW_55_in_networkRule1777_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_domainRule_in_networkRule1787  */
static	ANTLR3_BITWORD FOLLOW_domainRule_in_networkRule1787_bits[]	= { ANTLR3_UINT64_LIT(0x0100040000000000), ANTLR3_UINT64_LIT(0x00000003FF7FE000) };
static  ANTLR3_BITSET FOLLOW_domainRule_in_networkRule1787	= { FOLLOW_domainRule_in_networkRule1787_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typeRule_in_networkRule1801  */
static	ANTLR3_BITWORD FOLLOW_typeRule_in_networkRule1801_bits[]	= { ANTLR3_UINT64_LIT(0x0100040000000000), ANTLR3_UINT64_LIT(0x00000003FF7C0000) };
static  ANTLR3_BITSET FOLLOW_typeRule_in_networkRule1801	= { FOLLOW_typeRule_in_networkRule1801_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_protocolRule_in_networkRule1815  */
static	ANTLR3_BITWORD FOLLOW_protocolRule_in_networkRule1815_bits[]	= { ANTLR3_UINT64_LIT(0x0100040000000000), ANTLR3_UINT64_LIT(0x00000003FF000000) };
static  ANTLR3_BITSET FOLLOW_protocolRule_in_networkRule1815	= { FOLLOW_protocolRule_in_networkRule1815_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_networkActionRule_in_networkRule1829  */
static	ANTLR3_BITWORD FOLLOW_networkActionRule_in_networkRule1829_bits[]	= { ANTLR3_UINT64_LIT(0x0100040000000000), ANTLR3_UINT64_LIT(0x00000003E0000000) };
static  ANTLR3_BITSET FOLLOW_networkActionRule_in_networkRule1829	= { FOLLOW_networkActionRule_in_networkRule1829_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_networkHostRule_in_networkRule1843  */
static	ANTLR3_BITWORD FOLLOW_networkHostRule_in_networkRule1843_bits[]	= { ANTLR3_UINT64_LIT(0x0100040000000000), ANTLR3_UINT64_LIT(0x00000003E0000000) };
static  ANTLR3_BITSET FOLLOW_networkHostRule_in_networkRule1843	= { FOLLOW_networkHostRule_in_networkRule1843_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_networkHostRule_in_networkRule1855  */
static	ANTLR3_BITWORD FOLLOW_networkHostRule_in_networkRule1855_bits[]	= { ANTLR3_UINT64_LIT(0x0100040000000000), ANTLR3_UINT64_LIT(0x0000000300000000) };
static  ANTLR3_BITSET FOLLOW_networkHostRule_in_networkRule1855	= { FOLLOW_networkHostRule_in_networkRule1855_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ifaceRule_in_networkRule1876  */
static	ANTLR3_BITWORD FOLLOW_ifaceRule_in_networkRule1876_bits[]	= { ANTLR3_UINT64_LIT(0x0100040000000000), ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET FOLLOW_ifaceRule_in_networkRule1876	= { FOLLOW_ifaceRule_in_networkRule1876_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_limitRule_in_networkRule1891  */
static	ANTLR3_BITWORD FOLLOW_limitRule_in_networkRule1891_bits[]	= { ANTLR3_UINT64_LIT(0x0100040000000000) };
static  ANTLR3_BITSET FOLLOW_limitRule_in_networkRule1891	= { FOLLOW_limitRule_in_networkRule1891_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_networkRule1903  */
static	ANTLR3_BITWORD FOLLOW_56_in_networkRule1903_bits[]	= { ANTLR3_UINT64_LIT(0x0000040000000000) };
static  ANTLR3_BITSET FOLLOW_56_in_networkRule1903	= { FOLLOW_56_in_networkRule1903_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_42_in_networkRule1910  */
static	ANTLR3_BITWORD FOLLOW_42_in_networkRule1910_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET FOLLOW_42_in_networkRule1910	= { FOLLOW_42_in_networkRule1910_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_endOfLineComment_in_networkRule1915  */
static	ANTLR3_BITWORD FOLLOW_endOfLineComment_in_networkRule1915_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_endOfLineComment_in_networkRule1915	= { FOLLOW_endOfLineComment_in_networkRule1915_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_57_in_domainRule1949  */
static	ANTLR3_BITWORD FOLLOW_57_in_domainRule1949_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_57_in_domainRule1949	= { FOLLOW_57_in_domainRule1949_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_58_in_domainRule1956  */
static	ANTLR3_BITWORD FOLLOW_58_in_domainRule1956_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_58_in_domainRule1956	= { FOLLOW_58_in_domainRule1956_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_59_in_domainRule1967  */
static	ANTLR3_BITWORD FOLLOW_59_in_domainRule1967_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_59_in_domainRule1967	= { FOLLOW_59_in_domainRule1967_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_60_in_domainRule1974  */
static	ANTLR3_BITWORD FOLLOW_60_in_domainRule1974_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_60_in_domainRule1974	= { FOLLOW_60_in_domainRule1974_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_61_in_domainRule1981  */
static	ANTLR3_BITWORD FOLLOW_61_in_domainRule1981_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_61_in_domainRule1981	= { FOLLOW_61_in_domainRule1981_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_62_in_domainRule1988  */
static	ANTLR3_BITWORD FOLLOW_62_in_domainRule1988_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_62_in_domainRule1988	= { FOLLOW_62_in_domainRule1988_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_63_in_domainRule1995  */
static	ANTLR3_BITWORD FOLLOW_63_in_domainRule1995_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_63_in_domainRule1995	= { FOLLOW_63_in_domainRule1995_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_64_in_domainRule2002  */
static	ANTLR3_BITWORD FOLLOW_64_in_domainRule2002_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_64_in_domainRule2002	= { FOLLOW_64_in_domainRule2002_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_65_in_domainRule2009  */
static	ANTLR3_BITWORD FOLLOW_65_in_domainRule2009_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_65_in_domainRule2009	= { FOLLOW_65_in_domainRule2009_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_66_in_domainRule2016  */
static	ANTLR3_BITWORD FOLLOW_66_in_domainRule2016_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_66_in_domainRule2016	= { FOLLOW_66_in_domainRule2016_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_67_in_domainRule2023  */
static	ANTLR3_BITWORD FOLLOW_67_in_domainRule2023_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_67_in_domainRule2023	= { FOLLOW_67_in_domainRule2023_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_68_in_domainRule2030  */
static	ANTLR3_BITWORD FOLLOW_68_in_domainRule2030_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_68_in_domainRule2030	= { FOLLOW_68_in_domainRule2030_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_69_in_domainRule2044  */
static	ANTLR3_BITWORD FOLLOW_69_in_domainRule2044_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_69_in_domainRule2044	= { FOLLOW_69_in_domainRule2044_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_70_in_domainRule2051  */
static	ANTLR3_BITWORD FOLLOW_70_in_domainRule2051_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_70_in_domainRule2051	= { FOLLOW_70_in_domainRule2051_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_71_in_domainRule2058  */
static	ANTLR3_BITWORD FOLLOW_71_in_domainRule2058_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_71_in_domainRule2058	= { FOLLOW_71_in_domainRule2058_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_72_in_domainRule2065  */
static	ANTLR3_BITWORD FOLLOW_72_in_domainRule2065_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_72_in_domainRule2065	= { FOLLOW_72_in_domainRule2065_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_73_in_domainRule2072  */
static	ANTLR3_BITWORD FOLLOW_73_in_domainRule2072_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_73_in_domainRule2072	= { FOLLOW_73_in_domainRule2072_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_74_in_domainRule2079  */
static	ANTLR3_BITWORD FOLLOW_74_in_domainRule2079_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_74_in_domainRule2079	= { FOLLOW_74_in_domainRule2079_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_75_in_domainRule2086  */
static	ANTLR3_BITWORD FOLLOW_75_in_domainRule2086_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_75_in_domainRule2086	= { FOLLOW_75_in_domainRule2086_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_76_in_domainRule2100  */
static	ANTLR3_BITWORD FOLLOW_76_in_domainRule2100_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_76_in_domainRule2100	= { FOLLOW_76_in_domainRule2100_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_77_in_typeRule2130  */
static	ANTLR3_BITWORD FOLLOW_77_in_typeRule2130_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_77_in_typeRule2130	= { FOLLOW_77_in_typeRule2130_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_78_in_typeRule2137  */
static	ANTLR3_BITWORD FOLLOW_78_in_typeRule2137_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_78_in_typeRule2137	= { FOLLOW_78_in_typeRule2137_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_79_in_typeRule2144  */
static	ANTLR3_BITWORD FOLLOW_79_in_typeRule2144_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_79_in_typeRule2144	= { FOLLOW_79_in_typeRule2144_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_80_in_typeRule2151  */
static	ANTLR3_BITWORD FOLLOW_80_in_typeRule2151_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_80_in_typeRule2151	= { FOLLOW_80_in_typeRule2151_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_81_in_typeRule2158  */
static	ANTLR3_BITWORD FOLLOW_81_in_typeRule2158_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_81_in_typeRule2158	= { FOLLOW_81_in_typeRule2158_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_82_in_protocolRule2193  */
static	ANTLR3_BITWORD FOLLOW_82_in_protocolRule2193_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_82_in_protocolRule2193	= { FOLLOW_82_in_protocolRule2193_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_83_in_protocolRule2200  */
static	ANTLR3_BITWORD FOLLOW_83_in_protocolRule2200_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_83_in_protocolRule2200	= { FOLLOW_83_in_protocolRule2200_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_84_in_protocolRule2207  */
static	ANTLR3_BITWORD FOLLOW_84_in_protocolRule2207_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_84_in_protocolRule2207	= { FOLLOW_84_in_protocolRule2207_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_85_in_protocolRule2214  */
static	ANTLR3_BITWORD FOLLOW_85_in_protocolRule2214_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_85_in_protocolRule2214	= { FOLLOW_85_in_protocolRule2214_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_86_in_protocolRule2221  */
static	ANTLR3_BITWORD FOLLOW_86_in_protocolRule2221_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_86_in_protocolRule2221	= { FOLLOW_86_in_protocolRule2221_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tcpRule_in_networkActionRule2252  */
static	ANTLR3_BITWORD FOLLOW_tcpRule_in_networkActionRule2252_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_tcpRule_in_networkActionRule2252	= { FOLLOW_tcpRule_in_networkActionRule2252_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_udpRule_in_networkActionRule2263  */
static	ANTLR3_BITWORD FOLLOW_udpRule_in_networkActionRule2263_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET FOLLOW_udpRule_in_networkActionRule2263	= { FOLLOW_udpRule_in_networkActionRule2263_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_87_in_networkActionRule2274  */
static	ANTLR3_BITWORD FOLLOW_87_in_networkActionRule2274_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000018000000) };
static  ANTLR3_BITSET FOLLOW_87_in_networkActionRule2274	= { FOLLOW_87_in_networkActionRule2274_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_udpRule_in_networkActionRule2278  */
static	ANTLR3_BITWORD FOLLOW_udpRule_in_networkActionRule2278_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_udpRule_in_networkActionRule2278	= { FOLLOW_udpRule_in_networkActionRule2278_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_88_in_tcpRule2316  */
static	ANTLR3_BITWORD FOLLOW_88_in_tcpRule2316_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_88_in_tcpRule2316	= { FOLLOW_88_in_tcpRule2316_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_89_in_tcpRule2323  */
static	ANTLR3_BITWORD FOLLOW_89_in_tcpRule2323_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_89_in_tcpRule2323	= { FOLLOW_89_in_tcpRule2323_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_90_in_tcpRule2330  */
static	ANTLR3_BITWORD FOLLOW_90_in_tcpRule2330_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_90_in_tcpRule2330	= { FOLLOW_90_in_tcpRule2330_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_91_in_udpRule2361  */
static	ANTLR3_BITWORD FOLLOW_91_in_udpRule2361_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_91_in_udpRule2361	= { FOLLOW_91_in_udpRule2361_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_92_in_udpRule2368  */
static	ANTLR3_BITWORD FOLLOW_92_in_udpRule2368_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_92_in_udpRule2368	= { FOLLOW_92_in_udpRule2368_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_93_in_networkHostRule2399  */
static	ANTLR3_BITWORD FOLLOW_93_in_networkHostRule2399_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET FOLLOW_93_in_networkHostRule2399	= { FOLLOW_93_in_networkHostRule2399_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_94_in_networkHostRule2406  */
static	ANTLR3_BITWORD FOLLOW_94_in_networkHostRule2406_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET FOLLOW_94_in_networkHostRule2406	= { FOLLOW_94_in_networkHostRule2406_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_95_in_networkHostRule2413  */
static	ANTLR3_BITWORD FOLLOW_95_in_networkHostRule2413_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET FOLLOW_95_in_networkHostRule2413	= { FOLLOW_95_in_networkHostRule2413_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ipRule_in_networkHostRule2420  */
static	ANTLR3_BITWORD FOLLOW_ipRule_in_networkHostRule2420_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_ipRule_in_networkHostRule2420	= { FOLLOW_ipRule_in_networkHostRule2420_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_ipRule2449  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_ipRule2449_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_IDENT_in_ipRule2449	= { FOLLOW_IDENT_in_ipRule2449_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_96_in_ifaceRule2473  */
static	ANTLR3_BITWORD FOLLOW_96_in_ifaceRule2473_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET FOLLOW_96_in_ifaceRule2473	= { FOLLOW_96_in_ifaceRule2473_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_ifaceRule2477  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_ifaceRule2477_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_IDENT_in_ifaceRule2477	= { FOLLOW_IDENT_in_ifaceRule2477_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_97_in_limitRule2500  */
static	ANTLR3_BITWORD FOLLOW_97_in_limitRule2500_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET FOLLOW_97_in_limitRule2500	= { FOLLOW_97_in_limitRule2500_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_limitRule2504  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_limitRule2504_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET FOLLOW_IDENT_in_limitRule2504	= { FOLLOW_IDENT_in_limitRule2504_bits, 1	};
     
/** Load up the static bitsets for following set for error recovery.
 *  \remark
 *  These are static after the parser is generated, hence they are static
 *  delcarations in the parser and are thread safe after initialization.
 */
static
void AppArmorParserLoadFollowSets()
{
    antlr3BitsetSetAPI(&FOLLOW_appArmorProfile_in_startParse101);
    antlr3BitsetSetAPI(&FOLLOW_EOF_in_startParse106);
    antlr3BitsetSetAPI(&FOLLOW_newlineRule_in_appArmorProfile122);
    antlr3BitsetSetAPI(&FOLLOW_includeExpr_in_appArmorProfile131);
    antlr3BitsetSetAPI(&FOLLOW_startOfLineComment_in_appArmorProfile142);
    antlr3BitsetSetAPI(&FOLLOW_optionExpr_in_appArmorProfile153);
    antlr3BitsetSetAPI(&FOLLOW_profileExpr_in_appArmorProfile164);
    antlr3BitsetSetAPI(&FOLLOW_variableAssign_in_appArmorProfile175);
    antlr3BitsetSetAPI(&FOLLOW_NEWLINE_in_newlineRule193);
    antlr3BitsetSetAPI(&FOLLOW_SOL_COMMENT_in_startOfLineComment211);
    antlr3BitsetSetAPI(&FOLLOW_EOL_COMMENT_in_endOfLineComment230);
    antlr3BitsetSetAPI(&FOLLOW_INCLUDE_in_includeExpr252);
    antlr3BitsetSetAPI(&FOLLOW_LESS_THAN_in_includeExpr255);
    antlr3BitsetSetAPI(&FOLLOW_IDENT_in_includeExpr260);
    antlr3BitsetSetAPI(&FOLLOW_UNQUOTED_PATH_in_includeExpr264);
    antlr3BitsetSetAPI(&FOLLOW_GREATER_THAN_in_includeExpr267);
    antlr3BitsetSetAPI(&FOLLOW_QUOTED_STRING_in_includeExpr274);
    antlr3BitsetSetAPI(&FOLLOW_endOfLineComment_in_includeExpr280);
    antlr3BitsetSetAPI(&FOLLOW_LIST_VAR_START_in_variableAssign309);
    antlr3BitsetSetAPI(&FOLLOW_IDENT_in_variableAssign313);
    antlr3BitsetSetAPI(&FOLLOW_RIGHT_BRACE_in_variableAssign315);
    antlr3BitsetSetAPI(&FOLLOW_PLUS_in_variableAssign325);
    antlr3BitsetSetAPI(&FOLLOW_EQUALS_in_variableAssign333);
    antlr3BitsetSetAPI(&FOLLOW_IDENT_in_variableAssign350);
    antlr3BitsetSetAPI(&FOLLOW_QUOTED_STRING_in_variableAssign354);
    antlr3BitsetSetAPI(&FOLLOW_UNQUOTED_PATH_in_variableAssign358);
    antlr3BitsetSetAPI(&FOLLOW_LIST_VAR_START_in_variableAssign367);
    antlr3BitsetSetAPI(&FOLLOW_IDENT_in_variableAssign371);
    antlr3BitsetSetAPI(&FOLLOW_RIGHT_BRACE_in_variableAssign373);
    antlr3BitsetSetAPI(&FOLLOW_BOOL_VAR_START_in_variableAssign389);
    antlr3BitsetSetAPI(&FOLLOW_IDENT_in_variableAssign393);
    antlr3BitsetSetAPI(&FOLLOW_RIGHT_BRACE_in_variableAssign395);
    antlr3BitsetSetAPI(&FOLLOW_EQUALS_in_variableAssign403);
    antlr3BitsetSetAPI(&FOLLOW_32_in_variableAssign409);
    antlr3BitsetSetAPI(&FOLLOW_33_in_variableAssign419);
    antlr3BitsetSetAPI(&FOLLOW_NEWLINE_in_variableAssign438);
    antlr3BitsetSetAPI(&FOLLOW_endOfLineComment_in_variableAssign442);
    antlr3BitsetSetAPI(&FOLLOW_34_in_optionExpr470);
    antlr3BitsetSetAPI(&FOLLOW_32_in_optionExpr473);
    antlr3BitsetSetAPI(&FOLLOW_33_in_optionExpr483);
    antlr3BitsetSetAPI(&FOLLOW_35_in_optionExpr495);
    antlr3BitsetSetAPI(&FOLLOW_IDENT_in_optionExpr500);
    antlr3BitsetSetAPI(&FOLLOW_QUOTED_STRING_in_optionExpr506);
    antlr3BitsetSetAPI(&FOLLOW_36_in_optionExpr515);
    antlr3BitsetSetAPI(&FOLLOW_IDENT_in_optionExpr520);
    antlr3BitsetSetAPI(&FOLLOW_QUOTED_STRING_in_optionExpr526);
    antlr3BitsetSetAPI(&FOLLOW_37_in_optionExpr535);
    antlr3BitsetSetAPI(&FOLLOW_32_in_optionExpr538);
    antlr3BitsetSetAPI(&FOLLOW_33_in_optionExpr550);
    antlr3BitsetSetAPI(&FOLLOW_38_in_optionExpr562);
    antlr3BitsetSetAPI(&FOLLOW_32_in_optionExpr565);
    antlr3BitsetSetAPI(&FOLLOW_33_in_optionExpr577);
    antlr3BitsetSetAPI(&FOLLOW_endOfLineComment_in_optionExpr593);
    antlr3BitsetSetAPI(&FOLLOW_UNQUOTED_PATH_in_profileExpr627);
    antlr3BitsetSetAPI(&FOLLOW_QUOTED_STRING_in_profileExpr631);
    antlr3BitsetSetAPI(&FOLLOW_39_in_profileExpr645);
    antlr3BitsetSetAPI(&FOLLOW_IDENT_in_profileExpr649);
    antlr3BitsetSetAPI(&FOLLOW_40_in_profileExpr673);
    antlr3BitsetSetAPI(&FOLLOW_EQUALS_in_profileExpr675);
    antlr3BitsetSetAPI(&FOLLOW_LEFT_PAREN_in_profileExpr679);
    antlr3BitsetSetAPI(&FOLLOW_38_in_profileExpr685);
    antlr3BitsetSetAPI(&FOLLOW_37_in_profileExpr693);
    antlr3BitsetSetAPI(&FOLLOW_34_in_profileExpr701);
    antlr3BitsetSetAPI(&FOLLOW_41_in_profileExpr709);
    antlr3BitsetSetAPI(&FOLLOW_RIGHT_PAREN_in_profileExpr717);
    antlr3BitsetSetAPI(&FOLLOW_endOfLineComment_in_profileExpr726);
    antlr3BitsetSetAPI(&FOLLOW_LEFT_BRACE_in_profileExpr733);
    antlr3BitsetSetAPI(&FOLLOW_endOfLineComment_in_profileExpr737);
    antlr3BitsetSetAPI(&FOLLOW_ruleExpr_in_profileExpr746);
    antlr3BitsetSetAPI(&FOLLOW_RIGHT_BRACE_in_profileExpr752);
    antlr3BitsetSetAPI(&FOLLOW_endOfLineComment_in_profileExpr756);
    antlr3BitsetSetAPI(&FOLLOW_newlineRule_in_ruleExpr785);
    antlr3BitsetSetAPI(&FOLLOW_startOfLineComment_in_ruleExpr790);
    antlr3BitsetSetAPI(&FOLLOW_includeExpr_in_ruleExpr795);
    antlr3BitsetSetAPI(&FOLLOW_accessRule_in_ruleExpr806);
    antlr3BitsetSetAPI(&FOLLOW_capabilityRule_in_ruleExpr817);
    antlr3BitsetSetAPI(&FOLLOW_auditRule_in_ruleExpr829);
    antlr3BitsetSetAPI(&FOLLOW_changeProfileRule_in_ruleExpr840);
    antlr3BitsetSetAPI(&FOLLOW_networkRule_in_ruleExpr851);
    antlr3BitsetSetAPI(&FOLLOW_conditionalIfExpr_in_ruleExpr866);
    antlr3BitsetSetAPI(&FOLLOW_conditionalElseExpr_in_ruleExpr881);
    antlr3BitsetSetAPI(&FOLLOW_accessPath_in_accessRule920);
    antlr3BitsetSetAPI(&FOLLOW_RULE_in_accessRule924);
    antlr3BitsetSetAPI(&FOLLOW_42_in_accessRule926);
    antlr3BitsetSetAPI(&FOLLOW_RULE_in_accessRule933);
    antlr3BitsetSetAPI(&FOLLOW_accessPath_in_accessRule937);
    antlr3BitsetSetAPI(&FOLLOW_42_in_accessRule939);
    antlr3BitsetSetAPI(&FOLLOW_endOfLineComment_in_accessRule949);
    antlr3BitsetSetAPI(&FOLLOW_QUOTED_STRING_in_accessPath979);
    antlr3BitsetSetAPI(&FOLLOW_LIST_VAR_START_in_accessPath990);
    antlr3BitsetSetAPI(&FOLLOW_IDENT_in_accessPath994);
    antlr3BitsetSetAPI(&FOLLOW_RIGHT_BRACE_in_accessPath996);
    antlr3BitsetSetAPI(&FOLLOW_UNQUOTED_PATH_in_accessPath1012);
    antlr3BitsetSetAPI(&FOLLOW_43_in_changeProfileRule1048);
    antlr3BitsetSetAPI(&FOLLOW_UNQUOTED_PATH_in_changeProfileRule1052);
    antlr3BitsetSetAPI(&FOLLOW_44_in_capabilityRule1078);
    antlr3BitsetSetAPI(&FOLLOW_capabilitiesSubExpr_in_capabilityRule1087);
    antlr3BitsetSetAPI(&FOLLOW_42_in_capabilityRule1096);
    antlr3BitsetSetAPI(&FOLLOW_endOfLineComment_in_capabilityRule1101);
    antlr3BitsetSetAPI(&FOLLOW_IDENT_in_capabilitiesSubExpr1132);
    antlr3BitsetSetAPI(&FOLLOW_QUOTED_STRING_in_capabilitiesSubExpr1138);
    antlr3BitsetSetAPI(&FOLLOW_34_in_auditRule1165);
    antlr3BitsetSetAPI(&FOLLOW_endOfLineComment_in_auditRule1169);
    antlr3BitsetSetAPI(&FOLLOW_LEFT_BRACE_in_auditRule1177);
    antlr3BitsetSetAPI(&FOLLOW_endOfLineComment_in_auditRule1181);
    antlr3BitsetSetAPI(&FOLLOW_accessRule_in_auditRule1192);
    antlr3BitsetSetAPI(&FOLLOW_RIGHT_BRACE_in_auditRule1204);
    antlr3BitsetSetAPI(&FOLLOW_endOfLineComment_in_auditRule1208);
    antlr3BitsetSetAPI(&FOLLOW_45_in_conditionalIfExpr1239);
    antlr3BitsetSetAPI(&FOLLOW_LEFT_PAREN_in_conditionalIfExpr1241);
    antlr3BitsetSetAPI(&FOLLOW_ifExpr_in_conditionalIfExpr1245);
    antlr3BitsetSetAPI(&FOLLOW_RIGHT_PAREN_in_conditionalIfExpr1247);
    antlr3BitsetSetAPI(&FOLLOW_endOfLineComment_in_conditionalIfExpr1257);
    antlr3BitsetSetAPI(&FOLLOW_LEFT_BRACE_in_conditionalIfExpr1264);
    antlr3BitsetSetAPI(&FOLLOW_endOfLineComment_in_conditionalIfExpr1268);
    antlr3BitsetSetAPI(&FOLLOW_conditionalRules_in_conditionalIfExpr1277);
    antlr3BitsetSetAPI(&FOLLOW_RIGHT_BRACE_in_conditionalIfExpr1283);
    antlr3BitsetSetAPI(&FOLLOW_endOfLineComment_in_conditionalIfExpr1287);
    antlr3BitsetSetAPI(&FOLLOW_46_in_conditionalElseExpr1312);
    antlr3BitsetSetAPI(&FOLLOW_endOfLineComment_in_conditionalElseExpr1316);
    antlr3BitsetSetAPI(&FOLLOW_LEFT_BRACE_in_conditionalElseExpr1322);
    antlr3BitsetSetAPI(&FOLLOW_endOfLineComment_in_conditionalElseExpr1327);
    antlr3BitsetSetAPI(&FOLLOW_conditionalRules_in_conditionalElseExpr1336);
    antlr3BitsetSetAPI(&FOLLOW_RIGHT_BRACE_in_conditionalElseExpr1342);
    antlr3BitsetSetAPI(&FOLLOW_endOfLineComment_in_conditionalElseExpr1346);
    antlr3BitsetSetAPI(&FOLLOW_newlineRule_in_conditionalRules1374);
    antlr3BitsetSetAPI(&FOLLOW_startOfLineComment_in_conditionalRules1379);
    antlr3BitsetSetAPI(&FOLLOW_accessRule_in_conditionalRules1388);
    antlr3BitsetSetAPI(&FOLLOW_capabilityRule_in_conditionalRules1397);
    antlr3BitsetSetAPI(&FOLLOW_auditRule_in_conditionalRules1406);
    antlr3BitsetSetAPI(&FOLLOW_builtInFunctions_in_conditionalRules1415);
    antlr3BitsetSetAPI(&FOLLOW_47_in_builtInFunctions1450);
    antlr3BitsetSetAPI(&FOLLOW_LEFT_PAREN_in_builtInFunctions1452);
    antlr3BitsetSetAPI(&FOLLOW_QUOTED_STRING_in_builtInFunctions1456);
    antlr3BitsetSetAPI(&FOLLOW_RIGHT_PAREN_in_builtInFunctions1458);
    antlr3BitsetSetAPI(&FOLLOW_48_in_builtInFunctions1467);
    antlr3BitsetSetAPI(&FOLLOW_LEFT_PAREN_in_builtInFunctions1469);
    antlr3BitsetSetAPI(&FOLLOW_LIST_VAR_START_in_builtInFunctions1471);
    antlr3BitsetSetAPI(&FOLLOW_IDENT_in_builtInFunctions1475);
    antlr3BitsetSetAPI(&FOLLOW_RIGHT_BRACE_in_builtInFunctions1477);
    antlr3BitsetSetAPI(&FOLLOW_RIGHT_PAREN_in_builtInFunctions1479);
    antlr3BitsetSetAPI(&FOLLOW_49_in_builtInFunctions1488);
    antlr3BitsetSetAPI(&FOLLOW_LEFT_PAREN_in_builtInFunctions1490);
    antlr3BitsetSetAPI(&FOLLOW_QUOTED_STRING_in_builtInFunctions1495);
    antlr3BitsetSetAPI(&FOLLOW_RIGHT_PAREN_in_builtInFunctions1497);
    antlr3BitsetSetAPI(&FOLLOW_endOfLineComment_in_builtInFunctions1512);
    antlr3BitsetSetAPI(&FOLLOW_50_in_ifExpr1541);
    antlr3BitsetSetAPI(&FOLLOW_variableOrFunction_in_ifExpr1554);
    antlr3BitsetSetAPI(&FOLLOW_andNotExpr_in_ifExpr1564);
    antlr3BitsetSetAPI(&FOLLOW_BOOL_VAR_START_in_variableOrFunction1596);
    antlr3BitsetSetAPI(&FOLLOW_IDENT_in_variableOrFunction1600);
    antlr3BitsetSetAPI(&FOLLOW_RIGHT_BRACE_in_variableOrFunction1602);
    antlr3BitsetSetAPI(&FOLLOW_51_in_variableOrFunction1610);
    antlr3BitsetSetAPI(&FOLLOW_LEFT_PAREN_in_variableOrFunction1612);
    antlr3BitsetSetAPI(&FOLLOW_QUOTED_STRING_in_variableOrFunction1617);
    antlr3BitsetSetAPI(&FOLLOW_UNQUOTED_PATH_in_variableOrFunction1621);
    antlr3BitsetSetAPI(&FOLLOW_RIGHT_PAREN_in_variableOrFunction1624);
    antlr3BitsetSetAPI(&FOLLOW_52_in_variableOrFunction1638);
    antlr3BitsetSetAPI(&FOLLOW_LEFT_PAREN_in_variableOrFunction1640);
    antlr3BitsetSetAPI(&FOLLOW_LIST_VAR_START_in_variableOrFunction1649);
    antlr3BitsetSetAPI(&FOLLOW_IDENT_in_variableOrFunction1653);
    antlr3BitsetSetAPI(&FOLLOW_BOOL_VAR_START_in_variableOrFunction1663);
    antlr3BitsetSetAPI(&FOLLOW_IDENT_in_variableOrFunction1667);
    antlr3BitsetSetAPI(&FOLLOW_RIGHT_BRACE_in_variableOrFunction1679);
    antlr3BitsetSetAPI(&FOLLOW_RIGHT_PAREN_in_variableOrFunction1681);
    antlr3BitsetSetAPI(&FOLLOW_53_in_andNotExpr1711);
    antlr3BitsetSetAPI(&FOLLOW_50_in_andNotExpr1714);
    antlr3BitsetSetAPI(&FOLLOW_variableOrFunction_in_andNotExpr1723);
    antlr3BitsetSetAPI(&FOLLOW_54_in_andNotExpr1733);
    antlr3BitsetSetAPI(&FOLLOW_50_in_andNotExpr1736);
    antlr3BitsetSetAPI(&FOLLOW_variableOrFunction_in_andNotExpr1745);
    antlr3BitsetSetAPI(&FOLLOW_55_in_networkRule1777);
    antlr3BitsetSetAPI(&FOLLOW_domainRule_in_networkRule1787);
    antlr3BitsetSetAPI(&FOLLOW_typeRule_in_networkRule1801);
    antlr3BitsetSetAPI(&FOLLOW_protocolRule_in_networkRule1815);
    antlr3BitsetSetAPI(&FOLLOW_networkActionRule_in_networkRule1829);
    antlr3BitsetSetAPI(&FOLLOW_networkHostRule_in_networkRule1843);
    antlr3BitsetSetAPI(&FOLLOW_networkHostRule_in_networkRule1855);
    antlr3BitsetSetAPI(&FOLLOW_ifaceRule_in_networkRule1876);
    antlr3BitsetSetAPI(&FOLLOW_limitRule_in_networkRule1891);
    antlr3BitsetSetAPI(&FOLLOW_56_in_networkRule1903);
    antlr3BitsetSetAPI(&FOLLOW_42_in_networkRule1910);
    antlr3BitsetSetAPI(&FOLLOW_endOfLineComment_in_networkRule1915);
    antlr3BitsetSetAPI(&FOLLOW_57_in_domainRule1949);
    antlr3BitsetSetAPI(&FOLLOW_58_in_domainRule1956);
    antlr3BitsetSetAPI(&FOLLOW_59_in_domainRule1967);
    antlr3BitsetSetAPI(&FOLLOW_60_in_domainRule1974);
    antlr3BitsetSetAPI(&FOLLOW_61_in_domainRule1981);
    antlr3BitsetSetAPI(&FOLLOW_62_in_domainRule1988);
    antlr3BitsetSetAPI(&FOLLOW_63_in_domainRule1995);
    antlr3BitsetSetAPI(&FOLLOW_64_in_domainRule2002);
    antlr3BitsetSetAPI(&FOLLOW_65_in_domainRule2009);
    antlr3BitsetSetAPI(&FOLLOW_66_in_domainRule2016);
    antlr3BitsetSetAPI(&FOLLOW_67_in_domainRule2023);
    antlr3BitsetSetAPI(&FOLLOW_68_in_domainRule2030);
    antlr3BitsetSetAPI(&FOLLOW_69_in_domainRule2044);
    antlr3BitsetSetAPI(&FOLLOW_70_in_domainRule2051);
    antlr3BitsetSetAPI(&FOLLOW_71_in_domainRule2058);
    antlr3BitsetSetAPI(&FOLLOW_72_in_domainRule2065);
    antlr3BitsetSetAPI(&FOLLOW_73_in_domainRule2072);
    antlr3BitsetSetAPI(&FOLLOW_74_in_domainRule2079);
    antlr3BitsetSetAPI(&FOLLOW_75_in_domainRule2086);
    antlr3BitsetSetAPI(&FOLLOW_76_in_domainRule2100);
    antlr3BitsetSetAPI(&FOLLOW_77_in_typeRule2130);
    antlr3BitsetSetAPI(&FOLLOW_78_in_typeRule2137);
    antlr3BitsetSetAPI(&FOLLOW_79_in_typeRule2144);
    antlr3BitsetSetAPI(&FOLLOW_80_in_typeRule2151);
    antlr3BitsetSetAPI(&FOLLOW_81_in_typeRule2158);
    antlr3BitsetSetAPI(&FOLLOW_82_in_protocolRule2193);
    antlr3BitsetSetAPI(&FOLLOW_83_in_protocolRule2200);
    antlr3BitsetSetAPI(&FOLLOW_84_in_protocolRule2207);
    antlr3BitsetSetAPI(&FOLLOW_85_in_protocolRule2214);
    antlr3BitsetSetAPI(&FOLLOW_86_in_protocolRule2221);
    antlr3BitsetSetAPI(&FOLLOW_tcpRule_in_networkActionRule2252);
    antlr3BitsetSetAPI(&FOLLOW_udpRule_in_networkActionRule2263);
    antlr3BitsetSetAPI(&FOLLOW_87_in_networkActionRule2274);
    antlr3BitsetSetAPI(&FOLLOW_udpRule_in_networkActionRule2278);
    antlr3BitsetSetAPI(&FOLLOW_88_in_tcpRule2316);
    antlr3BitsetSetAPI(&FOLLOW_89_in_tcpRule2323);
    antlr3BitsetSetAPI(&FOLLOW_90_in_tcpRule2330);
    antlr3BitsetSetAPI(&FOLLOW_91_in_udpRule2361);
    antlr3BitsetSetAPI(&FOLLOW_92_in_udpRule2368);
    antlr3BitsetSetAPI(&FOLLOW_93_in_networkHostRule2399);
    antlr3BitsetSetAPI(&FOLLOW_94_in_networkHostRule2406);
    antlr3BitsetSetAPI(&FOLLOW_95_in_networkHostRule2413);
    antlr3BitsetSetAPI(&FOLLOW_ipRule_in_networkHostRule2420);
    antlr3BitsetSetAPI(&FOLLOW_IDENT_in_ipRule2449);
    antlr3BitsetSetAPI(&FOLLOW_96_in_ifaceRule2473);
    antlr3BitsetSetAPI(&FOLLOW_IDENT_in_ifaceRule2477);
    antlr3BitsetSetAPI(&FOLLOW_97_in_limitRule2500);
    antlr3BitsetSetAPI(&FOLLOW_IDENT_in_limitRule2504);

    return;
}

 
 
/* ==============================================
 * Parsing rules
 */
/** 
 * $ANTLR start startParse
 * AppArmor.g:195:1: startParse returns [ParseNode *returnTree] : ( appArmorProfile )* EOF ;
 */
static ParseNode *
startParse(pAppArmorParser ctx)
{   
    ParseNode * returnTree = NULL;

    /* Initialize rule variables
     */


     
    		init_stream_vector();
    		File *topFileNode = new_file_node();
    		mpTree = new_parse_node(ELEMENT_FILE, NULL);
    		mpTree->pData = topFileNode;
    		mpTree->pVariableList = NULL;
    		returnTree= mpTree;
    		factory = antlr3StringFactoryNew();
    	
    {
        // AppArmor.g:205:2: ( ( appArmorProfile )* EOF )
        // AppArmor.g:206:2: ( appArmorProfile )* EOF
        {

            // AppArmor.g:206:2: ( appArmorProfile )*

            for (;;)
            {
                int alt1=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA1_0 = LA(1);
                    if ( (LA1_0 == SOL_COMMENT || ((LA1_0 >= NEWLINE) && (LA1_0 <= INCLUDE)) || LA1_0 == UNQUOTED_PATH || ((LA1_0 >= QUOTED_STRING) && (LA1_0 <= LIST_VAR_START)) || LA1_0 == BOOL_VAR_START || ((LA1_0 >= 34) && (LA1_0 <= 39))) ) 
                    {
                        alt1=1;
                    }

                }
                switch (alt1) 
                {
            	case 1:
            	    // AppArmor.g:206:4: appArmorProfile
            	    {
            	        FOLLOWPUSH(FOLLOW_appArmorProfile_in_startParse101);
            	        appArmorProfile(ctx);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestartParseEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop1;	/* break out of the loop */
            	    break;
                }
            }
            loop1: ; /* Jump out to here if this rule does not match */

            MATCHT(EOF, &FOLLOW_EOF_in_startParse106); 

            {

                		close_streams();
                		factory->close(factory);
                	
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulestartParseEx; /* Prevent compiler warnings */
    rulestartParseEx: ;



    	if (HASEXCEPTION())
    	{
    		if (mpTree != NULL)
    		{
    			ParseError *error = new_parse_error();
    			if (mpTree->pError != NULL)
    				free_parse_error(mpTree->pError);
    			mpTree->mError = 1;
    			mpTree->pError = error;
    			error->mLine = EXCEPTION->line;
    			error->mPos = EXCEPTION->charPositionInLine;
    			
    			if (EXCEPTION->name != NULL)
    			error->pName = strdup(EXCEPTION->name);
    			
    			if (EXCEPTION->message != NULL)
    			error->pMessage = strdup((char *) EXCEPTION->message);
    		}
    	}

    return returnTree;
}
/* $ANTLR end startParse */

/** 
 * $ANTLR start appArmorProfile
 * AppArmor.g:213:1: appArmorProfile : ( ( newlineRule ) | ( includeExpr ) | ( startOfLineComment ) | ( optionExpr ) | ( profileExpr ) | ( variableAssign ) );
 */
static void
appArmorProfile(pAppArmorParser ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  AppArmor.g:214:2: ( ( newlineRule ) | ( includeExpr ) | ( startOfLineComment ) | ( optionExpr ) | ( profileExpr ) | ( variableAssign ) )
            
            ANTLR3_UINT32 alt2;

            alt2=6;

            switch ( LA(1) ) 
            {
            case NEWLINE:
            	{
            		alt2=1;
            	}
                break;
            case INCLUDE:
            	{
            		alt2=2;
            	}
                break;
            case SOL_COMMENT:
            	{
            		alt2=3;
            	}
                break;
            case 34:
            case 35:
            case 36:
            case 37:
            case 38:
            	{
            		alt2=4;
            	}
                break;
            case UNQUOTED_PATH:
            case QUOTED_STRING:
            case 39:
            	{
            		alt2=5;
            	}
                break;
            case LIST_VAR_START:
            case BOOL_VAR_START:
            	{
            		alt2=6;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = "213:1: appArmorProfile : ( ( newlineRule ) | ( includeExpr ) | ( startOfLineComment ) | ( optionExpr ) | ( profileExpr ) | ( variableAssign ) );";
                EXCEPTION->decisionNum  = 2;
                EXCEPTION->state        = 0;


                goto ruleappArmorProfileEx;
            }

            switch (alt2) 
            {
        	case 1:
        	    // AppArmor.g:214:4: ( newlineRule )
        	    {
        	        // AppArmor.g:214:4: ( newlineRule )
        	        // AppArmor.g:214:6: newlineRule
        	        {
        	            FOLLOWPUSH(FOLLOW_newlineRule_in_appArmorProfile122);
        	            newlineRule(ctx);
        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleappArmorProfileEx;
        	            }


        	        }


        	    }
        	    break;
        	case 2:
        	    // AppArmor.g:215:4: ( includeExpr )
        	    {
        	        // AppArmor.g:215:4: ( includeExpr )
        	        // AppArmor.g:215:6: includeExpr
        	        {
        	            FOLLOWPUSH(FOLLOW_includeExpr_in_appArmorProfile131);
        	            includeExpr(ctx);
        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleappArmorProfileEx;
        	            }

        	            {
        	                 mNewlineCount = 0; 
        	            }

        	        }


        	    }
        	    break;
        	case 3:
        	    // AppArmor.g:216:4: ( startOfLineComment )
        	    {
        	        // AppArmor.g:216:4: ( startOfLineComment )
        	        // AppArmor.g:216:6: startOfLineComment
        	        {
        	            FOLLOWPUSH(FOLLOW_startOfLineComment_in_appArmorProfile142);
        	            startOfLineComment(ctx);
        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleappArmorProfileEx;
        	            }

        	            {
        	                 mNewlineCount = 0; 
        	            }

        	        }


        	    }
        	    break;
        	case 4:
        	    // AppArmor.g:217:4: ( optionExpr )
        	    {
        	        // AppArmor.g:217:4: ( optionExpr )
        	        // AppArmor.g:217:6: optionExpr
        	        {
        	            FOLLOWPUSH(FOLLOW_optionExpr_in_appArmorProfile153);
        	            optionExpr(ctx);
        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleappArmorProfileEx;
        	            }

        	            {
        	                 mNewlineCount = 0; 
        	            }

        	        }


        	    }
        	    break;
        	case 5:
        	    // AppArmor.g:218:4: ( profileExpr )
        	    {
        	        // AppArmor.g:218:4: ( profileExpr )
        	        // AppArmor.g:218:6: profileExpr
        	        {
        	            FOLLOWPUSH(FOLLOW_profileExpr_in_appArmorProfile164);
        	            profileExpr(ctx);
        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleappArmorProfileEx;
        	            }

        	            {
        	                 mNewlineCount = 0; 
        	            }

        	        }


        	    }
        	    break;
        	case 6:
        	    // AppArmor.g:219:4: ( variableAssign )
        	    {
        	        // AppArmor.g:219:4: ( variableAssign )
        	        // AppArmor.g:219:6: variableAssign
        	        {
        	            FOLLOWPUSH(FOLLOW_variableAssign_in_appArmorProfile175);
        	            variableAssign(ctx);
        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleappArmorProfileEx;
        	            }

        	            {
        	                 mNewlineCount = 0; 
        	            }

        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleappArmorProfileEx; /* Prevent compiler warnings */
    ruleappArmorProfileEx: ;



    	if (HASEXCEPTION())
    	{
    		if (mpTree != NULL)
    		{
    			ParseError *error = new_parse_error();
    			if (mpTree->pError != NULL)
    				free_parse_error(mpTree->pError);
    			mpTree->mError = 1;
    			mpTree->pError = error;
    			error->mLine = EXCEPTION->line;
    			error->mPos = EXCEPTION->charPositionInLine;
    			
    			if (EXCEPTION->name != NULL)
    			error->pName = strdup(EXCEPTION->name);
    			
    			if (EXCEPTION->message != NULL)
    			error->pMessage = strdup((char *) EXCEPTION->message);
    		}
    	}

    return ;
}
/* $ANTLR end appArmorProfile */

/** 
 * $ANTLR start newlineRule
 * AppArmor.g:242:1: newlineRule : NEWLINE ;
 */
static void
newlineRule(pAppArmorParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // AppArmor.g:243:2: ( NEWLINE )
        // AppArmor.g:243:4: NEWLINE
        {
            MATCHT(NEWLINE, &FOLLOW_NEWLINE_in_newlineRule193); 

            {

                		if (mpCommentBlock != NULL)
                		{
                			ParseNode *newNode;
                			newNode = new_parse_node(ELEMENT_COMMENT, mpTree);
                			newNode->pData = mpCommentBlock;
                			THROW_IF_NULL(newNode,rulenewlineRuleEx);
                			add_parse_node_child(mpTree, newNode);
                			mpCommentBlock = NULL;
                		}
                	
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulenewlineRuleEx; /* Prevent compiler warnings */
    rulenewlineRuleEx: ;



    	if (HASEXCEPTION())
    	{
    		if (mpTree != NULL)
    		{
    			ParseError *error = new_parse_error();
    			if (mpTree->pError != NULL)
    				free_parse_error(mpTree->pError);
    			mpTree->mError = 1;
    			mpTree->pError = error;
    			error->mLine = EXCEPTION->line;
    			error->mPos = EXCEPTION->charPositionInLine;
    			
    			if (EXCEPTION->name != NULL)
    			error->pName = strdup(EXCEPTION->name);
    			
    			if (EXCEPTION->message != NULL)
    			error->pMessage = strdup((char *) EXCEPTION->message);
    		}
    	}

    return ;
}
/* $ANTLR end newlineRule */

/** 
 * $ANTLR start startOfLineComment
 * AppArmor.g:264:1: startOfLineComment : comment= SOL_COMMENT ;
 */
static void
startOfLineComment(pAppArmorParser ctx)
{   
    pANTLR3_COMMON_TOKEN    comment;

    /* Initialize rule variables
     */


    comment       = NULL;

    {
        // AppArmor.g:265:2: (comment= SOL_COMMENT )
        // AppArmor.g:265:4: comment= SOL_COMMENT
        {
            comment = (pANTLR3_COMMON_TOKEN)LT(1);
            MATCHT(SOL_COMMENT, &FOLLOW_SOL_COMMENT_in_startOfLineComment211); 

            {

                		/* If a block comment doesn't currently exist,
                		 * assign this new found comment to be the start of one.
                		 * otherwise, append it to the block comment we're already
                		 * keeping track of.
                		 *
                		 * NOTE: Notice how %s is escaped?  If you don't do that,
                		 * ANTLR will complain about it because it clashes with
                		 * StringTemplate's business.
                		 */

                		if (mpCommentBlock == NULL)
                		{
                			mpCommentBlock = new_comment_node((char *) comment->getText(comment)->chars);
                			THROW_IF_NULL(mpCommentBlock,rulestartOfLineCommentEx);
                		}
                		else
                		{
                			int len1 = strlen((char *) mpCommentBlock->pCommentText);
                			int len2 = comment->getText(comment)->len;
                			char *tmp = (char *) malloc(len1 + len2 + 3);
                			snprintf(tmp, len1 + len2 + 2, "%s\n%s", 
                						mpCommentBlock->pCommentText,
                						comment->getText(comment)->chars);
                			free(mpCommentBlock->pCommentText);
                			mpCommentBlock->pCommentText = tmp;
                		}
                	
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulestartOfLineCommentEx; /* Prevent compiler warnings */
    rulestartOfLineCommentEx: ;



    	if (HASEXCEPTION())
    	{
    		if (mpTree != NULL)
    		{
    			ParseError *error = new_parse_error();
    			if (mpTree->pError != NULL)
    				free_parse_error(mpTree->pError);
    			mpTree->mError = 1;
    			mpTree->pError = error;
    			error->mLine = EXCEPTION->line;
    			error->mPos = EXCEPTION->charPositionInLine;
    			
    			if (EXCEPTION->name != NULL)
    			error->pName = strdup(EXCEPTION->name);
    			
    			if (EXCEPTION->message != NULL)
    			error->pMessage = strdup((char *) EXCEPTION->message);
    		}
    	}

    return ;
}
/* $ANTLR end startOfLineComment */

/** 
 * $ANTLR start endOfLineComment
 * AppArmor.g:303:1: endOfLineComment[Comment *a] : comment= EOL_COMMENT ;
 */
static void
endOfLineComment(pAppArmorParser ctx, Comment *a)
{   
    pANTLR3_COMMON_TOKEN    comment;

    /* Initialize rule variables
     */


    comment       = NULL;

    {
        // AppArmor.g:304:2: (comment= EOL_COMMENT )
        // AppArmor.g:304:4: comment= EOL_COMMENT
        {
            comment = (pANTLR3_COMMON_TOKEN)LT(1);
            MATCHT(EOL_COMMENT, &FOLLOW_EOL_COMMENT_in_endOfLineComment230); 

            {

                		/* The rules that call this one should be passing in
                		 * their ParseNode->pEOLComment pointer as a.  If it's NULL,
                		 * great - allocate it and assign the text.  This is the most
                		 * likely occurance.  In some cases, EOL comments will need
                		 * to be appended to each other, like this:
                		 * 
                		 *
                		 * /path/to #comment1
                		 * { #comment2
                		 * } #comment 3
                		 * 
                		 * those will all form a large EOL comment block attached
                		 * to the Group node.  So in that case, append the text to a.
                		 */
                		if (a->pCommentText == NULL)
                		{
                			a->pCommentText = strdup((char *) comment->getText(comment)->chars);
                		}
                		else
                		{

                			int len1 = strlen((char *) a->pCommentText);
                			int len2 = comment->getText(comment)->len;
                			char *tmp = (char *) malloc(len1 + len2 + 3);
                			snprintf(tmp, len1 + len2 + 2, "%s\n%s", 
                						a->pCommentText,
                						comment->getText(comment)->chars);
                			free(a->pCommentText);
                			a->pCommentText = tmp;
                		}
                	
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleendOfLineCommentEx; /* Prevent compiler warnings */
    ruleendOfLineCommentEx: ;



    	if (HASEXCEPTION())
    	{
    		if (mpTree != NULL)
    		{
    			ParseError *error = new_parse_error();
    			if (mpTree->pError != NULL)
    				free_parse_error(mpTree->pError);
    			mpTree->mError = 1;
    			mpTree->pError = error;
    			error->mLine = EXCEPTION->line;
    			error->mPos = EXCEPTION->charPositionInLine;
    			
    			if (EXCEPTION->name != NULL)
    			error->pName = strdup(EXCEPTION->name);
    			
    			if (EXCEPTION->message != NULL)
    			error->pMessage = strdup((char *) EXCEPTION->message);
    		}
    	}

    return ;
}
/* $ANTLR end endOfLineComment */

/** 
 * $ANTLR start includeExpr
 * AppArmor.g:358:1: includeExpr : INCLUDE ( LESS_THAN (include= IDENT | include= UNQUOTED_PATH ) GREATER_THAN | include= QUOTED_STRING ) ( endOfLineComment[newComment] )? ;
 */
static void
includeExpr(pAppArmorParser ctx)
{   
    pANTLR3_COMMON_TOKEN    include;

    /* Initialize rule variables
     */


     Comment *newComment = new_comment_node(NULL); 
    include       = NULL;

    {
        // AppArmor.g:360:2: ( INCLUDE ( LESS_THAN (include= IDENT | include= UNQUOTED_PATH ) GREATER_THAN | include= QUOTED_STRING ) ( endOfLineComment[newComment] )? )
        // AppArmor.g:360:4: INCLUDE ( LESS_THAN (include= IDENT | include= UNQUOTED_PATH ) GREATER_THAN | include= QUOTED_STRING ) ( endOfLineComment[newComment] )?
        {
            MATCHT(INCLUDE, &FOLLOW_INCLUDE_in_includeExpr252); 


            // AppArmor.g:360:12: ( LESS_THAN (include= IDENT | include= UNQUOTED_PATH ) GREATER_THAN | include= QUOTED_STRING )
            {
                int alt4=2;

                {
                    int LA4_0 = LA(1);
                    if ( (LA4_0 == LESS_THAN) ) 
                    {
                        alt4=1;
                    }
                    else if ( (LA4_0 == QUOTED_STRING) ) 
                    {
                        alt4=2;
                    }
                    else 
                    {
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = "360:12: ( LESS_THAN (include= IDENT | include= UNQUOTED_PATH ) GREATER_THAN | include= QUOTED_STRING )";
                        EXCEPTION->decisionNum  = 4;
                        EXCEPTION->state        = 0;

                    
                        goto ruleincludeExprEx;
                    }
                }
                switch (alt4) 
                {
            	case 1:
            	    // AppArmor.g:360:13: LESS_THAN (include= IDENT | include= UNQUOTED_PATH ) GREATER_THAN
            	    {
            	        MATCHT(LESS_THAN, &FOLLOW_LESS_THAN_in_includeExpr255); 


            	        // AppArmor.g:360:23: (include= IDENT | include= UNQUOTED_PATH )
            	        {
            	            int alt3=2;

            	            {
            	                int LA3_0 = LA(1);
            	                if ( (LA3_0 == IDENT) ) 
            	                {
            	                    alt3=1;
            	                }
            	                else if ( (LA3_0 == UNQUOTED_PATH) ) 
            	                {
            	                    alt3=2;
            	                }
            	                else 
            	                {
            	                
            	                    CONSTRUCTEX();
            	                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                    EXCEPTION->message      = "360:23: (include= IDENT | include= UNQUOTED_PATH )";
            	                    EXCEPTION->decisionNum  = 3;
            	                    EXCEPTION->state        = 0;

            	                
            	                    goto ruleincludeExprEx;
            	                }
            	            }
            	            switch (alt3) 
            	            {
            	        	case 1:
            	        	    // AppArmor.g:360:24: include= IDENT
            	        	    {
            	        	        include = (pANTLR3_COMMON_TOKEN)LT(1);
            	        	        MATCHT(IDENT, &FOLLOW_IDENT_in_includeExpr260); 


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // AppArmor.g:360:38: include= UNQUOTED_PATH
            	        	    {
            	        	        include = (pANTLR3_COMMON_TOKEN)LT(1);
            	        	        MATCHT(UNQUOTED_PATH, &FOLLOW_UNQUOTED_PATH_in_includeExpr264); 


            	        	    }
            	        	    break;

            	            }
            	        }
            	        MATCHT(GREATER_THAN, &FOLLOW_GREATER_THAN_in_includeExpr267); 


            	    }
            	    break;
            	case 2:
            	    // AppArmor.g:361:4: include= QUOTED_STRING
            	    {
            	        include = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(QUOTED_STRING, &FOLLOW_QUOTED_STRING_in_includeExpr274); 


            	    }
            	    break;

                }
            }

            // AppArmor.g:362:2: ( endOfLineComment[newComment] )?
            {
                int alt5=2;
                {
                    int LA5_0 = LA(1);
                    if ( (LA5_0 == EOL_COMMENT) ) 
                    {
                        alt5=1;
                    }
                }
                switch (alt5) 
                {
            	case 1:
            	    // AppArmor.g:362:4: endOfLineComment[newComment]
            	    {
            	        FOLLOWPUSH(FOLLOW_endOfLineComment_in_includeExpr280);
            	        endOfLineComment(ctx, newComment);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleincludeExprEx;
            	        }


            	    }
            	    break;

                }
            }
            {

                		Include *includeFile = new_include_node();
                		THROW_IF_NULL(includeFile,ruleincludeExprEx);
                		ParseNode *includeNode;
                		includeNode = new_parse_node(ELEMENT_INCLUDE, mpTree);
                		THROW_IF_NULL(includeNode,ruleincludeExprEx);
                		
                		includeNode->pData = includeFile;
                		includeNode->pEOLComment = newComment;
                		AttachCommentBlock(includeNode);
                		
                		/* if this is a QUOTED_STRING, strip the quotes out using
                		 * the ANTLR_STRING_struct substring function.
                		 * Yes, I know it looks horrible.
                		 */
                		if (include->getText(include)->charAt(include->getText(include), 0) == '\"') /* " */
                			includeFile->pIncludeFile = 
                				strdup((char *) include->getText(include)->subString
                						(include->getText(include),	1, 
                						include->getText(include)->len - 1)->chars);
                		else
                			includeFile->pIncludeFile = strdup((char *) include->getText(include)->chars);
                		
                		add_parse_node_child(mpTree, includeNode);
                	
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleincludeExprEx; /* Prevent compiler warnings */
    ruleincludeExprEx: ;



    	if (HASEXCEPTION())
    	{
    		if (mpTree != NULL)
    		{
    			ParseError *error = new_parse_error();
    			if (mpTree->pError != NULL)
    				free_parse_error(mpTree->pError);
    			mpTree->mError = 1;
    			mpTree->pError = error;
    			error->mLine = EXCEPTION->line;
    			error->mPos = EXCEPTION->charPositionInLine;
    			
    			if (EXCEPTION->name != NULL)
    			error->pName = strdup(EXCEPTION->name);
    			
    			if (EXCEPTION->message != NULL)
    			error->pMessage = strdup((char *) EXCEPTION->message);
    		}
    	}

    return ;
}
/* $ANTLR end includeExpr */

/** 
 * $ANTLR start variableAssign
 * AppArmor.g:392:1: variableAssign : ( LIST_VAR_START varList= IDENT RIGHT_BRACE ( PLUS )? EQUALS ( (incomingString= IDENT | incomingString= QUOTED_STRING | incomingString= UNQUOTED_PATH ) | LIST_VAR_START incomingString= IDENT RIGHT_BRACE )* | BOOL_VAR_START boolVar= IDENT RIGHT_BRACE EQUALS ( 'true' | 'false' ) ) ( NEWLINE | endOfLineComment[newComment] ) ;
 */
static void
variableAssign(pAppArmorParser ctx)
{   
    pANTLR3_COMMON_TOKEN    varList;
    pANTLR3_COMMON_TOKEN    incomingString;
    pANTLR3_COMMON_TOKEN    boolVar;

    /* Initialize rule variables
     */



    		char *name = NULL;
    		char *valueString = NULL;

    		Comment *newComment = new_comment_node(NULL);

    		VariableAssignment *varAssign;
    		varAssign = new_variable_assignment_node();
    		THROW_IF_NULL(varAssign,rulevariableAssignEx);
    		
    		ParseNode *varNode;
    		varNode = new_parse_node(ELEMENT_VARIABLE_ASSIGNMENT, mpTree);
    		varNode->pData = varAssign;
    		varNode->pEOLComment = newComment;
    		AttachCommentBlock(varNode);

    		if (mpTree->pVariableList == NULL)
    			mpTree->pVariableList = new_variable_list();

    	
    varList       = NULL;
    incomingString       = NULL;
    boolVar       = NULL;

    {
        // AppArmor.g:413:2: ( ( LIST_VAR_START varList= IDENT RIGHT_BRACE ( PLUS )? EQUALS ( (incomingString= IDENT | incomingString= QUOTED_STRING | incomingString= UNQUOTED_PATH ) | LIST_VAR_START incomingString= IDENT RIGHT_BRACE )* | BOOL_VAR_START boolVar= IDENT RIGHT_BRACE EQUALS ( 'true' | 'false' ) ) ( NEWLINE | endOfLineComment[newComment] ) )
        // AppArmor.g:414:2: ( LIST_VAR_START varList= IDENT RIGHT_BRACE ( PLUS )? EQUALS ( (incomingString= IDENT | incomingString= QUOTED_STRING | incomingString= UNQUOTED_PATH ) | LIST_VAR_START incomingString= IDENT RIGHT_BRACE )* | BOOL_VAR_START boolVar= IDENT RIGHT_BRACE EQUALS ( 'true' | 'false' ) ) ( NEWLINE | endOfLineComment[newComment] )
        {

            // AppArmor.g:414:2: ( LIST_VAR_START varList= IDENT RIGHT_BRACE ( PLUS )? EQUALS ( (incomingString= IDENT | incomingString= QUOTED_STRING | incomingString= UNQUOTED_PATH ) | LIST_VAR_START incomingString= IDENT RIGHT_BRACE )* | BOOL_VAR_START boolVar= IDENT RIGHT_BRACE EQUALS ( 'true' | 'false' ) )
            {
                int alt10=2;

                {
                    int LA10_0 = LA(1);
                    if ( (LA10_0 == LIST_VAR_START) ) 
                    {
                        alt10=1;
                    }
                    else if ( (LA10_0 == BOOL_VAR_START) ) 
                    {
                        alt10=2;
                    }
                    else 
                    {
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = "414:2: ( LIST_VAR_START varList= IDENT RIGHT_BRACE ( PLUS )? EQUALS ( (incomingString= IDENT | incomingString= QUOTED_STRING | incomingString= UNQUOTED_PATH ) | LIST_VAR_START incomingString= IDENT RIGHT_BRACE )* | BOOL_VAR_START boolVar= IDENT RIGHT_BRACE EQUALS ( 'true' | 'false' ) )";
                        EXCEPTION->decisionNum  = 10;
                        EXCEPTION->state        = 0;

                    
                        goto rulevariableAssignEx;
                    }
                }
                switch (alt10) 
                {
            	case 1:
            	    // AppArmor.g:414:4: LIST_VAR_START varList= IDENT RIGHT_BRACE ( PLUS )? EQUALS ( (incomingString= IDENT | incomingString= QUOTED_STRING | incomingString= UNQUOTED_PATH ) | LIST_VAR_START incomingString= IDENT RIGHT_BRACE )*
            	    {
            	        MATCHT(LIST_VAR_START, &FOLLOW_LIST_VAR_START_in_variableAssign309); 

            	        varList = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(IDENT, &FOLLOW_IDENT_in_variableAssign313); 

            	        MATCHT(RIGHT_BRACE, &FOLLOW_RIGHT_BRACE_in_variableAssign315); 

            	        {
            	             name = strdup((char *) varList->getText(varList)->chars); 
            	        }

            	        // AppArmor.g:416:3: ( PLUS )?
            	        {
            	            int alt6=2;
            	            {
            	                int LA6_0 = LA(1);
            	                if ( (LA6_0 == PLUS) ) 
            	                {
            	                    alt6=1;
            	                }
            	            }
            	            switch (alt6) 
            	            {
            	        	case 1:
            	        	    // AppArmor.g:416:5: PLUS
            	        	    {
            	        	        MATCHT(PLUS, &FOLLOW_PLUS_in_variableAssign325); 

            	        	        {
            	        	             varAssign->mPlusEquals = 1; 
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }
            	        MATCHT(EQUALS, &FOLLOW_EQUALS_in_variableAssign333); 

            	        {

            	            		/* Clear out any existing entries if it is not a +=
            	            		 * assignment.
            	            		 */
            	            		if ((mpTree->pVariableList != NULL) 
            	            		    && (varAssign->mPlusEquals == 0))
            	            			mpTree->pVariableList = 
            	            				del_variable_list_by_name(mpTree->pVariableList,
            	            							name);
            	            	
            	        }

            	        // AppArmor.g:430:2: ( (incomingString= IDENT | incomingString= QUOTED_STRING | incomingString= UNQUOTED_PATH ) | LIST_VAR_START incomingString= IDENT RIGHT_BRACE )*

            	        for (;;)
            	        {
            	            int alt8=3;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA8_0 = LA(1);
            	                if ( (((LA8_0 >= IDENT) && (LA8_0 <= UNQUOTED_PATH)) || LA8_0 == QUOTED_STRING) ) 
            	                {
            	                    alt8=1;
            	                }
            	                else if ( (LA8_0 == LIST_VAR_START) ) 
            	                {
            	                    alt8=2;
            	                }

            	            }
            	            switch (alt8) 
            	            {
            	        	case 1:
            	        	    // AppArmor.g:430:4: (incomingString= IDENT | incomingString= QUOTED_STRING | incomingString= UNQUOTED_PATH )
            	        	    {

            	        	        // AppArmor.g:430:4: (incomingString= IDENT | incomingString= QUOTED_STRING | incomingString= UNQUOTED_PATH )
            	        	        {
            	        	            int alt7=3;
            	        	            switch ( LA(1) ) 
            	        	            {
            	        	            case IDENT:
            	        	            	{
            	        	            		alt7=1;
            	        	            	}
            	        	                break;
            	        	            case QUOTED_STRING:
            	        	            	{
            	        	            		alt7=2;
            	        	            	}
            	        	                break;
            	        	            case UNQUOTED_PATH:
            	        	            	{
            	        	            		alt7=3;
            	        	            	}
            	        	                break;

            	        	            default:
            	        	                CONSTRUCTEX();
            	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                EXCEPTION->message      = "430:4: (incomingString= IDENT | incomingString= QUOTED_STRING | incomingString= UNQUOTED_PATH )";
            	        	                EXCEPTION->decisionNum  = 7;
            	        	                EXCEPTION->state        = 0;


            	        	                goto rulevariableAssignEx;
            	        	            }

            	        	            switch (alt7) 
            	        	            {
            	        	        	case 1:
            	        	        	    // AppArmor.g:430:5: incomingString= IDENT
            	        	        	    {
            	        	        	        incomingString = (pANTLR3_COMMON_TOKEN)LT(1);
            	        	        	        MATCHT(IDENT, &FOLLOW_IDENT_in_variableAssign350); 


            	        	        	    }
            	        	        	    break;
            	        	        	case 2:
            	        	        	    // AppArmor.g:430:26: incomingString= QUOTED_STRING
            	        	        	    {
            	        	        	        incomingString = (pANTLR3_COMMON_TOKEN)LT(1);
            	        	        	        MATCHT(QUOTED_STRING, &FOLLOW_QUOTED_STRING_in_variableAssign354); 


            	        	        	    }
            	        	        	    break;
            	        	        	case 3:
            	        	        	    // AppArmor.g:430:55: incomingString= UNQUOTED_PATH
            	        	        	    {
            	        	        	        incomingString = (pANTLR3_COMMON_TOKEN)LT(1);
            	        	        	        MATCHT(UNQUOTED_PATH, &FOLLOW_UNQUOTED_PATH_in_variableAssign358); 


            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }
            	        	        {
            	        	             
            	        	            	
            	        	            		/* Insert the entry */

            	        	            		VariableListEntry *newEntry = new_variable_list_entry();
            	        	            		newEntry->mIsBoolValue = 0;
            	        	            		newEntry->pName = strdup(name);
            	        	            		newEntry->mValues.pValue = strdup((char *) incomingString->getText(incomingString)->chars);
            	        	            		add_variable_list_entry(mpTree->pVariableList, newEntry);
            	        	            	
            	        	            		/* If this is the first iteration (or the only one)
            	        	            		 * of a list of variables being assigned, insert it.
            	        	            		 * Otherwise, append it.
            	        	            		 */
            	        	            		if (valueString == NULL)
            	        	            		{
            	        	            			valueString = (char *) malloc(incomingString->getText(incomingString)->len + 1);
            	        	            			strncpy(valueString, (char *)
            	        	            				incomingString->getText(incomingString)->chars,
            	        	            				incomingString->getText(incomingString)->len + 1);
            	        	            		}
            	        	            		else
            	        	            		{
            	        	            			int len1 = strlen(valueString);
            	        	            			int len2 = incomingString->getText(incomingString)->len;
            	        	            			char *tmp = (char *) malloc(len1 + len2 + 2);
            	        	            			sprintf(tmp, "%s %s", valueString, 
            	        	            						incomingString->getText(incomingString)->chars);
            	        	            			free(valueString);
            	        	            			valueString = tmp;
            	        	            		}

            	        	            	
            	        	        }

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // AppArmor.g:464:4: LIST_VAR_START incomingString= IDENT RIGHT_BRACE
            	        	    {
            	        	        MATCHT(LIST_VAR_START, &FOLLOW_LIST_VAR_START_in_variableAssign367); 

            	        	        incomingString = (pANTLR3_COMMON_TOKEN)LT(1);
            	        	        MATCHT(IDENT, &FOLLOW_IDENT_in_variableAssign371); 

            	        	        MATCHT(RIGHT_BRACE, &FOLLOW_RIGHT_BRACE_in_variableAssign373); 

            	        	        {


            	        	            		/* insert the contents of "incomingString" from the 
            	        	            		 * variable list into the "name" entry.
            	        	            		 */
            	        	            		append_variable_list_values(mpTree->pVariableList,
            	        	            					name,
            	        	            					(char *)incomingString->getText(incomingString)->chars);

            	        	            		if (valueString == NULL)
            	        	            		{
            	        	            			valueString = (char *) malloc(incomingString->getText(incomingString)->len + 4);
            	        	            			snprintf(valueString, incomingString->getText(incomingString)->len + 4, 
            	        	            						"@{%s}",
            	        	            						incomingString->getText(incomingString)->chars);
            	        	            		}
            	        	            		else
            	        	            		{
            	        	            			int len1 = strlen(valueString);
            	        	            			int len2 = incomingString->getText(incomingString)->len;
            	        	            			char *tmp = (char *) malloc(len1 + len2 + 5);
            	        	            			sprintf(tmp, "%s @{%s}", valueString, 
            	        	            						incomingString->getText(incomingString)->chars);
            	        	            			free(valueString);
            	        	            			valueString = tmp;
            	        	            		}
            	        	            	
            	        	        }

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop8;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop8: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;
            	case 2:
            	    // AppArmor.g:494:4: BOOL_VAR_START boolVar= IDENT RIGHT_BRACE EQUALS ( 'true' | 'false' )
            	    {
            	        MATCHT(BOOL_VAR_START, &FOLLOW_BOOL_VAR_START_in_variableAssign389); 

            	        boolVar = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(IDENT, &FOLLOW_IDENT_in_variableAssign393); 

            	        MATCHT(RIGHT_BRACE, &FOLLOW_RIGHT_BRACE_in_variableAssign395); 

            	        {
            	             
            	            	  	name = strdup((char *) boolVar->getText(boolVar)->chars);
            	            		varAssign->mIsBoolValue = 1;
            	            	  
            	        }
            	        MATCHT(EQUALS, &FOLLOW_EQUALS_in_variableAssign403); 


            	        // AppArmor.g:499:3: ( 'true' | 'false' )
            	        {
            	            int alt9=2;

            	            {
            	                int LA9_0 = LA(1);
            	                if ( (LA9_0 == 32) ) 
            	                {
            	                    alt9=1;
            	                }
            	                else if ( (LA9_0 == 33) ) 
            	                {
            	                    alt9=2;
            	                }
            	                else 
            	                {
            	                
            	                    CONSTRUCTEX();
            	                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                    EXCEPTION->message      = "499:3: ( 'true' | 'false' )";
            	                    EXCEPTION->decisionNum  = 9;
            	                    EXCEPTION->state        = 0;

            	                
            	                    goto rulevariableAssignEx;
            	                }
            	            }
            	            switch (alt9) 
            	            {
            	        	case 1:
            	        	    // AppArmor.g:499:5: 'true'
            	        	    {
            	        	        MATCHT(32, &FOLLOW_32_in_variableAssign409); 

            	        	        {

            	        	            			if (valueString != NULL) free(valueString);
            	        	            			valueString = strdup(" = true");
            	        	            			VariableListEntry *newEntry = new_variable_list_entry();
            	        	            			newEntry->mIsBoolValue = 1;
            	        	            			newEntry->pName = strdup(name);
            	        	            			newEntry->mValues.mBoolValue = 1;
            	        	            			add_variable_list_entry(mpTree->pVariableList,
            	        	            							newEntry);

            	        	            		
            	        	        }

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // AppArmor.g:511:5: 'false'
            	        	    {
            	        	        MATCHT(33, &FOLLOW_33_in_variableAssign419); 

            	        	        {

            	        	            			if (valueString != NULL) free(valueString);
            	        	            			valueString = strdup(" = false");
            	        	            			VariableListEntry *newEntry = new_variable_list_entry();
            	        	            			newEntry->mIsBoolValue = 1;
            	        	            			newEntry->pName = strdup(name);
            	        	            			newEntry->mValues.mBoolValue = 0;
            	        	            			add_variable_list_entry(mpTree->pVariableList,
            	        	            							newEntry);
            	        	            		
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            // AppArmor.g:532:2: ( NEWLINE | endOfLineComment[newComment] )
            {
                int alt11=2;

                {
                    int LA11_0 = LA(1);
                    if ( (LA11_0 == NEWLINE) ) 
                    {
                        alt11=1;
                    }
                    else if ( (LA11_0 == EOL_COMMENT) ) 
                    {
                        alt11=2;
                    }
                    else 
                    {
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = "532:2: ( NEWLINE | endOfLineComment[newComment] )";
                        EXCEPTION->decisionNum  = 11;
                        EXCEPTION->state        = 0;

                    
                        goto rulevariableAssignEx;
                    }
                }
                switch (alt11) 
                {
            	case 1:
            	    // AppArmor.g:532:4: NEWLINE
            	    {
            	        MATCHT(NEWLINE, &FOLLOW_NEWLINE_in_variableAssign438); 


            	    }
            	    break;
            	case 2:
            	    // AppArmor.g:532:14: endOfLineComment[newComment]
            	    {
            	        FOLLOWPUSH(FOLLOW_endOfLineComment_in_variableAssign442);
            	        endOfLineComment(ctx, newComment);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulevariableAssignEx;
            	        }


            	    }
            	    break;

                }
            }
            {

                		varAssign->pName = name;
                		varAssign->pValue = valueString;
                		add_parse_node_child(mpTree, varNode);
                	
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulevariableAssignEx; /* Prevent compiler warnings */
    rulevariableAssignEx: ;



    	if (HASEXCEPTION())
    	{
    		if (mpTree != NULL)
    		{
    			ParseError *error = new_parse_error();
    			if (mpTree->pError != NULL)
    				free_parse_error(mpTree->pError);
    			mpTree->mError = 1;
    			mpTree->pError = error;
    			error->mLine = EXCEPTION->line;
    			error->mPos = EXCEPTION->charPositionInLine;
    			
    			if (EXCEPTION->name != NULL)
    			error->pName = strdup(EXCEPTION->name);
    			
    			if (EXCEPTION->message != NULL)
    			error->pMessage = strdup((char *) EXCEPTION->message);
    		}
    	}

    return ;
}
/* $ANTLR end variableAssign */

/** 
 * $ANTLR start optionExpr
 * AppArmor.g:545:1: optionExpr : ( 'audit' ( 'true' | 'false' ) | 'version' (ver= IDENT | ver= QUOTED_STRING ) | 'encoding' (enc= IDENT | enc= QUOTED_STRING ) | 'disabled' ( 'true' | 'false' ) | 'complain' ( 'true' | 'false' ) ) ( endOfLineComment[newComment] )? ;
 */
static void
optionExpr(pAppArmorParser ctx)
{   
    pANTLR3_COMMON_TOKEN    ver;
    pANTLR3_COMMON_TOKEN    enc;

    /* Initialize rule variables
     */



    		Option *option = new_option_node();
    		THROW_IF_NULL(option,ruleoptionExprEx);
    		Comment *newComment = new_comment_node(NULL);
    		ParseNode *optionTree = new_parse_node(ELEMENT_OPTION, mpTree);
    		THROW_IF_NULL(optionTree,ruleoptionExprEx);
    		optionTree->pData = option;
    		optionTree->pEOLComment = newComment;
    		AttachCommentBlock(optionTree);
    	
    ver       = NULL;
    enc       = NULL;

    {
        // AppArmor.g:556:2: ( ( 'audit' ( 'true' | 'false' ) | 'version' (ver= IDENT | ver= QUOTED_STRING ) | 'encoding' (enc= IDENT | enc= QUOTED_STRING ) | 'disabled' ( 'true' | 'false' ) | 'complain' ( 'true' | 'false' ) ) ( endOfLineComment[newComment] )? )
        // AppArmor.g:557:2: ( 'audit' ( 'true' | 'false' ) | 'version' (ver= IDENT | ver= QUOTED_STRING ) | 'encoding' (enc= IDENT | enc= QUOTED_STRING ) | 'disabled' ( 'true' | 'false' ) | 'complain' ( 'true' | 'false' ) ) ( endOfLineComment[newComment] )?
        {

            // AppArmor.g:557:2: ( 'audit' ( 'true' | 'false' ) | 'version' (ver= IDENT | ver= QUOTED_STRING ) | 'encoding' (enc= IDENT | enc= QUOTED_STRING ) | 'disabled' ( 'true' | 'false' ) | 'complain' ( 'true' | 'false' ) )
            {
                int alt17=5;
                switch ( LA(1) ) 
                {
                case 34:
                	{
                		alt17=1;
                	}
                    break;
                case 35:
                	{
                		alt17=2;
                	}
                    break;
                case 36:
                	{
                		alt17=3;
                	}
                    break;
                case 37:
                	{
                		alt17=4;
                	}
                    break;
                case 38:
                	{
                		alt17=5;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = "557:2: ( 'audit' ( 'true' | 'false' ) | 'version' (ver= IDENT | ver= QUOTED_STRING ) | 'encoding' (enc= IDENT | enc= QUOTED_STRING ) | 'disabled' ( 'true' | 'false' ) | 'complain' ( 'true' | 'false' ) )";
                    EXCEPTION->decisionNum  = 17;
                    EXCEPTION->state        = 0;


                    goto ruleoptionExprEx;
                }

                switch (alt17) 
                {
            	case 1:
            	    // AppArmor.g:557:4: 'audit' ( 'true' | 'false' )
            	    {
            	        MATCHT(34, &FOLLOW_34_in_optionExpr470); 


            	        // AppArmor.g:557:12: ( 'true' | 'false' )
            	        {
            	            int alt12=2;

            	            {
            	                int LA12_0 = LA(1);
            	                if ( (LA12_0 == 32) ) 
            	                {
            	                    alt12=1;
            	                }
            	                else if ( (LA12_0 == 33) ) 
            	                {
            	                    alt12=2;
            	                }
            	                else 
            	                {
            	                
            	                    CONSTRUCTEX();
            	                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                    EXCEPTION->message      = "557:12: ( 'true' | 'false' )";
            	                    EXCEPTION->decisionNum  = 12;
            	                    EXCEPTION->state        = 0;

            	                
            	                    goto ruleoptionExprEx;
            	                }
            	            }
            	            switch (alt12) 
            	            {
            	        	case 1:
            	        	    // AppArmor.g:557:13: 'true'
            	        	    {
            	        	        MATCHT(32, &FOLLOW_32_in_optionExpr473); 

            	        	        {
            	        	             option->mValue.mBoolValue = 1; 
            	        	        }

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // AppArmor.g:558:7: 'false'
            	        	    {
            	        	        MATCHT(33, &FOLLOW_33_in_optionExpr483); 

            	        	        {
            	        	             option->mValue.mBoolValue = 0; 
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }
            	        {
            	             option->mOptionType = OPTION_AUDIT; 
            	        }

            	    }
            	    break;
            	case 2:
            	    // AppArmor.g:560:4: 'version' (ver= IDENT | ver= QUOTED_STRING )
            	    {
            	        MATCHT(35, &FOLLOW_35_in_optionExpr495); 


            	        // AppArmor.g:560:14: (ver= IDENT | ver= QUOTED_STRING )
            	        {
            	            int alt13=2;

            	            {
            	                int LA13_0 = LA(1);
            	                if ( (LA13_0 == IDENT) ) 
            	                {
            	                    alt13=1;
            	                }
            	                else if ( (LA13_0 == QUOTED_STRING) ) 
            	                {
            	                    alt13=2;
            	                }
            	                else 
            	                {
            	                
            	                    CONSTRUCTEX();
            	                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                    EXCEPTION->message      = "560:14: (ver= IDENT | ver= QUOTED_STRING )";
            	                    EXCEPTION->decisionNum  = 13;
            	                    EXCEPTION->state        = 0;

            	                
            	                    goto ruleoptionExprEx;
            	                }
            	            }
            	            switch (alt13) 
            	            {
            	        	case 1:
            	        	    // AppArmor.g:560:15: ver= IDENT
            	        	    {
            	        	        ver = (pANTLR3_COMMON_TOKEN)LT(1);
            	        	        MATCHT(IDENT, &FOLLOW_IDENT_in_optionExpr500); 


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // AppArmor.g:560:27: ver= QUOTED_STRING
            	        	    {
            	        	        ver = (pANTLR3_COMMON_TOKEN)LT(1);
            	        	        MATCHT(QUOTED_STRING, &FOLLOW_QUOTED_STRING_in_optionExpr506); 


            	        	    }
            	        	    break;

            	            }
            	        }
            	        {

            	            		option->mOptionType = OPTION_VERSION;
            	            		option->mValue.pCharValue = strdup((char *) ver->getText(ver)->chars);
            	            	
            	        }

            	    }
            	    break;
            	case 3:
            	    // AppArmor.g:565:4: 'encoding' (enc= IDENT | enc= QUOTED_STRING )
            	    {
            	        MATCHT(36, &FOLLOW_36_in_optionExpr515); 


            	        // AppArmor.g:565:15: (enc= IDENT | enc= QUOTED_STRING )
            	        {
            	            int alt14=2;

            	            {
            	                int LA14_0 = LA(1);
            	                if ( (LA14_0 == IDENT) ) 
            	                {
            	                    alt14=1;
            	                }
            	                else if ( (LA14_0 == QUOTED_STRING) ) 
            	                {
            	                    alt14=2;
            	                }
            	                else 
            	                {
            	                
            	                    CONSTRUCTEX();
            	                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                    EXCEPTION->message      = "565:15: (enc= IDENT | enc= QUOTED_STRING )";
            	                    EXCEPTION->decisionNum  = 14;
            	                    EXCEPTION->state        = 0;

            	                
            	                    goto ruleoptionExprEx;
            	                }
            	            }
            	            switch (alt14) 
            	            {
            	        	case 1:
            	        	    // AppArmor.g:565:16: enc= IDENT
            	        	    {
            	        	        enc = (pANTLR3_COMMON_TOKEN)LT(1);
            	        	        MATCHT(IDENT, &FOLLOW_IDENT_in_optionExpr520); 


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // AppArmor.g:565:28: enc= QUOTED_STRING
            	        	    {
            	        	        enc = (pANTLR3_COMMON_TOKEN)LT(1);
            	        	        MATCHT(QUOTED_STRING, &FOLLOW_QUOTED_STRING_in_optionExpr526); 


            	        	    }
            	        	    break;

            	            }
            	        }
            	        {

            	            		option->mOptionType = OPTION_ENCODING;
            	            		option->mValue.pCharValue = strdup((char *) enc->getText(enc)->chars);
            	            	
            	        }

            	    }
            	    break;
            	case 4:
            	    // AppArmor.g:570:4: 'disabled' ( 'true' | 'false' )
            	    {
            	        MATCHT(37, &FOLLOW_37_in_optionExpr535); 


            	        // AppArmor.g:570:15: ( 'true' | 'false' )
            	        {
            	            int alt15=2;

            	            {
            	                int LA15_0 = LA(1);
            	                if ( (LA15_0 == 32) ) 
            	                {
            	                    alt15=1;
            	                }
            	                else if ( (LA15_0 == 33) ) 
            	                {
            	                    alt15=2;
            	                }
            	                else 
            	                {
            	                
            	                    CONSTRUCTEX();
            	                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                    EXCEPTION->message      = "570:15: ( 'true' | 'false' )";
            	                    EXCEPTION->decisionNum  = 15;
            	                    EXCEPTION->state        = 0;

            	                
            	                    goto ruleoptionExprEx;
            	                }
            	            }
            	            switch (alt15) 
            	            {
            	        	case 1:
            	        	    // AppArmor.g:570:16: 'true'
            	        	    {
            	        	        MATCHT(32, &FOLLOW_32_in_optionExpr538); 

            	        	        {
            	        	             option->mValue.mBoolValue = 1; 
            	        	        }

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // AppArmor.g:571:9: 'false'
            	        	    {
            	        	        MATCHT(33, &FOLLOW_33_in_optionExpr550); 

            	        	        {
            	        	             option->mValue.mBoolValue = 0; 
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }
            	        {
            	             option->mOptionType = OPTION_DISABLED; 
            	        }

            	    }
            	    break;
            	case 5:
            	    // AppArmor.g:573:4: 'complain' ( 'true' | 'false' )
            	    {
            	        MATCHT(38, &FOLLOW_38_in_optionExpr562); 


            	        // AppArmor.g:573:15: ( 'true' | 'false' )
            	        {
            	            int alt16=2;

            	            {
            	                int LA16_0 = LA(1);
            	                if ( (LA16_0 == 32) ) 
            	                {
            	                    alt16=1;
            	                }
            	                else if ( (LA16_0 == 33) ) 
            	                {
            	                    alt16=2;
            	                }
            	                else 
            	                {
            	                
            	                    CONSTRUCTEX();
            	                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                    EXCEPTION->message      = "573:15: ( 'true' | 'false' )";
            	                    EXCEPTION->decisionNum  = 16;
            	                    EXCEPTION->state        = 0;

            	                
            	                    goto ruleoptionExprEx;
            	                }
            	            }
            	            switch (alt16) 
            	            {
            	        	case 1:
            	        	    // AppArmor.g:573:16: 'true'
            	        	    {
            	        	        MATCHT(32, &FOLLOW_32_in_optionExpr565); 

            	        	        {
            	        	            option->mValue.mBoolValue = 1; 
            	        	        }

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // AppArmor.g:574:9: 'false'
            	        	    {
            	        	        MATCHT(33, &FOLLOW_33_in_optionExpr577); 

            	        	        {
            	        	             option->mValue.mBoolValue = 0; 
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }
            	        {
            	             option->mOptionType = OPTION_COMPLAIN; 
            	        }

            	    }
            	    break;

                }
            }
            {
                 add_parse_node_child(mpTree, optionTree); 
            }

            // AppArmor.g:578:2: ( endOfLineComment[newComment] )?
            {
                int alt18=2;
                {
                    int LA18_0 = LA(1);
                    if ( (LA18_0 == EOL_COMMENT) ) 
                    {
                        alt18=1;
                    }
                }
                switch (alt18) 
                {
            	case 1:
            	    // AppArmor.g:578:4: endOfLineComment[newComment]
            	    {
            	        FOLLOWPUSH(FOLLOW_endOfLineComment_in_optionExpr593);
            	        endOfLineComment(ctx, newComment);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleoptionExprEx;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleoptionExprEx; /* Prevent compiler warnings */
    ruleoptionExprEx: ;



    	if (HASEXCEPTION())
    	{
    		if (mpTree != NULL)
    		{
    			ParseError *error = new_parse_error();
    			if (mpTree->pError != NULL)
    				free_parse_error(mpTree->pError);
    			mpTree->mError = 1;
    			mpTree->pError = error;
    			error->mLine = EXCEPTION->line;
    			error->mPos = EXCEPTION->charPositionInLine;
    			
    			if (EXCEPTION->name != NULL)
    			error->pName = strdup(EXCEPTION->name);
    			
    			if (EXCEPTION->message != NULL)
    			error->pMessage = strdup((char *) EXCEPTION->message);
    		}
    	}

    return ;
}
/* $ANTLR end optionExpr */

/** 
 * $ANTLR start profileExpr
 * AppArmor.g:588:1: profileExpr : ( (path= UNQUOTED_PATH | path= QUOTED_STRING ) | 'profile' path= IDENT ) ( ( 'flags' EQUALS )? LEFT_PAREN ( 'complain' | 'disabled' | 'audit' | 'fold_hats' )* RIGHT_PAREN )? ( endOfLineComment[newComment] )? LEFT_BRACE ( endOfLineComment[newComment] )? incomingRuleTree= ruleExpr RIGHT_BRACE ( endOfLineComment[newComment] )? ;
 */
static void
profileExpr(pAppArmorParser ctx)
{   
    pANTLR3_COMMON_TOKEN    path;
    ParseNode * incomingRuleTree;
    #undef	RETURN_TYPE_incomingRuleTree
    #define	RETURN_TYPE_incomingRuleTree ParseNode *

    /* Initialize rule variables
     */



    		ParseNode *profileTree; /* This node */
    		Group *profileElement;
    		char flags = 0;
    		Comment *newComment = new_comment_node(NULL);
    		profileElement = new_group_node(ELEMENT_GROUP_INVALID);
    		THROW_IF_NULL(profileElement,ruleprofileExprEx);
    		profileTree = new_parse_node(ELEMENT_GROUP, mpTree);
    		THROW_IF_NULL(profileTree,ruleprofileExprEx);
    		profileTree->pData = profileElement;
    		profileTree->pEOLComment = newComment;
    		AttachCommentBlock(profileTree);
    		add_parse_node_child(mpTree, profileTree);
    	
    path       = NULL;
    incomingRuleTree = NULL;

    {
        // AppArmor.g:604:2: ( ( (path= UNQUOTED_PATH | path= QUOTED_STRING ) | 'profile' path= IDENT ) ( ( 'flags' EQUALS )? LEFT_PAREN ( 'complain' | 'disabled' | 'audit' | 'fold_hats' )* RIGHT_PAREN )? ( endOfLineComment[newComment] )? LEFT_BRACE ( endOfLineComment[newComment] )? incomingRuleTree= ruleExpr RIGHT_BRACE ( endOfLineComment[newComment] )? )
        // AppArmor.g:605:2: ( (path= UNQUOTED_PATH | path= QUOTED_STRING ) | 'profile' path= IDENT ) ( ( 'flags' EQUALS )? LEFT_PAREN ( 'complain' | 'disabled' | 'audit' | 'fold_hats' )* RIGHT_PAREN )? ( endOfLineComment[newComment] )? LEFT_BRACE ( endOfLineComment[newComment] )? incomingRuleTree= ruleExpr RIGHT_BRACE ( endOfLineComment[newComment] )?
        {

            // AppArmor.g:605:2: ( (path= UNQUOTED_PATH | path= QUOTED_STRING ) | 'profile' path= IDENT )
            {
                int alt20=2;

                {
                    int LA20_0 = LA(1);
                    if ( (LA20_0 == UNQUOTED_PATH || LA20_0 == QUOTED_STRING) ) 
                    {
                        alt20=1;
                    }
                    else if ( (LA20_0 == 39) ) 
                    {
                        alt20=2;
                    }
                    else 
                    {
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = "605:2: ( (path= UNQUOTED_PATH | path= QUOTED_STRING ) | 'profile' path= IDENT )";
                        EXCEPTION->decisionNum  = 20;
                        EXCEPTION->state        = 0;

                    
                        goto ruleprofileExprEx;
                    }
                }
                switch (alt20) 
                {
            	case 1:
            	    // AppArmor.g:605:6: (path= UNQUOTED_PATH | path= QUOTED_STRING )
            	    {

            	        // AppArmor.g:605:6: (path= UNQUOTED_PATH | path= QUOTED_STRING )
            	        {
            	            int alt19=2;

            	            {
            	                int LA19_0 = LA(1);
            	                if ( (LA19_0 == UNQUOTED_PATH) ) 
            	                {
            	                    alt19=1;
            	                }
            	                else if ( (LA19_0 == QUOTED_STRING) ) 
            	                {
            	                    alt19=2;
            	                }
            	                else 
            	                {
            	                
            	                    CONSTRUCTEX();
            	                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                    EXCEPTION->message      = "605:6: (path= UNQUOTED_PATH | path= QUOTED_STRING )";
            	                    EXCEPTION->decisionNum  = 19;
            	                    EXCEPTION->state        = 0;

            	                
            	                    goto ruleprofileExprEx;
            	                }
            	            }
            	            switch (alt19) 
            	            {
            	        	case 1:
            	        	    // AppArmor.g:605:7: path= UNQUOTED_PATH
            	        	    {
            	        	        path = (pANTLR3_COMMON_TOKEN)LT(1);
            	        	        MATCHT(UNQUOTED_PATH, &FOLLOW_UNQUOTED_PATH_in_profileExpr627); 


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // AppArmor.g:605:26: path= QUOTED_STRING
            	        	    {
            	        	        path = (pANTLR3_COMMON_TOKEN)LT(1);
            	        	        MATCHT(QUOTED_STRING, &FOLLOW_QUOTED_STRING_in_profileExpr631); 


            	        	    }
            	        	    break;

            	            }
            	        }
            	        {
            	             profileElement->mGroupType = ELEMENT_GROUP_SUBPROFILE; 
            	        }

            	    }
            	    break;
            	case 2:
            	    // AppArmor.g:607:8: 'profile' path= IDENT
            	    {
            	        MATCHT(39, &FOLLOW_39_in_profileExpr645); 

            	        path = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(IDENT, &FOLLOW_IDENT_in_profileExpr649); 

            	        {
            	            profileElement->mGroupType = ELEMENT_GROUP_TRANSITION_PROFILE;
            	        }

            	    }
            	    break;

                }
            }
            {
                 profileElement->pIdentifier = strdup((char *) path->getText(path)->chars); 
            }

            // AppArmor.g:612:2: ( ( 'flags' EQUALS )? LEFT_PAREN ( 'complain' | 'disabled' | 'audit' | 'fold_hats' )* RIGHT_PAREN )?
            {
                int alt23=2;
                {
                    int LA23_0 = LA(1);
                    if ( (LA23_0 == LEFT_PAREN || LA23_0 == 40) ) 
                    {
                        alt23=1;
                    }
                }
                switch (alt23) 
                {
            	case 1:
            	    // AppArmor.g:612:4: ( 'flags' EQUALS )? LEFT_PAREN ( 'complain' | 'disabled' | 'audit' | 'fold_hats' )* RIGHT_PAREN
            	    {

            	        // AppArmor.g:612:4: ( 'flags' EQUALS )?
            	        {
            	            int alt21=2;
            	            {
            	                int LA21_0 = LA(1);
            	                if ( (LA21_0 == 40) ) 
            	                {
            	                    alt21=1;
            	                }
            	            }
            	            switch (alt21) 
            	            {
            	        	case 1:
            	        	    // AppArmor.g:612:5: 'flags' EQUALS
            	        	    {
            	        	        MATCHT(40, &FOLLOW_40_in_profileExpr673); 

            	        	        MATCHT(EQUALS, &FOLLOW_EQUALS_in_profileExpr675); 


            	        	    }
            	        	    break;

            	            }
            	        }
            	        MATCHT(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_profileExpr679); 


            	        // AppArmor.g:613:3: ( 'complain' | 'disabled' | 'audit' | 'fold_hats' )*

            	        for (;;)
            	        {
            	            int alt22=5;
            	            switch ( LA(1) ) 
            	            {
            	            case 38:
            	            	{
            	            		alt22=1;
            	            	}
            	                break;
            	            case 37:
            	            	{
            	            		alt22=2;
            	            	}
            	                break;
            	            case 34:
            	            	{
            	            		alt22=3;
            	            	}
            	                break;
            	            case 41:
            	            	{
            	            		alt22=4;
            	            	}
            	                break;

            	            }

            	            switch (alt22) 
            	            {
            	        	case 1:
            	        	    // AppArmor.g:613:5: 'complain'
            	        	    {
            	        	        MATCHT(38, &FOLLOW_38_in_profileExpr685); 

            	        	        {
            	        	             flags |= GROUP_FLAG_COMPLAIN; 
            	        	        }

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // AppArmor.g:614:5: 'disabled'
            	        	    {
            	        	        MATCHT(37, &FOLLOW_37_in_profileExpr693); 

            	        	        {
            	        	             flags |= GROUP_FLAG_DISABLED; 
            	        	        }

            	        	    }
            	        	    break;
            	        	case 3:
            	        	    // AppArmor.g:615:5: 'audit'
            	        	    {
            	        	        MATCHT(34, &FOLLOW_34_in_profileExpr701); 

            	        	        {
            	        	             flags |= GROUP_FLAG_AUDIT; 
            	        	        }

            	        	    }
            	        	    break;
            	        	case 4:
            	        	    // AppArmor.g:616:5: 'fold_hats'
            	        	    {
            	        	        MATCHT(41, &FOLLOW_41_in_profileExpr709); 

            	        	        {
            	        	             flags |= GROUP_FLAG_FOLD_HATS; 
            	        	        }

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop22;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop22: ; /* Jump out to here if this rule does not match */

            	        MATCHT(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_profileExpr717); 


            	    }
            	    break;

                }
            }

            // AppArmor.g:619:2: ( endOfLineComment[newComment] )?
            {
                int alt24=2;
                {
                    int LA24_0 = LA(1);
                    if ( (LA24_0 == EOL_COMMENT) ) 
                    {
                        alt24=1;
                    }
                }
                switch (alt24) 
                {
            	case 1:
            	    // AppArmor.g:619:4: endOfLineComment[newComment]
            	    {
            	        FOLLOWPUSH(FOLLOW_endOfLineComment_in_profileExpr726);
            	        endOfLineComment(ctx, newComment);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprofileExprEx;
            	        }


            	    }
            	    break;

                }
            }
            MATCHT(LEFT_BRACE, &FOLLOW_LEFT_BRACE_in_profileExpr733); 


            // AppArmor.g:620:13: ( endOfLineComment[newComment] )?
            {
                int alt25=2;
                {
                    int LA25_0 = LA(1);
                    if ( (LA25_0 == EOL_COMMENT) ) 
                    {
                        alt25=1;
                    }
                }
                switch (alt25) 
                {
            	case 1:
            	    // AppArmor.g:620:15: endOfLineComment[newComment]
            	    {
            	        FOLLOWPUSH(FOLLOW_endOfLineComment_in_profileExpr737);
            	        endOfLineComment(ctx, newComment);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprofileExprEx;
            	        }


            	    }
            	    break;

                }
            }
            FOLLOWPUSH(FOLLOW_ruleExpr_in_profileExpr746);
            incomingRuleTree=ruleExpr(ctx);
            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleprofileExprEx;
            }

            {

                		if (incomingRuleTree != NULL)
                			add_parse_node_child(profileTree,
                						incomingRuleTree);
                	
            }
            MATCHT(RIGHT_BRACE, &FOLLOW_RIGHT_BRACE_in_profileExpr752); 


            // AppArmor.g:627:14: ( endOfLineComment[newComment] )?
            {
                int alt26=2;
                {
                    int LA26_0 = LA(1);
                    if ( (LA26_0 == EOL_COMMENT) ) 
                    {
                        alt26=1;
                    }
                }
                switch (alt26) 
                {
            	case 1:
            	    // AppArmor.g:627:16: endOfLineComment[newComment]
            	    {
            	        FOLLOWPUSH(FOLLOW_endOfLineComment_in_profileExpr756);
            	        endOfLineComment(ctx, newComment);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprofileExprEx;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleprofileExprEx; /* Prevent compiler warnings */
    ruleprofileExprEx: ;



    	if (HASEXCEPTION())
    	{
    		if (mpTree != NULL)
    		{
    			ParseError *error = new_parse_error();
    			if (mpTree->pError != NULL)
    				free_parse_error(mpTree->pError);
    			mpTree->mError = 1;
    			mpTree->pError = error;
    			error->mLine = EXCEPTION->line;
    			error->mPos = EXCEPTION->charPositionInLine;
    			
    			if (EXCEPTION->name != NULL)
    			error->pName = strdup(EXCEPTION->name);
    			
    			if (EXCEPTION->message != NULL)
    			error->pMessage = strdup((char *) EXCEPTION->message);
    		}
    	}

    return ;
}
/* $ANTLR end profileExpr */

/** 
 * $ANTLR start ruleExpr
 * AppArmor.g:633:1: ruleExpr returns [ParseNode *ruleExprTree] : ( newlineRule | startOfLineComment | includeExpr | (incomingRule= accessRule | incomingRule= capabilityRule | incomingRule= auditRule | incomingRule= changeProfileRule | incomingRule= networkRule ) | incomingIfTree= conditionalIfExpr | incomingElseTree= conditionalElseExpr )* ;
 */
static ParseNode *
ruleExpr(pAppArmorParser ctx)
{   
    ParseNode * ruleExprTree = NULL;

    ParseNode * incomingRule;
    #undef	RETURN_TYPE_incomingRule
    #define	RETURN_TYPE_incomingRule ParseNode *

    ParseNode * incomingIfTree;
    #undef	RETURN_TYPE_incomingIfTree
    #define	RETURN_TYPE_incomingIfTree ParseNode *

    ParseNode * incomingElseTree;
    #undef	RETURN_TYPE_incomingElseTree
    #define	RETURN_TYPE_incomingElseTree ParseNode *

    /* Initialize rule variables
     */



    		ParseNode *retTree = NULL;
    		ParseNode *conditionalParent = NULL;
    	
    incomingRule = NULL;
    incomingIfTree = NULL;
    incomingElseTree = NULL;

    {
        // AppArmor.g:638:2: ( ( newlineRule | startOfLineComment | includeExpr | (incomingRule= accessRule | incomingRule= capabilityRule | incomingRule= auditRule | incomingRule= changeProfileRule | incomingRule= networkRule ) | incomingIfTree= conditionalIfExpr | incomingElseTree= conditionalElseExpr )* )
        // AppArmor.g:639:2: ( newlineRule | startOfLineComment | includeExpr | (incomingRule= accessRule | incomingRule= capabilityRule | incomingRule= auditRule | incomingRule= changeProfileRule | incomingRule= networkRule ) | incomingIfTree= conditionalIfExpr | incomingElseTree= conditionalElseExpr )*
        {

            // AppArmor.g:639:2: ( newlineRule | startOfLineComment | includeExpr | (incomingRule= accessRule | incomingRule= capabilityRule | incomingRule= auditRule | incomingRule= changeProfileRule | incomingRule= networkRule ) | incomingIfTree= conditionalIfExpr | incomingElseTree= conditionalElseExpr )*

            for (;;)
            {
                int alt28=7;
                switch ( LA(1) ) 
                {
                case NEWLINE:
                	{
                		alt28=1;
                	}
                    break;
                case SOL_COMMENT:
                	{
                		alt28=2;
                	}
                    break;
                case INCLUDE:
                	{
                		alt28=3;
                	}
                    break;
                case UNQUOTED_PATH:
                case QUOTED_STRING:
                case LIST_VAR_START:
                case RULE:
                case 34:
                case 43:
                case 44:
                case 55:
                	{
                		alt28=4;
                	}
                    break;
                case 45:
                	{
                		alt28=5;
                	}
                    break;
                case 46:
                	{
                		alt28=6;
                	}
                    break;

                }

                switch (alt28) 
                {
            	case 1:
            	    // AppArmor.g:639:4: newlineRule
            	    {
            	        FOLLOWPUSH(FOLLOW_newlineRule_in_ruleExpr785);
            	        newlineRule(ctx);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleruleExprEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // AppArmor.g:640:4: startOfLineComment
            	    {
            	        FOLLOWPUSH(FOLLOW_startOfLineComment_in_ruleExpr790);
            	        startOfLineComment(ctx);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleruleExprEx;
            	        }


            	    }
            	    break;
            	case 3:
            	    // AppArmor.g:641:4: includeExpr
            	    {
            	        FOLLOWPUSH(FOLLOW_includeExpr_in_ruleExpr795);
            	        includeExpr(ctx);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleruleExprEx;
            	        }


            	    }
            	    break;
            	case 4:
            	    // AppArmor.g:642:4: (incomingRule= accessRule | incomingRule= capabilityRule | incomingRule= auditRule | incomingRule= changeProfileRule | incomingRule= networkRule )
            	    {

            	        // AppArmor.g:642:4: (incomingRule= accessRule | incomingRule= capabilityRule | incomingRule= auditRule | incomingRule= changeProfileRule | incomingRule= networkRule )
            	        {
            	            int alt27=5;
            	            switch ( LA(1) ) 
            	            {
            	            case UNQUOTED_PATH:
            	            case QUOTED_STRING:
            	            case LIST_VAR_START:
            	            case RULE:
            	            	{
            	            		alt27=1;
            	            	}
            	                break;
            	            case 44:
            	            	{
            	            		alt27=2;
            	            	}
            	                break;
            	            case 34:
            	            	{
            	            		alt27=3;
            	            	}
            	                break;
            	            case 43:
            	            	{
            	            		alt27=4;
            	            	}
            	                break;
            	            case 55:
            	            	{
            	            		alt27=5;
            	            	}
            	                break;

            	            default:
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = "642:4: (incomingRule= accessRule | incomingRule= capabilityRule | incomingRule= auditRule | incomingRule= changeProfileRule | incomingRule= networkRule )";
            	                EXCEPTION->decisionNum  = 27;
            	                EXCEPTION->state        = 0;


            	                goto ruleruleExprEx;
            	            }

            	            switch (alt27) 
            	            {
            	        	case 1:
            	        	    // AppArmor.g:642:6: incomingRule= accessRule
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_accessRule_in_ruleExpr806);
            	        	        incomingRule=accessRule(ctx);
            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleruleExprEx;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // AppArmor.g:643:6: incomingRule= capabilityRule
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_capabilityRule_in_ruleExpr817);
            	        	        incomingRule=capabilityRule(ctx);
            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleruleExprEx;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 3:
            	        	    // AppArmor.g:644:6: incomingRule= auditRule
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_auditRule_in_ruleExpr829);
            	        	        incomingRule=auditRule(ctx);
            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleruleExprEx;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 4:
            	        	    // AppArmor.g:645:6: incomingRule= changeProfileRule
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_changeProfileRule_in_ruleExpr840);
            	        	        incomingRule=changeProfileRule(ctx);
            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleruleExprEx;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 5:
            	        	    // AppArmor.g:646:6: incomingRule= networkRule
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_networkRule_in_ruleExpr851);
            	        	        incomingRule=networkRule(ctx);
            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleruleExprEx;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }
            	        {

            	            	  	conditionalParent = NULL;
            	            		/* We need to return a list of nodes, which is what this
            	            		 * is all about.
            	            		 */
            	            		if (retTree == NULL)
            	            			retTree = incomingRule;
            	            		else
            	            			add_parse_node_sibling(retTree, incomingRule);
            	            	    
            	        }

            	    }
            	    break;
            	case 5:
            	    // AppArmor.g:658:4: incomingIfTree= conditionalIfExpr
            	    {
            	        FOLLOWPUSH(FOLLOW_conditionalIfExpr_in_ruleExpr866);
            	        incomingIfTree=conditionalIfExpr(ctx);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleruleExprEx;
            	        }

            	        {

            	            		conditionalParent = incomingIfTree;
            	            		
            	            		if (retTree == NULL)
            	            			retTree = conditionalParent;
            	            		else
            	            			add_parse_node_sibling(retTree, conditionalParent);
            	            	  
            	        }

            	    }
            	    break;
            	case 6:
            	    // AppArmor.g:667:4: incomingElseTree= conditionalElseExpr
            	    {
            	        FOLLOWPUSH(FOLLOW_conditionalElseExpr_in_ruleExpr881);
            	        incomingElseTree=conditionalElseExpr(ctx);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleruleExprEx;
            	        }

            	        {

            	            	  	/* If conditionalParent is NULL, that means that
            	            		 * one of the other rules has been called in between
            	            		 * an if and an else, and we simply can't accept that.
            	            		 */
            	            		if (conditionalParent != NULL)
            	            		{
            	            		 	Conditional *tmp = (Conditional *) conditionalParent->pData;
            	            			tmp->pElseBranch = incomingElseTree;
            	            		}
            	            		else
            	            		{
            	            			 THROW_PARSER_EXCEPTION("else missing an if",ruleruleExprEx);
            	            		}
            	            	  
            	        }

            	    }
            	    break;

            	default:
            	    goto loop28;	/* break out of the loop */
            	    break;
                }
            }
            loop28: ; /* Jump out to here if this rule does not match */

            {
                 ruleExprTree= retTree; 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleruleExprEx; /* Prevent compiler warnings */
    ruleruleExprEx: ;



    	if (HASEXCEPTION())
    	{
    		if (mpTree != NULL)
    		{
    			ParseError *error = new_parse_error();
    			if (mpTree->pError != NULL)
    				free_parse_error(mpTree->pError);
    			mpTree->mError = 1;
    			mpTree->pError = error;
    			error->mLine = EXCEPTION->line;
    			error->mPos = EXCEPTION->charPositionInLine;
    			
    			if (EXCEPTION->name != NULL)
    			error->pName = strdup(EXCEPTION->name);
    			
    			if (EXCEPTION->message != NULL)
    			error->pMessage = strdup((char *) EXCEPTION->message);
    		}
    	}

    return ruleExprTree;
}
/* $ANTLR end ruleExpr */

/** 
 * $ANTLR start accessRule
 * AppArmor.g:690:1: accessRule returns [ParseNode *tree] : (path= accessPath rule= RULE ',' | rule= RULE path= accessPath ',' ) ( endOfLineComment[newComment] )? ;
 */
static ParseNode *
accessRule(pAppArmorParser ctx)
{   
    ParseNode * tree = NULL;

    pANTLR3_COMMON_TOKEN    rule;
    AppArmorParser_accessPath_return path;
    #undef	RETURN_TYPE_path
    #define	RETURN_TYPE_path AppArmorParser_accessPath_return

    /* Initialize rule variables
     */



    		tree= new_parse_node(ELEMENT_RULE, mpTree);
    		THROW_IF_NULL(tree,ruleaccessRuleEx);
    		
    		Comment *newComment = new_comment_node(NULL);
    		
    		Rule *newRule = new_rule_node();
    		THROW_IF_NULL(newRule,ruleaccessRuleEx);
    		tree->pData = newRule;
    		tree->pEOLComment = newComment;
    		AttachCommentBlock(tree);
    	
    rule       = NULL;

    {
        // AppArmor.g:704:2: ( (path= accessPath rule= RULE ',' | rule= RULE path= accessPath ',' ) ( endOfLineComment[newComment] )? )
        // AppArmor.g:704:3: (path= accessPath rule= RULE ',' | rule= RULE path= accessPath ',' ) ( endOfLineComment[newComment] )?
        {

            // AppArmor.g:704:3: (path= accessPath rule= RULE ',' | rule= RULE path= accessPath ',' )
            {
                int alt29=2;

                {
                    int LA29_0 = LA(1);
                    if ( (LA29_0 == UNQUOTED_PATH || ((LA29_0 >= QUOTED_STRING) && (LA29_0 <= LIST_VAR_START))) ) 
                    {
                        alt29=1;
                    }
                    else if ( (LA29_0 == RULE) ) 
                    {
                        alt29=2;
                    }
                    else 
                    {
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = "704:3: (path= accessPath rule= RULE ',' | rule= RULE path= accessPath ',' )";
                        EXCEPTION->decisionNum  = 29;
                        EXCEPTION->state        = 0;

                    
                        goto ruleaccessRuleEx;
                    }
                }
                switch (alt29) 
                {
            	case 1:
            	    // AppArmor.g:704:5: path= accessPath rule= RULE ','
            	    {
            	        FOLLOWPUSH(FOLLOW_accessPath_in_accessRule920);
            	        path=accessPath(ctx);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleaccessRuleEx;
            	        }

            	        rule = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(RULE, &FOLLOW_RULE_in_accessRule924); 

            	        MATCHT(42, &FOLLOW_42_in_accessRule926); 


            	    }
            	    break;
            	case 2:
            	    // AppArmor.g:705:4: rule= RULE path= accessPath ','
            	    {
            	        rule = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(RULE, &FOLLOW_RULE_in_accessRule933); 

            	        FOLLOWPUSH(FOLLOW_accessPath_in_accessRule937);
            	        path=accessPath(ctx);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleaccessRuleEx;
            	        }

            	        MATCHT(42, &FOLLOW_42_in_accessRule939); 


            	    }
            	    break;

                }
            }
            {

                		newRule->pResource = strdup((char *) path.path->chars);
                		/* If it's a QUOTED_STRING, it won't have a pExpandedPath.
                		 */
                		if (path.expandedPath->chars != NULL)
                		newRule->pExpandedResource = strdup((char *) path.expandedPath->chars);
                		newRule->pPermString = strdup((char *) rule->getText(rule)->chars);
                		/* TODO: convert permstring into a bitmask */
                	
            }

            // AppArmor.g:715:2: ( endOfLineComment[newComment] )?
            {
                int alt30=2;
                {
                    int LA30_0 = LA(1);
                    if ( (LA30_0 == EOL_COMMENT) ) 
                    {
                        alt30=1;
                    }
                }
                switch (alt30) 
                {
            	case 1:
            	    // AppArmor.g:715:4: endOfLineComment[newComment]
            	    {
            	        FOLLOWPUSH(FOLLOW_endOfLineComment_in_accessRule949);
            	        endOfLineComment(ctx, newComment);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleaccessRuleEx;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleaccessRuleEx; /* Prevent compiler warnings */
    ruleaccessRuleEx: ;



    	if (HASEXCEPTION())
    	{
    		if (mpTree != NULL)
    		{
    			ParseError *error = new_parse_error();
    			if (mpTree->pError != NULL)
    				free_parse_error(mpTree->pError);
    			mpTree->mError = 1;
    			mpTree->pError = error;
    			error->mLine = EXCEPTION->line;
    			error->mPos = EXCEPTION->charPositionInLine;
    			
    			if (EXCEPTION->name != NULL)
    			error->pName = strdup(EXCEPTION->name);
    			
    			if (EXCEPTION->message != NULL)
    			error->pMessage = strdup((char *) EXCEPTION->message);
    		}
    	}

    return tree;
}
/* $ANTLR end accessRule */

/** 
 * $ANTLR start accessPath
 * AppArmor.g:721:1: accessPath returns [pANTLR3_STRING path, pANTLR3_STRING expandedPath] : (u= QUOTED_STRING | ( LIST_VAR_START u= IDENT RIGHT_BRACE | u= UNQUOTED_PATH )+ );
 */
static AppArmorParser_accessPath_return
accessPath(pAppArmorParser ctx)
{   
    AppArmorParser_accessPath_return retval;

    pANTLR3_COMMON_TOKEN    u;

    /* Initialize rule variables
     */



    		retval.path= factory->newRaw(factory);
    		retval.expandedPath= factory->newRaw(factory);
    	
    u       = NULL;
    retval.start = LT(1);

    {
        {
            //  AppArmor.g:726:2: (u= QUOTED_STRING | ( LIST_VAR_START u= IDENT RIGHT_BRACE | u= UNQUOTED_PATH )+ )
            
            ANTLR3_UINT32 alt32;

            alt32=2;


            {
                int LA32_0 = LA(1);
                if ( (LA32_0 == QUOTED_STRING) ) 
                {
                    alt32=1;
                }
                else if ( (LA32_0 == UNQUOTED_PATH || LA32_0 == LIST_VAR_START) ) 
                {
                    alt32=2;
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = "721:1: accessPath returns [pANTLR3_STRING path, pANTLR3_STRING expandedPath] : (u= QUOTED_STRING | ( LIST_VAR_START u= IDENT RIGHT_BRACE | u= UNQUOTED_PATH )+ );";
                    EXCEPTION->decisionNum  = 32;
                    EXCEPTION->state        = 0;

                
                    goto ruleaccessPathEx;
                }
            }
            switch (alt32) 
            {
        	case 1:
        	    // AppArmor.g:726:4: u= QUOTED_STRING
        	    {
        	        u = (pANTLR3_COMMON_TOKEN)LT(1);
        	        MATCHT(QUOTED_STRING, &FOLLOW_QUOTED_STRING_in_accessPath979); 

        	        {

        	            		retval.path->setS(retval.path, u->getText(u));
        	            	
        	        }

        	    }
        	    break;
        	case 2:
        	    // AppArmor.g:731:2: ( LIST_VAR_START u= IDENT RIGHT_BRACE | u= UNQUOTED_PATH )+
        	    {
        	        // AppArmor.g:731:2: ( LIST_VAR_START u= IDENT RIGHT_BRACE | u= UNQUOTED_PATH )+
        	        {
        	            int cnt31=0;

        	            for (;;)
        	            {
        	                int alt31=3;
        	        	{
        	        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	        	    */
        	        	    int LA31_0 = LA(1);
        	        	    if ( (LA31_0 == LIST_VAR_START) ) 
        	        	    {
        	        	        alt31=1;
        	        	    }
        	        	    else if ( (LA31_0 == UNQUOTED_PATH) ) 
        	        	    {
        	        	        alt31=2;
        	        	    }

        	        	}
        	        	switch (alt31) 
        	        	{
        	        	    case 1:
        	        	        // AppArmor.g:731:4: LIST_VAR_START u= IDENT RIGHT_BRACE
        	        	        {
        	        	            MATCHT(LIST_VAR_START, &FOLLOW_LIST_VAR_START_in_accessPath990); 

        	        	            u = (pANTLR3_COMMON_TOKEN)LT(1);
        	        	            MATCHT(IDENT, &FOLLOW_IDENT_in_accessPath994); 

        	        	            MATCHT(RIGHT_BRACE, &FOLLOW_RIGHT_BRACE_in_accessPath996); 

        	        	            {

        	        	                	    	retval.path->append(retval.path, "${");
        	        	                		retval.path->appendS(retval.path, u->getText(u));
        	        	                		retval.path->append(retval.path, "}");
        	        	                		/* Expand the variables and insert them */
        	        	                		VariableList *list = find_variable_list_by_name
        	        	                					(mpTree->pVariableList,
        	        	                					(char *) u->getText(u)->chars);
        	        	                		if (list != NULL)
        	        	                		{
        	        	                			VariableListEntry *tmp = list->pFirstEntry;
        	        	                			while (tmp != NULL)
        	        	                			{
        	        	                				if (tmp->mIsBoolValue == 1) break;
        	        	                				if (tmp->mValues.pValue == NULL) break;
        	        	                				
        	        	                				retval.expandedPath->append(retval.expandedPath,
        	        	                							tmp->mValues.pValue);
        	        	                				tmp = tmp->pNext;
        	        	                			}
        	        	                		}
        	        	                	    
        	        	            }

        	        	        }
        	        	        break;
        	        	    case 2:
        	        	        // AppArmor.g:754:6: u= UNQUOTED_PATH
        	        	        {
        	        	            u = (pANTLR3_COMMON_TOKEN)LT(1);
        	        	            MATCHT(UNQUOTED_PATH, &FOLLOW_UNQUOTED_PATH_in_accessPath1012); 

        	        	            {

        	        	                	    	retval.path->appendS(retval.path, u->getText(u));
        	        	                		retval.expandedPath->appendS(retval.expandedPath, u->getText(u));
        	        	                	    
        	        	            }

        	        	        }
        	        	        break;

        	        	    default:
        	        	    
        	        		if ( cnt31 >= 1 )
        	        		{
        	        		    goto loop31;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = ANTLR3_EARLY_EXIT_NAME;


        	        		goto ruleaccessPathEx;
        	        	}
        	        	cnt31++;
        	            }
        	            loop31: ;	/* Jump to here if this rule does not match */
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleaccessPathEx; /* Prevent compiler warnings */
    ruleaccessPathEx: ;
    retval.stop = LT(-1);



    	if (HASEXCEPTION())
    	{
    		if (mpTree != NULL)
    		{
    			ParseError *error = new_parse_error();
    			if (mpTree->pError != NULL)
    				free_parse_error(mpTree->pError);
    			mpTree->mError = 1;
    			mpTree->pError = error;
    			error->mLine = EXCEPTION->line;
    			error->mPos = EXCEPTION->charPositionInLine;
    			
    			if (EXCEPTION->name != NULL)
    			error->pName = strdup(EXCEPTION->name);
    			
    			if (EXCEPTION->message != NULL)
    			error->pMessage = strdup((char *) EXCEPTION->message);
    		}
    	}

    return retval;
}
/* $ANTLR end accessPath */

/** 
 * $ANTLR start changeProfileRule
 * AppArmor.g:764:1: changeProfileRule returns [ParseNode *tree] : 'change_profile' path= UNQUOTED_PATH ;
 */
static ParseNode *
changeProfileRule(pAppArmorParser ctx)
{   
    ParseNode * tree = NULL;

    pANTLR3_COMMON_TOKEN    path;

    /* Initialize rule variables
     */



    		ChangeProfile *newProfile = new_change_profile_node();
    		THROW_IF_NULL(newProfile,rulechangeProfileRuleEx);
    		Comment *newComment = new_comment_node(NULL);
    		THROW_IF_NULL(newComment,rulechangeProfileRuleEx);
    		tree= new_parse_node(ELEMENT_CHANGE_PROFILE, mpTree);
    		THROW_IF_NULL(tree,rulechangeProfileRuleEx);
    		tree->pData = newProfile;
    		tree->pEOLComment = newComment;
    		AttachCommentBlock(tree);
    	
    path       = NULL;

    {
        // AppArmor.g:776:2: ( 'change_profile' path= UNQUOTED_PATH )
        // AppArmor.g:776:4: 'change_profile' path= UNQUOTED_PATH
        {
            MATCHT(43, &FOLLOW_43_in_changeProfileRule1048); 

            path = (pANTLR3_COMMON_TOKEN)LT(1);
            MATCHT(UNQUOTED_PATH, &FOLLOW_UNQUOTED_PATH_in_changeProfileRule1052); 

            {
                 newProfile->pProfile = strdup((char *) path->getText(path)->chars); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulechangeProfileRuleEx; /* Prevent compiler warnings */
    rulechangeProfileRuleEx: ;



    	if (HASEXCEPTION())
    	{
    		if (mpTree != NULL)
    		{
    			ParseError *error = new_parse_error();
    			if (mpTree->pError != NULL)
    				free_parse_error(mpTree->pError);
    			mpTree->mError = 1;
    			mpTree->pError = error;
    			error->mLine = EXCEPTION->line;
    			error->mPos = EXCEPTION->charPositionInLine;
    			
    			if (EXCEPTION->name != NULL)
    			error->pName = strdup(EXCEPTION->name);
    			
    			if (EXCEPTION->message != NULL)
    			error->pMessage = strdup((char *) EXCEPTION->message);
    		}
    	}

    return tree;
}
/* $ANTLR end changeProfileRule */

/** 
 * $ANTLR start capabilityRule
 * AppArmor.g:782:1: capabilityRule returns [ParseNode *tree] : 'capability' (incomingCapNode= capabilitiesSubExpr )+ ',' ( endOfLineComment[newComment] )? ;
 */
static ParseNode *
capabilityRule(pAppArmorParser ctx)
{   
    ParseNode * tree = NULL;

    ParseNode * incomingCapNode;
    #undef	RETURN_TYPE_incomingCapNode
    #define	RETURN_TYPE_incomingCapNode ParseNode *

    /* Initialize rule variables
     */



    		tree= NULL;
    		Comment *newComment;
    	
    incomingCapNode = NULL;

    {
        // AppArmor.g:787:2: ( 'capability' (incomingCapNode= capabilitiesSubExpr )+ ',' ( endOfLineComment[newComment] )? )
        // AppArmor.g:787:4: 'capability' (incomingCapNode= capabilitiesSubExpr )+ ',' ( endOfLineComment[newComment] )?
        {
            MATCHT(44, &FOLLOW_44_in_capabilityRule1078); 

            {
                 newComment = new_comment_node(NULL); 
            }
            // AppArmor.g:788:2: (incomingCapNode= capabilitiesSubExpr )+
            {
                int cnt33=0;

                for (;;)
                {
                    int alt33=2;
            	{
            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	    */
            	    int LA33_0 = LA(1);
            	    if ( (LA33_0 == IDENT || LA33_0 == QUOTED_STRING) ) 
            	    {
            	        alt33=1;
            	    }

            	}
            	switch (alt33) 
            	{
            	    case 1:
            	        // AppArmor.g:788:4: incomingCapNode= capabilitiesSubExpr
            	        {
            	            FOLLOWPUSH(FOLLOW_capabilitiesSubExpr_in_capabilityRule1087);
            	            incomingCapNode=capabilitiesSubExpr(ctx);
            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulecapabilityRuleEx;
            	            }

            	            {

            	                	  	if (tree == NULL)
            	                		{
            	                			tree= incomingCapNode;
            	                			AttachCommentBlock(tree);
            	                			tree->pEOLComment = newComment;
            	                		}
            	                		else
            	                		{
            	                			add_parse_node_sibling(tree, incomingCapNode);
            	                		}
            	                	
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt33 >= 1 )
            		{
            		    goto loop33;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = ANTLR3_EARLY_EXIT_NAME;


            		goto rulecapabilityRuleEx;
            	}
            	cnt33++;
                }
                loop33: ;	/* Jump to here if this rule does not match */
            }
            MATCHT(42, &FOLLOW_42_in_capabilityRule1096); 


            // AppArmor.g:801:2: ( endOfLineComment[newComment] )?
            {
                int alt34=2;
                {
                    int LA34_0 = LA(1);
                    if ( (LA34_0 == EOL_COMMENT) ) 
                    {
                        alt34=1;
                    }
                }
                switch (alt34) 
                {
            	case 1:
            	    // AppArmor.g:801:4: endOfLineComment[newComment]
            	    {
            	        FOLLOWPUSH(FOLLOW_endOfLineComment_in_capabilityRule1101);
            	        endOfLineComment(ctx, newComment);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecapabilityRuleEx;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecapabilityRuleEx; /* Prevent compiler warnings */
    rulecapabilityRuleEx: ;



    	if (HASEXCEPTION())
    	{
    		if (mpTree != NULL)
    		{
    			ParseError *error = new_parse_error();
    			if (mpTree->pError != NULL)
    				free_parse_error(mpTree->pError);
    			mpTree->mError = 1;
    			mpTree->pError = error;
    			error->mLine = EXCEPTION->line;
    			error->mPos = EXCEPTION->charPositionInLine;
    			
    			if (EXCEPTION->name != NULL)
    			error->pName = strdup(EXCEPTION->name);
    			
    			if (EXCEPTION->message != NULL)
    			error->pMessage = strdup((char *) EXCEPTION->message);
    		}
    	}

    return tree;
}
/* $ANTLR end capabilityRule */

/** 
 * $ANTLR start capabilitiesSubExpr
 * AppArmor.g:805:1: capabilitiesSubExpr returns [ParseNode *node] : (capIdent= IDENT | capIdent= QUOTED_STRING ) ;
 */
static ParseNode *
capabilitiesSubExpr(pAppArmorParser ctx)
{   
    ParseNode * node = NULL;

    pANTLR3_COMMON_TOKEN    capIdent;

    /* Initialize rule variables
     */



    		ParseNode *capabilityNode = new_parse_node(ELEMENT_CAPABILITY,
    								mpTree);
    		THROW_IF_NULL(capabilityNode,rulecapabilitiesSubExprEx);
    		Capability *capability = new_capability_node();
    		THROW_IF_NULL(capability,rulecapabilitiesSubExprEx);
    		capabilityNode->pData = capability;
    		node= capabilityNode;
    	
    capIdent       = NULL;

    {
        // AppArmor.g:815:2: ( (capIdent= IDENT | capIdent= QUOTED_STRING ) )
        // AppArmor.g:816:2: (capIdent= IDENT | capIdent= QUOTED_STRING )
        {

            // AppArmor.g:816:2: (capIdent= IDENT | capIdent= QUOTED_STRING )
            {
                int alt35=2;

                {
                    int LA35_0 = LA(1);
                    if ( (LA35_0 == IDENT) ) 
                    {
                        alt35=1;
                    }
                    else if ( (LA35_0 == QUOTED_STRING) ) 
                    {
                        alt35=2;
                    }
                    else 
                    {
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = "816:2: (capIdent= IDENT | capIdent= QUOTED_STRING )";
                        EXCEPTION->decisionNum  = 35;
                        EXCEPTION->state        = 0;

                    
                        goto rulecapabilitiesSubExprEx;
                    }
                }
                switch (alt35) 
                {
            	case 1:
            	    // AppArmor.g:816:3: capIdent= IDENT
            	    {
            	        capIdent = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(IDENT, &FOLLOW_IDENT_in_capabilitiesSubExpr1132); 


            	    }
            	    break;
            	case 2:
            	    // AppArmor.g:816:20: capIdent= QUOTED_STRING
            	    {
            	        capIdent = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(QUOTED_STRING, &FOLLOW_QUOTED_STRING_in_capabilitiesSubExpr1138); 


            	    }
            	    break;

                }
            }
            {

                		capability->pCapability = strdup((char *) capIdent->getText(capIdent)->chars);
                	
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecapabilitiesSubExprEx; /* Prevent compiler warnings */
    rulecapabilitiesSubExprEx: ;



    	if (HASEXCEPTION())
    	{
    		if (mpTree != NULL)
    		{
    			ParseError *error = new_parse_error();
    			if (mpTree->pError != NULL)
    				free_parse_error(mpTree->pError);
    			mpTree->mError = 1;
    			mpTree->pError = error;
    			error->mLine = EXCEPTION->line;
    			error->mPos = EXCEPTION->charPositionInLine;
    			
    			if (EXCEPTION->name != NULL)
    			error->pName = strdup(EXCEPTION->name);
    			
    			if (EXCEPTION->message != NULL)
    			error->pMessage = strdup((char *) EXCEPTION->message);
    		}
    	}

    return node;
}
/* $ANTLR end capabilitiesSubExpr */

/** 
 * $ANTLR start auditRule
 * AppArmor.g:831:1: auditRule returns [ParseNode *tree] : 'audit' ( endOfLineComment[newComment] )? LEFT_BRACE ( endOfLineComment[newComment] )? (incomingTree= accessRule )* RIGHT_BRACE ( endOfLineComment[newComment] )? ;
 */
static ParseNode *
auditRule(pAppArmorParser ctx)
{   
    ParseNode * tree = NULL;

    ParseNode * incomingTree;
    #undef	RETURN_TYPE_incomingTree
    #define	RETURN_TYPE_incomingTree ParseNode *

    /* Initialize rule variables
     */



    		Group *auditBlock;
    		auditBlock = new_group_node(ELEMENT_GROUP_AUDIT);
    		THROW_IF_NULL(auditBlock,ruleauditRuleEx);
    		tree= new_parse_node(ELEMENT_GROUP, mpTree);
    		THROW_IF_NULL(tree,ruleauditRuleEx);
    		tree->pData = auditBlock;
    		
    		Comment *newComment = new_comment_node(NULL);
    		AttachCommentBlock(tree);
    		tree->pEOLComment = newComment;
    	
    incomingTree = NULL;

    {
        // AppArmor.g:844:2: ( 'audit' ( endOfLineComment[newComment] )? LEFT_BRACE ( endOfLineComment[newComment] )? (incomingTree= accessRule )* RIGHT_BRACE ( endOfLineComment[newComment] )? )
        // AppArmor.g:844:4: 'audit' ( endOfLineComment[newComment] )? LEFT_BRACE ( endOfLineComment[newComment] )? (incomingTree= accessRule )* RIGHT_BRACE ( endOfLineComment[newComment] )?
        {
            MATCHT(34, &FOLLOW_34_in_auditRule1165); 


            // AppArmor.g:844:12: ( endOfLineComment[newComment] )?
            {
                int alt36=2;
                {
                    int LA36_0 = LA(1);
                    if ( (LA36_0 == EOL_COMMENT) ) 
                    {
                        alt36=1;
                    }
                }
                switch (alt36) 
                {
            	case 1:
            	    // AppArmor.g:844:14: endOfLineComment[newComment]
            	    {
            	        FOLLOWPUSH(FOLLOW_endOfLineComment_in_auditRule1169);
            	        endOfLineComment(ctx, newComment);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleauditRuleEx;
            	        }


            	    }
            	    break;

                }
            }
            MATCHT(LEFT_BRACE, &FOLLOW_LEFT_BRACE_in_auditRule1177); 


            // AppArmor.g:845:13: ( endOfLineComment[newComment] )?
            {
                int alt37=2;
                {
                    int LA37_0 = LA(1);
                    if ( (LA37_0 == EOL_COMMENT) ) 
                    {
                        alt37=1;
                    }
                }
                switch (alt37) 
                {
            	case 1:
            	    // AppArmor.g:845:15: endOfLineComment[newComment]
            	    {
            	        FOLLOWPUSH(FOLLOW_endOfLineComment_in_auditRule1181);
            	        endOfLineComment(ctx, newComment);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleauditRuleEx;
            	        }


            	    }
            	    break;

                }
            }

            // AppArmor.g:846:2: (incomingTree= accessRule )*

            for (;;)
            {
                int alt38=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA38_0 = LA(1);
                    if ( (LA38_0 == UNQUOTED_PATH || ((LA38_0 >= QUOTED_STRING) && (LA38_0 <= LIST_VAR_START)) || LA38_0 == RULE) ) 
                    {
                        alt38=1;
                    }

                }
                switch (alt38) 
                {
            	case 1:
            	    // AppArmor.g:846:4: incomingTree= accessRule
            	    {
            	        FOLLOWPUSH(FOLLOW_accessRule_in_auditRule1192);
            	        incomingTree=accessRule(ctx);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleauditRuleEx;
            	        }

            	        {
            	             add_parse_node_child(tree, incomingTree); 
            	        }

            	    }
            	    break;

            	default:
            	    goto loop38;	/* break out of the loop */
            	    break;
                }
            }
            loop38: ; /* Jump out to here if this rule does not match */

            MATCHT(RIGHT_BRACE, &FOLLOW_RIGHT_BRACE_in_auditRule1204); 


            // AppArmor.g:849:14: ( endOfLineComment[newComment] )?
            {
                int alt39=2;
                {
                    int LA39_0 = LA(1);
                    if ( (LA39_0 == EOL_COMMENT) ) 
                    {
                        alt39=1;
                    }
                }
                switch (alt39) 
                {
            	case 1:
            	    // AppArmor.g:849:16: endOfLineComment[newComment]
            	    {
            	        FOLLOWPUSH(FOLLOW_endOfLineComment_in_auditRule1208);
            	        endOfLineComment(ctx, newComment);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleauditRuleEx;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleauditRuleEx; /* Prevent compiler warnings */
    ruleauditRuleEx: ;



    	if (HASEXCEPTION())
    	{
    		if (mpTree != NULL)
    		{
    			ParseError *error = new_parse_error();
    			if (mpTree->pError != NULL)
    				free_parse_error(mpTree->pError);
    			mpTree->mError = 1;
    			mpTree->pError = error;
    			error->mLine = EXCEPTION->line;
    			error->mPos = EXCEPTION->charPositionInLine;
    			
    			if (EXCEPTION->name != NULL)
    			error->pName = strdup(EXCEPTION->name);
    			
    			if (EXCEPTION->message != NULL)
    			error->pMessage = strdup((char *) EXCEPTION->message);
    		}
    	}

    return tree;
}
/* $ANTLR end auditRule */

/** 
 * $ANTLR start conditionalIfExpr
 * AppArmor.g:867:1: conditionalIfExpr returns [ParseNode *tree] : 'if' LEFT_PAREN condExpr= ifExpr RIGHT_PAREN ( endOfLineComment[newComment] )? LEFT_BRACE ( endOfLineComment[newComment] )? ifTree= conditionalRules RIGHT_BRACE ( endOfLineComment[newComment] )? ;
 */
static ParseNode *
conditionalIfExpr(pAppArmorParser ctx)
{   
    ParseNode * tree = NULL;

    AppArmorParser_ifExpr_return condExpr;
    #undef	RETURN_TYPE_condExpr
    #define	RETURN_TYPE_condExpr AppArmorParser_ifExpr_return

    ParseNode * ifTree;
    #undef	RETURN_TYPE_ifTree
    #define	RETURN_TYPE_ifTree ParseNode *

    /* Initialize rule variables
     */



    		Conditional *ifConditional = new_conditional_node();
    		THROW_IF_NULL(ifConditional,ruleconditionalIfExprEx);
    		tree= new_parse_node(ELEMENT_CONDITIONAL, mpTree);
    		THROW_IF_NULL(tree,ruleconditionalIfExprEx);
    		tree->pData = ifConditional;
    		AttachCommentBlock(tree);
    		
    		Comment *newComment = new_comment_node(NULL);
    		tree->pEOLComment = newComment;
    	

    ifTree = NULL;

    {
        // AppArmor.g:880:2: ( 'if' LEFT_PAREN condExpr= ifExpr RIGHT_PAREN ( endOfLineComment[newComment] )? LEFT_BRACE ( endOfLineComment[newComment] )? ifTree= conditionalRules RIGHT_BRACE ( endOfLineComment[newComment] )? )
        // AppArmor.g:880:4: 'if' LEFT_PAREN condExpr= ifExpr RIGHT_PAREN ( endOfLineComment[newComment] )? LEFT_BRACE ( endOfLineComment[newComment] )? ifTree= conditionalRules RIGHT_BRACE ( endOfLineComment[newComment] )?
        {
            MATCHT(45, &FOLLOW_45_in_conditionalIfExpr1239); 

            MATCHT(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_conditionalIfExpr1241); 

            FOLLOWPUSH(FOLLOW_ifExpr_in_conditionalIfExpr1245);
            condExpr=ifExpr(ctx);
            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconditionalIfExprEx;
            }

            MATCHT(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_conditionalIfExpr1247); 

            {
                 
                			ifConditional->pExpr = condExpr.expr;
                			ifConditional->pConditionalString =
                					strdup((char *)condExpr.string->chars);
                		
            }

            // AppArmor.g:886:3: ( endOfLineComment[newComment] )?
            {
                int alt40=2;
                {
                    int LA40_0 = LA(1);
                    if ( (LA40_0 == EOL_COMMENT) ) 
                    {
                        alt40=1;
                    }
                }
                switch (alt40) 
                {
            	case 1:
            	    // AppArmor.g:886:5: endOfLineComment[newComment]
            	    {
            	        FOLLOWPUSH(FOLLOW_endOfLineComment_in_conditionalIfExpr1257);
            	        endOfLineComment(ctx, newComment);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleconditionalIfExprEx;
            	        }


            	    }
            	    break;

                }
            }
            MATCHT(LEFT_BRACE, &FOLLOW_LEFT_BRACE_in_conditionalIfExpr1264); 


            // AppArmor.g:887:13: ( endOfLineComment[newComment] )?
            {
                int alt41=2;
                {
                    int LA41_0 = LA(1);
                    if ( (LA41_0 == EOL_COMMENT) ) 
                    {
                        alt41=1;
                    }
                }
                switch (alt41) 
                {
            	case 1:
            	    // AppArmor.g:887:15: endOfLineComment[newComment]
            	    {
            	        FOLLOWPUSH(FOLLOW_endOfLineComment_in_conditionalIfExpr1268);
            	        endOfLineComment(ctx, newComment);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleconditionalIfExprEx;
            	        }


            	    }
            	    break;

                }
            }
            FOLLOWPUSH(FOLLOW_conditionalRules_in_conditionalIfExpr1277);
            ifTree=conditionalRules(ctx);
            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconditionalIfExprEx;
            }

            {

                		ifConditional->pIfBranch = ifTree;
                	
            }
            MATCHT(RIGHT_BRACE, &FOLLOW_RIGHT_BRACE_in_conditionalIfExpr1283); 


            // AppArmor.g:892:14: ( endOfLineComment[newComment] )?
            {
                int alt42=2;
                {
                    int LA42_0 = LA(1);
                    if ( (LA42_0 == EOL_COMMENT) ) 
                    {
                        alt42=1;
                    }
                }
                switch (alt42) 
                {
            	case 1:
            	    // AppArmor.g:892:16: endOfLineComment[newComment]
            	    {
            	        FOLLOWPUSH(FOLLOW_endOfLineComment_in_conditionalIfExpr1287);
            	        endOfLineComment(ctx, newComment);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleconditionalIfExprEx;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleconditionalIfExprEx; /* Prevent compiler warnings */
    ruleconditionalIfExprEx: ;



    	if (HASEXCEPTION())
    	{
    		if (mpTree != NULL)
    		{
    			ParseError *error = new_parse_error();
    			if (mpTree->pError != NULL)
    				free_parse_error(mpTree->pError);
    			mpTree->mError = 1;
    			mpTree->pError = error;
    			error->mLine = EXCEPTION->line;
    			error->mPos = EXCEPTION->charPositionInLine;
    			
    			if (EXCEPTION->name != NULL)
    			error->pName = strdup(EXCEPTION->name);
    			
    			if (EXCEPTION->message != NULL)
    			error->pMessage = strdup((char *) EXCEPTION->message);
    		}
    	}

    return tree;
}
/* $ANTLR end conditionalIfExpr */

/** 
 * $ANTLR start conditionalElseExpr
 * AppArmor.g:895:1: conditionalElseExpr returns [ParseNode *tree] : 'else' ( endOfLineComment[newComment] )? LEFT_BRACE ( endOfLineComment[newComment] )? elseRules= conditionalRules RIGHT_BRACE ( endOfLineComment[newComment] )? ;
 */
static ParseNode *
conditionalElseExpr(pAppArmorParser ctx)
{   
    ParseNode * tree = NULL;

    ParseNode * elseRules;
    #undef	RETURN_TYPE_elseRules
    #define	RETURN_TYPE_elseRules ParseNode *

    /* Initialize rule variables
     */



    		Conditional *elseConditional;
    		elseConditional = new_conditional_node();
    		THROW_IF_NULL(elseConditional,ruleconditionalElseExprEx);
    		
    		tree= new_parse_node(ELEMENT_CONDITIONAL_ELSE, mpTree);
    		THROW_IF_NULL(tree,ruleconditionalElseExprEx);
    		tree->pData = elseConditional;
    		
    		Comment *newComment = new_comment_node(NULL);
    		THROW_IF_NULL(newComment,ruleconditionalElseExprEx);
    		tree->pEOLComment = newComment;
    		AttachCommentBlock(tree);
    	
    elseRules = NULL;

    {
        // AppArmor.g:910:2: ( 'else' ( endOfLineComment[newComment] )? LEFT_BRACE ( endOfLineComment[newComment] )? elseRules= conditionalRules RIGHT_BRACE ( endOfLineComment[newComment] )? )
        // AppArmor.g:910:4: 'else' ( endOfLineComment[newComment] )? LEFT_BRACE ( endOfLineComment[newComment] )? elseRules= conditionalRules RIGHT_BRACE ( endOfLineComment[newComment] )?
        {
            MATCHT(46, &FOLLOW_46_in_conditionalElseExpr1312); 


            // AppArmor.g:910:11: ( endOfLineComment[newComment] )?
            {
                int alt43=2;
                {
                    int LA43_0 = LA(1);
                    if ( (LA43_0 == EOL_COMMENT) ) 
                    {
                        alt43=1;
                    }
                }
                switch (alt43) 
                {
            	case 1:
            	    // AppArmor.g:910:13: endOfLineComment[newComment]
            	    {
            	        FOLLOWPUSH(FOLLOW_endOfLineComment_in_conditionalElseExpr1316);
            	        endOfLineComment(ctx, newComment);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleconditionalElseExprEx;
            	        }


            	    }
            	    break;

                }
            }
            MATCHT(LEFT_BRACE, &FOLLOW_LEFT_BRACE_in_conditionalElseExpr1322); 


            // AppArmor.g:911:2: ( endOfLineComment[newComment] )?
            {
                int alt44=2;
                {
                    int LA44_0 = LA(1);
                    if ( (LA44_0 == EOL_COMMENT) ) 
                    {
                        alt44=1;
                    }
                }
                switch (alt44) 
                {
            	case 1:
            	    // AppArmor.g:911:4: endOfLineComment[newComment]
            	    {
            	        FOLLOWPUSH(FOLLOW_endOfLineComment_in_conditionalElseExpr1327);
            	        endOfLineComment(ctx, newComment);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleconditionalElseExprEx;
            	        }


            	    }
            	    break;

                }
            }
            FOLLOWPUSH(FOLLOW_conditionalRules_in_conditionalElseExpr1336);
            elseRules=conditionalRules(ctx);
            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconditionalElseExprEx;
            }

            {
                 
                		if (elseRules != NULL)
                		add_parse_node_child(tree, elseRules);
                	
            }
            MATCHT(RIGHT_BRACE, &FOLLOW_RIGHT_BRACE_in_conditionalElseExpr1342); 


            // AppArmor.g:917:14: ( endOfLineComment[newComment] )?
            {
                int alt45=2;
                {
                    int LA45_0 = LA(1);
                    if ( (LA45_0 == EOL_COMMENT) ) 
                    {
                        alt45=1;
                    }
                }
                switch (alt45) 
                {
            	case 1:
            	    // AppArmor.g:917:16: endOfLineComment[newComment]
            	    {
            	        FOLLOWPUSH(FOLLOW_endOfLineComment_in_conditionalElseExpr1346);
            	        endOfLineComment(ctx, newComment);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleconditionalElseExprEx;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleconditionalElseExprEx; /* Prevent compiler warnings */
    ruleconditionalElseExprEx: ;



    	if (HASEXCEPTION())
    	{
    		if (mpTree != NULL)
    		{
    			ParseError *error = new_parse_error();
    			if (mpTree->pError != NULL)
    				free_parse_error(mpTree->pError);
    			mpTree->mError = 1;
    			mpTree->pError = error;
    			error->mLine = EXCEPTION->line;
    			error->mPos = EXCEPTION->charPositionInLine;
    			
    			if (EXCEPTION->name != NULL)
    			error->pName = strdup(EXCEPTION->name);
    			
    			if (EXCEPTION->message != NULL)
    			error->pMessage = strdup((char *) EXCEPTION->message);
    		}
    	}

    return tree;
}
/* $ANTLR end conditionalElseExpr */

/** 
 * $ANTLR start conditionalRules
 * AppArmor.g:920:1: conditionalRules returns [ParseNode *tree] : ( newlineRule | startOfLineComment | (incomingTree= accessRule | incomingTree= capabilityRule | incomingTree= auditRule | incomingTree= builtInFunctions ) )* ;
 */
static ParseNode *
conditionalRules(pAppArmorParser ctx)
{   
    ParseNode * tree = NULL;

    ParseNode * incomingTree;
    #undef	RETURN_TYPE_incomingTree
    #define	RETURN_TYPE_incomingTree ParseNode *

    /* Initialize rule variables
     */



    		tree= NULL;
    	
    incomingTree = NULL;

    {
        // AppArmor.g:924:2: ( ( newlineRule | startOfLineComment | (incomingTree= accessRule | incomingTree= capabilityRule | incomingTree= auditRule | incomingTree= builtInFunctions ) )* )
        // AppArmor.g:925:2: ( newlineRule | startOfLineComment | (incomingTree= accessRule | incomingTree= capabilityRule | incomingTree= auditRule | incomingTree= builtInFunctions ) )*
        {

            // AppArmor.g:925:2: ( newlineRule | startOfLineComment | (incomingTree= accessRule | incomingTree= capabilityRule | incomingTree= auditRule | incomingTree= builtInFunctions ) )*

            for (;;)
            {
                int alt47=4;
                switch ( LA(1) ) 
                {
                case NEWLINE:
                	{
                		alt47=1;
                	}
                    break;
                case SOL_COMMENT:
                	{
                		alt47=2;
                	}
                    break;
                case UNQUOTED_PATH:
                case QUOTED_STRING:
                case LIST_VAR_START:
                case RULE:
                case 34:
                case 44:
                case 47:
                case 48:
                case 49:
                	{
                		alt47=3;
                	}
                    break;

                }

                switch (alt47) 
                {
            	case 1:
            	    // AppArmor.g:925:4: newlineRule
            	    {
            	        FOLLOWPUSH(FOLLOW_newlineRule_in_conditionalRules1374);
            	        newlineRule(ctx);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleconditionalRulesEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // AppArmor.g:926:4: startOfLineComment
            	    {
            	        FOLLOWPUSH(FOLLOW_startOfLineComment_in_conditionalRules1379);
            	        startOfLineComment(ctx);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleconditionalRulesEx;
            	        }


            	    }
            	    break;
            	case 3:
            	    // AppArmor.g:927:4: (incomingTree= accessRule | incomingTree= capabilityRule | incomingTree= auditRule | incomingTree= builtInFunctions )
            	    {

            	        // AppArmor.g:927:4: (incomingTree= accessRule | incomingTree= capabilityRule | incomingTree= auditRule | incomingTree= builtInFunctions )
            	        {
            	            int alt46=4;
            	            switch ( LA(1) ) 
            	            {
            	            case UNQUOTED_PATH:
            	            case QUOTED_STRING:
            	            case LIST_VAR_START:
            	            case RULE:
            	            	{
            	            		alt46=1;
            	            	}
            	                break;
            	            case 44:
            	            	{
            	            		alt46=2;
            	            	}
            	                break;
            	            case 34:
            	            	{
            	            		alt46=3;
            	            	}
            	                break;
            	            case 47:
            	            case 48:
            	            case 49:
            	            	{
            	            		alt46=4;
            	            	}
            	                break;

            	            default:
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = "927:4: (incomingTree= accessRule | incomingTree= capabilityRule | incomingTree= auditRule | incomingTree= builtInFunctions )";
            	                EXCEPTION->decisionNum  = 46;
            	                EXCEPTION->state        = 0;


            	                goto ruleconditionalRulesEx;
            	            }

            	            switch (alt46) 
            	            {
            	        	case 1:
            	        	    // AppArmor.g:927:6: incomingTree= accessRule
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_accessRule_in_conditionalRules1388);
            	        	        incomingTree=accessRule(ctx);
            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleconditionalRulesEx;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // AppArmor.g:928:6: incomingTree= capabilityRule
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_capabilityRule_in_conditionalRules1397);
            	        	        incomingTree=capabilityRule(ctx);
            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleconditionalRulesEx;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 3:
            	        	    // AppArmor.g:929:6: incomingTree= auditRule
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_auditRule_in_conditionalRules1406);
            	        	        incomingTree=auditRule(ctx);
            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleconditionalRulesEx;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 4:
            	        	    // AppArmor.g:930:6: incomingTree= builtInFunctions
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_builtInFunctions_in_conditionalRules1415);
            	        	        incomingTree=builtInFunctions(ctx);
            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleconditionalRulesEx;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }
            	        {

            	            	  	if (tree == NULL)
            	            			tree= incomingTree;
            	            		else
            	            			add_parse_node_sibling(tree, incomingTree);
            	            	  
            	        }

            	    }
            	    break;

            	default:
            	    goto loop47;	/* break out of the loop */
            	    break;
                }
            }
            loop47: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleconditionalRulesEx; /* Prevent compiler warnings */
    ruleconditionalRulesEx: ;



    	if (HASEXCEPTION())
    	{
    		if (mpTree != NULL)
    		{
    			ParseError *error = new_parse_error();
    			if (mpTree->pError != NULL)
    				free_parse_error(mpTree->pError);
    			mpTree->mError = 1;
    			mpTree->pError = error;
    			error->mLine = EXCEPTION->line;
    			error->mPos = EXCEPTION->charPositionInLine;
    			
    			if (EXCEPTION->name != NULL)
    			error->pName = strdup(EXCEPTION->name);
    			
    			if (EXCEPTION->message != NULL)
    			error->pMessage = strdup((char *) EXCEPTION->message);
    		}
    	}

    return tree;
}
/* $ANTLR end conditionalRules */

/** 
 * $ANTLR start builtInFunctions
 * AppArmor.g:940:1: builtInFunctions returns [ParseNode *tree] : ( 'error' LEFT_PAREN funcData= QUOTED_STRING RIGHT_PAREN | 'undef' LEFT_PAREN LIST_VAR_START funcData= IDENT RIGHT_BRACE RIGHT_PAREN | 'warn' LEFT_PAREN funcData= QUOTED_STRING RIGHT_PAREN ) ( endOfLineComment[newComment] )? ;
 */
static ParseNode *
builtInFunctions(pAppArmorParser ctx)
{   
    ParseNode * tree = NULL;

    pANTLR3_COMMON_TOKEN    funcData;

    /* Initialize rule variables
     */



    		Function *newFunction = new_function_node();
    		THROW_IF_NULL(newFunction,rulebuiltInFunctionsEx);

    		tree= new_parse_node(ELEMENT_FUNCTION, mpTree);
    		THROW_IF_NULL(tree,rulebuiltInFunctionsEx);
    		tree->pData = newFunction;

    		Comment *newComment = new_comment_node(NULL);
    		THROW_IF_NULL(newComment,rulebuiltInFunctionsEx);

    		tree->pEOLComment = newComment;
    		AttachCommentBlock(tree);
    	
    funcData       = NULL;

    {
        // AppArmor.g:955:2: ( ( 'error' LEFT_PAREN funcData= QUOTED_STRING RIGHT_PAREN | 'undef' LEFT_PAREN LIST_VAR_START funcData= IDENT RIGHT_BRACE RIGHT_PAREN | 'warn' LEFT_PAREN funcData= QUOTED_STRING RIGHT_PAREN ) ( endOfLineComment[newComment] )? )
        // AppArmor.g:956:2: ( 'error' LEFT_PAREN funcData= QUOTED_STRING RIGHT_PAREN | 'undef' LEFT_PAREN LIST_VAR_START funcData= IDENT RIGHT_BRACE RIGHT_PAREN | 'warn' LEFT_PAREN funcData= QUOTED_STRING RIGHT_PAREN ) ( endOfLineComment[newComment] )?
        {

            // AppArmor.g:956:2: ( 'error' LEFT_PAREN funcData= QUOTED_STRING RIGHT_PAREN | 'undef' LEFT_PAREN LIST_VAR_START funcData= IDENT RIGHT_BRACE RIGHT_PAREN | 'warn' LEFT_PAREN funcData= QUOTED_STRING RIGHT_PAREN )
            {
                int alt48=3;
                switch ( LA(1) ) 
                {
                case 47:
                	{
                		alt48=1;
                	}
                    break;
                case 48:
                	{
                		alt48=2;
                	}
                    break;
                case 49:
                	{
                		alt48=3;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = "956:2: ( 'error' LEFT_PAREN funcData= QUOTED_STRING RIGHT_PAREN | 'undef' LEFT_PAREN LIST_VAR_START funcData= IDENT RIGHT_BRACE RIGHT_PAREN | 'warn' LEFT_PAREN funcData= QUOTED_STRING RIGHT_PAREN )";
                    EXCEPTION->decisionNum  = 48;
                    EXCEPTION->state        = 0;


                    goto rulebuiltInFunctionsEx;
                }

                switch (alt48) 
                {
            	case 1:
            	    // AppArmor.g:956:4: 'error' LEFT_PAREN funcData= QUOTED_STRING RIGHT_PAREN
            	    {
            	        MATCHT(47, &FOLLOW_47_in_builtInFunctions1450); 

            	        MATCHT(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_builtInFunctions1452); 

            	        funcData = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(QUOTED_STRING, &FOLLOW_QUOTED_STRING_in_builtInFunctions1456); 

            	        MATCHT(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_builtInFunctions1458); 

            	        {
            	             newFunction->mFunctionType = ELEMENT_FUNCTION_ERROR; 
            	        }

            	    }
            	    break;
            	case 2:
            	    // AppArmor.g:958:4: 'undef' LEFT_PAREN LIST_VAR_START funcData= IDENT RIGHT_BRACE RIGHT_PAREN
            	    {
            	        MATCHT(48, &FOLLOW_48_in_builtInFunctions1467); 

            	        MATCHT(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_builtInFunctions1469); 

            	        MATCHT(LIST_VAR_START, &FOLLOW_LIST_VAR_START_in_builtInFunctions1471); 

            	        funcData = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(IDENT, &FOLLOW_IDENT_in_builtInFunctions1475); 

            	        MATCHT(RIGHT_BRACE, &FOLLOW_RIGHT_BRACE_in_builtInFunctions1477); 

            	        MATCHT(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_builtInFunctions1479); 

            	        {
            	             newFunction->mFunctionType = ELEMENT_FUNCTION_UNDEF; 
            	        }

            	    }
            	    break;
            	case 3:
            	    // AppArmor.g:960:4: 'warn' LEFT_PAREN funcData= QUOTED_STRING RIGHT_PAREN
            	    {
            	        MATCHT(49, &FOLLOW_49_in_builtInFunctions1488); 

            	        MATCHT(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_builtInFunctions1490); 

            	        funcData = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(QUOTED_STRING, &FOLLOW_QUOTED_STRING_in_builtInFunctions1495); 

            	        MATCHT(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_builtInFunctions1497); 

            	        {
            	             newFunction->mFunctionType = ELEMENT_FUNCTION_WARN; 
            	        }

            	    }
            	    break;

                }
            }
            {
                  newFunction->pFunctionInput = strdup((char *) funcData->getText(funcData)->chars); 
            }

            // AppArmor.g:964:2: ( endOfLineComment[newComment] )?
            {
                int alt49=2;
                {
                    int LA49_0 = LA(1);
                    if ( (LA49_0 == EOL_COMMENT) ) 
                    {
                        alt49=1;
                    }
                }
                switch (alt49) 
                {
            	case 1:
            	    // AppArmor.g:964:4: endOfLineComment[newComment]
            	    {
            	        FOLLOWPUSH(FOLLOW_endOfLineComment_in_builtInFunctions1512);
            	        endOfLineComment(ctx, newComment);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebuiltInFunctionsEx;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulebuiltInFunctionsEx; /* Prevent compiler warnings */
    rulebuiltInFunctionsEx: ;



    	if (HASEXCEPTION())
    	{
    		if (mpTree != NULL)
    		{
    			ParseError *error = new_parse_error();
    			if (mpTree->pError != NULL)
    				free_parse_error(mpTree->pError);
    			mpTree->mError = 1;
    			mpTree->pError = error;
    			error->mLine = EXCEPTION->line;
    			error->mPos = EXCEPTION->charPositionInLine;
    			
    			if (EXCEPTION->name != NULL)
    			error->pName = strdup(EXCEPTION->name);
    			
    			if (EXCEPTION->message != NULL)
    			error->pMessage = strdup((char *) EXCEPTION->message);
    		}
    	}

    return tree;
}
/* $ANTLR end builtInFunctions */

/** 
 * $ANTLR start ifExpr
 * AppArmor.g:967:1: ifExpr returns [ConditionalExpr *expr, pANTLR3_STRING string] : (n= 'not' )? mainExpr= variableOrFunction (andExpr= andNotExpr )* ;
 */
static AppArmorParser_ifExpr_return
ifExpr(pAppArmorParser ctx)
{   
    AppArmorParser_ifExpr_return retval;

    pANTLR3_COMMON_TOKEN    n;
    AppArmorParser_variableOrFunction_return mainExpr;
    #undef	RETURN_TYPE_mainExpr
    #define	RETURN_TYPE_mainExpr AppArmorParser_variableOrFunction_return

    AppArmorParser_andNotExpr_return andExpr;
    #undef	RETURN_TYPE_andExpr
    #define	RETURN_TYPE_andExpr AppArmorParser_andNotExpr_return

    /* Initialize rule variables
     */



    		ConditionalExpr *nextLink = NULL;
    		retval.expr= NULL;
    		retval.string= NULL;
    		int negated = 0;
    		retval.string= factory->newRaw(factory);    

    	
    n       = NULL;


    retval.start = LT(1);

    {
        // AppArmor.g:976:2: ( (n= 'not' )? mainExpr= variableOrFunction (andExpr= andNotExpr )* )
        // AppArmor.g:976:4: (n= 'not' )? mainExpr= variableOrFunction (andExpr= andNotExpr )*
        {

            // AppArmor.g:976:4: (n= 'not' )?
            {
                int alt50=2;
                {
                    int LA50_0 = LA(1);
                    if ( (LA50_0 == 50) ) 
                    {
                        alt50=1;
                    }
                }
                switch (alt50) 
                {
            	case 1:
            	    // AppArmor.g:976:6: n= 'not'
            	    {
            	        n = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(50, &FOLLOW_50_in_ifExpr1541); 

            	        {

            	            		negated = 1;
            	            	
            	        }

            	    }
            	    break;

                }
            }
            FOLLOWPUSH(FOLLOW_variableOrFunction_in_ifExpr1554);
            mainExpr=variableOrFunction(ctx);
            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleifExprEx;
            }

            {

                		retval.string->append(retval.string, " ");
                		retval.string->appendS(retval.string, mainExpr.string);
                		mainExpr.expr->mNegated = negated;
                		retval.expr= mainExpr.expr;
                	
            }

            // AppArmor.g:988:2: (andExpr= andNotExpr )*

            for (;;)
            {
                int alt51=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA51_0 = LA(1);
                    if ( (((LA51_0 >= 53) && (LA51_0 <= 54))) ) 
                    {
                        alt51=1;
                    }

                }
                switch (alt51) 
                {
            	case 1:
            	    // AppArmor.g:988:4: andExpr= andNotExpr
            	    {
            	        FOLLOWPUSH(FOLLOW_andNotExpr_in_ifExpr1564);
            	        andExpr=andNotExpr(ctx);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleifExprEx;
            	        }

            	        {


            	            		retval.string->append(retval.string, " ");
            	            		retval.string->appendS(retval.string, andExpr.string);		
            	            		if (nextLink == NULL)
            	            		{
            	            			andExpr.expr->pBack = retval.expr;
            	            			retval.expr->pNext = andExpr.expr;
            	            			nextLink = andExpr.expr;
            	            		}
            	            		else
            	            		{
            	            			nextLink->pNext = andExpr.expr;
            	            			andExpr.expr->pBack = nextLink;
            	            			nextLink = andExpr.expr;
            	            		}
            	            	
            	        }

            	    }
            	    break;

            	default:
            	    goto loop51;	/* break out of the loop */
            	    break;
                }
            }
            loop51: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleifExprEx; /* Prevent compiler warnings */
    ruleifExprEx: ;
    retval.stop = LT(-1);



    	if (HASEXCEPTION())
    	{
    		if (mpTree != NULL)
    		{
    			ParseError *error = new_parse_error();
    			if (mpTree->pError != NULL)
    				free_parse_error(mpTree->pError);
    			mpTree->mError = 1;
    			mpTree->pError = error;
    			error->mLine = EXCEPTION->line;
    			error->mPos = EXCEPTION->charPositionInLine;
    			
    			if (EXCEPTION->name != NULL)
    			error->pName = strdup(EXCEPTION->name);
    			
    			if (EXCEPTION->message != NULL)
    			error->pMessage = strdup((char *) EXCEPTION->message);
    		}
    	}

    return retval;
}
/* $ANTLR end ifExpr */

/** 
 * $ANTLR start variableOrFunction
 * AppArmor.g:1009:1: variableOrFunction returns [ConditionalExpr *expr, pANTLR3_STRING string] : ( ( BOOL_VAR_START in= IDENT RIGHT_BRACE | 'exists' LEFT_PAREN (in= QUOTED_STRING | in= UNQUOTED_PATH ) RIGHT_PAREN ) | 'defined' LEFT_PAREN ( LIST_VAR_START definedVar= IDENT | BOOL_VAR_START definedVar= IDENT ) RIGHT_BRACE RIGHT_PAREN );
 */
static AppArmorParser_variableOrFunction_return
variableOrFunction(pAppArmorParser ctx)
{   
    AppArmorParser_variableOrFunction_return retval;

    pANTLR3_COMMON_TOKEN    in;
    pANTLR3_COMMON_TOKEN    definedVar;

    /* Initialize rule variables
     */



    		retval.string= factory->newRaw(factory);
    		retval.expr= new_conditional_expr_node();
    	
    in       = NULL;
    definedVar       = NULL;
    retval.start = LT(1);

    {
        {
            //  AppArmor.g:1014:2: ( ( BOOL_VAR_START in= IDENT RIGHT_BRACE | 'exists' LEFT_PAREN (in= QUOTED_STRING | in= UNQUOTED_PATH ) RIGHT_PAREN ) | 'defined' LEFT_PAREN ( LIST_VAR_START definedVar= IDENT | BOOL_VAR_START definedVar= IDENT ) RIGHT_BRACE RIGHT_PAREN )
            
            ANTLR3_UINT32 alt55;

            alt55=2;


            {
                int LA55_0 = LA(1);
                if ( (LA55_0 == BOOL_VAR_START || LA55_0 == 51) ) 
                {
                    alt55=1;
                }
                else if ( (LA55_0 == 52) ) 
                {
                    alt55=2;
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = "1009:1: variableOrFunction returns [ConditionalExpr *expr, pANTLR3_STRING string] : ( ( BOOL_VAR_START in= IDENT RIGHT_BRACE | 'exists' LEFT_PAREN (in= QUOTED_STRING | in= UNQUOTED_PATH ) RIGHT_PAREN ) | 'defined' LEFT_PAREN ( LIST_VAR_START definedVar= IDENT | BOOL_VAR_START definedVar= IDENT ) RIGHT_BRACE RIGHT_PAREN );";
                    EXCEPTION->decisionNum  = 55;
                    EXCEPTION->state        = 0;

                
                    goto rulevariableOrFunctionEx;
                }
            }
            switch (alt55) 
            {
        	case 1:
        	    // AppArmor.g:1015:2: ( BOOL_VAR_START in= IDENT RIGHT_BRACE | 'exists' LEFT_PAREN (in= QUOTED_STRING | in= UNQUOTED_PATH ) RIGHT_PAREN )
        	    {

        	        // AppArmor.g:1015:2: ( BOOL_VAR_START in= IDENT RIGHT_BRACE | 'exists' LEFT_PAREN (in= QUOTED_STRING | in= UNQUOTED_PATH ) RIGHT_PAREN )
        	        {
        	            int alt53=2;

        	            {
        	                int LA53_0 = LA(1);
        	                if ( (LA53_0 == BOOL_VAR_START) ) 
        	                {
        	                    alt53=1;
        	                }
        	                else if ( (LA53_0 == 51) ) 
        	                {
        	                    alt53=2;
        	                }
        	                else 
        	                {
        	                
        	                    CONSTRUCTEX();
        	                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                    EXCEPTION->message      = "1015:2: ( BOOL_VAR_START in= IDENT RIGHT_BRACE | 'exists' LEFT_PAREN (in= QUOTED_STRING | in= UNQUOTED_PATH ) RIGHT_PAREN )";
        	                    EXCEPTION->decisionNum  = 53;
        	                    EXCEPTION->state        = 0;

        	                
        	                    goto rulevariableOrFunctionEx;
        	                }
        	            }
        	            switch (alt53) 
        	            {
        	        	case 1:
        	        	    // AppArmor.g:1016:2: BOOL_VAR_START in= IDENT RIGHT_BRACE
        	        	    {
        	        	        MATCHT(BOOL_VAR_START, &FOLLOW_BOOL_VAR_START_in_variableOrFunction1596); 

        	        	        in = (pANTLR3_COMMON_TOKEN)LT(1);
        	        	        MATCHT(IDENT, &FOLLOW_IDENT_in_variableOrFunction1600); 

        	        	        MATCHT(RIGHT_BRACE, &FOLLOW_RIGHT_BRACE_in_variableOrFunction1602); 

        	        	        {
        	        	             
        	        	            		retval.string->append(retval.string, "${");
        	        	            		retval.string->appendS(retval.string, in->getText(in));
        	        	            		retval.string->append(retval.string, "} ");
        	        	            		retval.expr->mCondType = ELEMENT_CONDITIONAL_EXPRESSION_BOOLEAN;
        	        	            	
        	        	        }

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // AppArmor.g:1023:4: 'exists' LEFT_PAREN (in= QUOTED_STRING | in= UNQUOTED_PATH ) RIGHT_PAREN
        	        	    {
        	        	        MATCHT(51, &FOLLOW_51_in_variableOrFunction1610); 

        	        	        MATCHT(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_variableOrFunction1612); 


        	        	        // AppArmor.g:1023:24: (in= QUOTED_STRING | in= UNQUOTED_PATH )
        	        	        {
        	        	            int alt52=2;

        	        	            {
        	        	                int LA52_0 = LA(1);
        	        	                if ( (LA52_0 == QUOTED_STRING) ) 
        	        	                {
        	        	                    alt52=1;
        	        	                }
        	        	                else if ( (LA52_0 == UNQUOTED_PATH) ) 
        	        	                {
        	        	                    alt52=2;
        	        	                }
        	        	                else 
        	        	                {
        	        	                
        	        	                    CONSTRUCTEX();
        	        	                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                    EXCEPTION->message      = "1023:24: (in= QUOTED_STRING | in= UNQUOTED_PATH )";
        	        	                    EXCEPTION->decisionNum  = 52;
        	        	                    EXCEPTION->state        = 0;

        	        	                
        	        	                    goto rulevariableOrFunctionEx;
        	        	                }
        	        	            }
        	        	            switch (alt52) 
        	        	            {
        	        	        	case 1:
        	        	        	    // AppArmor.g:1023:25: in= QUOTED_STRING
        	        	        	    {
        	        	        	        in = (pANTLR3_COMMON_TOKEN)LT(1);
        	        	        	        MATCHT(QUOTED_STRING, &FOLLOW_QUOTED_STRING_in_variableOrFunction1617); 


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // AppArmor.g:1023:42: in= UNQUOTED_PATH
        	        	        	    {
        	        	        	        in = (pANTLR3_COMMON_TOKEN)LT(1);
        	        	        	        MATCHT(UNQUOTED_PATH, &FOLLOW_UNQUOTED_PATH_in_variableOrFunction1621); 


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }
        	        	        MATCHT(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_variableOrFunction1624); 

        	        	        {

        	        	            		retval.string->append(retval.string, "exists(");
        	        	            		retval.string->appendS(retval.string, in->getText(in));
        	        	            		retval.string->append(retval.string, ") ");
        	        	            		retval.expr->mCondType=ELEMENT_CONDITIONAL_EXPRESSION_EXISTS;
        	        	            	
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }
        	        {

        	            		retval.expr->pExprVariable = strdup((char *) in->getText(in)->chars); 
        	            	
        	        }

        	    }
        	    break;
        	case 2:
        	    // AppArmor.g:1034:4: 'defined' LEFT_PAREN ( LIST_VAR_START definedVar= IDENT | BOOL_VAR_START definedVar= IDENT ) RIGHT_BRACE RIGHT_PAREN
        	    {
        	        MATCHT(52, &FOLLOW_52_in_variableOrFunction1638); 

        	        MATCHT(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_variableOrFunction1640); 

        	        {

        	            		retval.string->append(retval.string, "defined(");
        	            	
        	        }

        	        // AppArmor.g:1038:3: ( LIST_VAR_START definedVar= IDENT | BOOL_VAR_START definedVar= IDENT )
        	        {
        	            int alt54=2;

        	            {
        	                int LA54_0 = LA(1);
        	                if ( (LA54_0 == LIST_VAR_START) ) 
        	                {
        	                    alt54=1;
        	                }
        	                else if ( (LA54_0 == BOOL_VAR_START) ) 
        	                {
        	                    alt54=2;
        	                }
        	                else 
        	                {
        	                
        	                    CONSTRUCTEX();
        	                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                    EXCEPTION->message      = "1038:3: ( LIST_VAR_START definedVar= IDENT | BOOL_VAR_START definedVar= IDENT )";
        	                    EXCEPTION->decisionNum  = 54;
        	                    EXCEPTION->state        = 0;

        	                
        	                    goto rulevariableOrFunctionEx;
        	                }
        	            }
        	            switch (alt54) 
        	            {
        	        	case 1:
        	        	    // AppArmor.g:1038:5: LIST_VAR_START definedVar= IDENT
        	        	    {
        	        	        MATCHT(LIST_VAR_START, &FOLLOW_LIST_VAR_START_in_variableOrFunction1649); 

        	        	        definedVar = (pANTLR3_COMMON_TOKEN)LT(1);
        	        	        MATCHT(IDENT, &FOLLOW_IDENT_in_variableOrFunction1653); 

        	        	        {

        	        	            			retval.string->append(retval.string, "@{");
        	        	            			retval.string->appendS(retval.string, definedVar->getText(definedVar));
        	        	            			retval.string->append(retval.string, "}) ");
        	        	            			retval.expr->mCondType = ELEMENT_CONDITIONAL_EXPRESSION_DEFINED_LIST;
        	        	            		
        	        	        }

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // AppArmor.g:1045:5: BOOL_VAR_START definedVar= IDENT
        	        	    {
        	        	        MATCHT(BOOL_VAR_START, &FOLLOW_BOOL_VAR_START_in_variableOrFunction1663); 

        	        	        definedVar = (pANTLR3_COMMON_TOKEN)LT(1);
        	        	        MATCHT(IDENT, &FOLLOW_IDENT_in_variableOrFunction1667); 

        	        	        {

        	        	            			retval.string->append(retval.string, "${");
        	        	            			retval.string->append(retval.string, "}) ");
        	        	            			retval.expr->mCondType = ELEMENT_CONDITIONAL_EXPRESSION_DEFINED_BOOL;
        	        	            		
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }
        	        MATCHT(RIGHT_BRACE, &FOLLOW_RIGHT_BRACE_in_variableOrFunction1679); 

        	        MATCHT(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_variableOrFunction1681); 

        	        {
        	             retval.expr->pExprVariable = strdup((char *) definedVar->getText(definedVar)->chars); 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulevariableOrFunctionEx; /* Prevent compiler warnings */
    rulevariableOrFunctionEx: ;
    retval.stop = LT(-1);



    	if (HASEXCEPTION())
    	{
    		if (mpTree != NULL)
    		{
    			ParseError *error = new_parse_error();
    			if (mpTree->pError != NULL)
    				free_parse_error(mpTree->pError);
    			mpTree->mError = 1;
    			mpTree->pError = error;
    			error->mLine = EXCEPTION->line;
    			error->mPos = EXCEPTION->charPositionInLine;
    			
    			if (EXCEPTION->name != NULL)
    			error->pName = strdup(EXCEPTION->name);
    			
    			if (EXCEPTION->message != NULL)
    			error->pMessage = strdup((char *) EXCEPTION->message);
    		}
    	}

    return retval;
}
/* $ANTLR end variableOrFunction */

/** 
 * $ANTLR start andNotExpr
 * AppArmor.g:1056:1: andNotExpr returns [ConditionalExpr *expr, pANTLR3_STRING string] : (a= 'and' ( 'not' )? inExpr= variableOrFunction | a= 'or' ( 'not' )? inExpr= variableOrFunction ) ;
 */
static AppArmorParser_andNotExpr_return
andNotExpr(pAppArmorParser ctx)
{   
    AppArmorParser_andNotExpr_return retval;

    pANTLR3_COMMON_TOKEN    a;
    AppArmorParser_variableOrFunction_return inExpr;
    #undef	RETURN_TYPE_inExpr
    #define	RETURN_TYPE_inExpr AppArmorParser_variableOrFunction_return

    /* Initialize rule variables
     */



    		retval.string= factory->newRaw(factory);
    		retval.expr= NULL;
    		int negated = 0;
    	
    a       = NULL;
    retval.start = LT(1);

    {
        // AppArmor.g:1062:2: ( (a= 'and' ( 'not' )? inExpr= variableOrFunction | a= 'or' ( 'not' )? inExpr= variableOrFunction ) )
        // AppArmor.g:1063:2: (a= 'and' ( 'not' )? inExpr= variableOrFunction | a= 'or' ( 'not' )? inExpr= variableOrFunction )
        {

            // AppArmor.g:1063:2: (a= 'and' ( 'not' )? inExpr= variableOrFunction | a= 'or' ( 'not' )? inExpr= variableOrFunction )
            {
                int alt58=2;

                {
                    int LA58_0 = LA(1);
                    if ( (LA58_0 == 53) ) 
                    {
                        alt58=1;
                    }
                    else if ( (LA58_0 == 54) ) 
                    {
                        alt58=2;
                    }
                    else 
                    {
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = "1063:2: (a= 'and' ( 'not' )? inExpr= variableOrFunction | a= 'or' ( 'not' )? inExpr= variableOrFunction )";
                        EXCEPTION->decisionNum  = 58;
                        EXCEPTION->state        = 0;

                    
                        goto ruleandNotExprEx;
                    }
                }
                switch (alt58) 
                {
            	case 1:
            	    // AppArmor.g:1063:4: a= 'and' ( 'not' )? inExpr= variableOrFunction
            	    {
            	        a = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(53, &FOLLOW_53_in_andNotExpr1711); 


            	        // AppArmor.g:1063:12: ( 'not' )?
            	        {
            	            int alt56=2;
            	            {
            	                int LA56_0 = LA(1);
            	                if ( (LA56_0 == 50) ) 
            	                {
            	                    alt56=1;
            	                }
            	            }
            	            switch (alt56) 
            	            {
            	        	case 1:
            	        	    // AppArmor.g:1063:13: 'not'
            	        	    {
            	        	        MATCHT(50, &FOLLOW_50_in_andNotExpr1714); 

            	        	        {
            	        	             negated = 1; 
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }
            	        FOLLOWPUSH(FOLLOW_variableOrFunction_in_andNotExpr1723);
            	        inExpr=variableOrFunction(ctx);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleandNotExprEx;
            	        }

            	        {

            	            		inExpr.expr->mLinkType=ELEMENT_CONDITIONAL_EXPRESSION_LINK_AND;
            	            		inExpr.expr->mNegated = negated;
            	            	
            	        }

            	    }
            	    break;
            	case 2:
            	    // AppArmor.g:1068:4: a= 'or' ( 'not' )? inExpr= variableOrFunction
            	    {
            	        a = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(54, &FOLLOW_54_in_andNotExpr1733); 


            	        // AppArmor.g:1068:11: ( 'not' )?
            	        {
            	            int alt57=2;
            	            {
            	                int LA57_0 = LA(1);
            	                if ( (LA57_0 == 50) ) 
            	                {
            	                    alt57=1;
            	                }
            	            }
            	            switch (alt57) 
            	            {
            	        	case 1:
            	        	    // AppArmor.g:1068:12: 'not'
            	        	    {
            	        	        MATCHT(50, &FOLLOW_50_in_andNotExpr1736); 

            	        	        {
            	        	             negated = 1; 
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }
            	        FOLLOWPUSH(FOLLOW_variableOrFunction_in_andNotExpr1745);
            	        inExpr=variableOrFunction(ctx);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleandNotExprEx;
            	        }

            	        {

            	            		inExpr.expr->mLinkType =ELEMENT_CONDITIONAL_EXPRESSION_LINK_OR;
            	            		inExpr.expr->mNegated = negated;
            	            	
            	        }

            	    }
            	    break;

                }
            }
            {
                 	
                		retval.string->appendS(retval.string, a->getText(a));
                		if (negated == 1)
                			retval.string->append(retval.string, " not");

                		retval.string->append(retval.string, " ");
                		retval.string->appendS(retval.string, inExpr.string);
                		retval.expr= inExpr.expr;
                	
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleandNotExprEx; /* Prevent compiler warnings */
    ruleandNotExprEx: ;
    retval.stop = LT(-1);



    	if (HASEXCEPTION())
    	{
    		if (mpTree != NULL)
    		{
    			ParseError *error = new_parse_error();
    			if (mpTree->pError != NULL)
    				free_parse_error(mpTree->pError);
    			mpTree->mError = 1;
    			mpTree->pError = error;
    			error->mLine = EXCEPTION->line;
    			error->mPos = EXCEPTION->charPositionInLine;
    			
    			if (EXCEPTION->name != NULL)
    			error->pName = strdup(EXCEPTION->name);
    			
    			if (EXCEPTION->message != NULL)
    			error->pMessage = strdup((char *) EXCEPTION->message);
    		}
    	}

    return retval;
}
/* $ANTLR end andNotExpr */

/** 
 * $ANTLR start networkRule
 * AppArmor.g:1087:1: networkRule returns [ParseNode *tree] : 'network' (domain= domainRule )? (type= typeRule )? (protocol= protocolRule )? (action= networkActionRule )? (network= networkHostRule (network2= networkHostRule )? )? (iface= ifaceRule )? (limit= limitRule )? ( 'conntrack' )? ',' ( endOfLineComment[newComment] )? ;
 */
static ParseNode *
networkRule(pAppArmorParser ctx)
{   
    ParseNode * tree = NULL;

    char * domain;
    #undef	RETURN_TYPE_domain
    #define	RETURN_TYPE_domain char *

    char * type;
    #undef	RETURN_TYPE_type
    #define	RETURN_TYPE_type char *

    char * protocol;
    #undef	RETURN_TYPE_protocol
    #define	RETURN_TYPE_protocol char *

    AppArmorParser_networkActionRule_return action;
    #undef	RETURN_TYPE_action
    #define	RETURN_TYPE_action AppArmorParser_networkActionRule_return

    AppArmorParser_networkHostRule_return network;
    #undef	RETURN_TYPE_network
    #define	RETURN_TYPE_network AppArmorParser_networkHostRule_return

    AppArmorParser_networkHostRule_return network2;
    #undef	RETURN_TYPE_network2
    #define	RETURN_TYPE_network2 AppArmorParser_networkHostRule_return

    char * iface;
    #undef	RETURN_TYPE_iface
    #define	RETURN_TYPE_iface char *

    char * limit;
    #undef	RETURN_TYPE_limit
    #define	RETURN_TYPE_limit char *

    /* Initialize rule variables
     */



    		Network *networkNode = new_network_node();
    		THROW_IF_NULL(networkNode,rulenetworkRuleEx);
    		tree= new_parse_node(ELEMENT_NETWORK, mpTree);
    		THROW_IF_NULL(tree,rulenetworkRuleEx);
    		Comment *newComment = new_comment_node(NULL);
    		tree->pData = networkNode;
    		tree->pEOLComment = newComment;
    		AttachCommentBlock(tree);
    	
    domain = NULL;
    type = NULL;
    protocol = NULL;



    iface = NULL;
    limit = NULL;

    {
        // AppArmor.g:1098:2: ( 'network' (domain= domainRule )? (type= typeRule )? (protocol= protocolRule )? (action= networkActionRule )? (network= networkHostRule (network2= networkHostRule )? )? (iface= ifaceRule )? (limit= limitRule )? ( 'conntrack' )? ',' ( endOfLineComment[newComment] )? )
        // AppArmor.g:1098:4: 'network' (domain= domainRule )? (type= typeRule )? (protocol= protocolRule )? (action= networkActionRule )? (network= networkHostRule (network2= networkHostRule )? )? (iface= ifaceRule )? (limit= limitRule )? ( 'conntrack' )? ',' ( endOfLineComment[newComment] )?
        {
            MATCHT(55, &FOLLOW_55_in_networkRule1777); 


            // AppArmor.g:1103:2: (domain= domainRule )?
            {
                int alt59=2;
                {
                    int LA59_0 = LA(1);
                    if ( (((LA59_0 >= 57) && (LA59_0 <= 76))) ) 
                    {
                        alt59=1;
                    }
                }
                switch (alt59) 
                {
            	case 1:
            	    // AppArmor.g:1103:4: domain= domainRule
            	    {
            	        FOLLOWPUSH(FOLLOW_domainRule_in_networkRule1787);
            	        domain=domainRule(ctx);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenetworkRuleEx;
            	        }

            	        {

            	            		if (domain != NULL)
            	            			networkNode->pDomain = strdup(domain);
            	            	
            	        }

            	    }
            	    break;

                }
            }

            // AppArmor.g:1109:2: (type= typeRule )?
            {
                int alt60=2;
                {
                    int LA60_0 = LA(1);
                    if ( (((LA60_0 >= 77) && (LA60_0 <= 81))) ) 
                    {
                        alt60=1;
                    }
                }
                switch (alt60) 
                {
            	case 1:
            	    // AppArmor.g:1109:4: type= typeRule
            	    {
            	        FOLLOWPUSH(FOLLOW_typeRule_in_networkRule1801);
            	        type=typeRule(ctx);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenetworkRuleEx;
            	        }

            	        {

            	            		if (type != NULL)
            	            			networkNode->pType = strdup(type);
            	            	
            	        }

            	    }
            	    break;

                }
            }

            // AppArmor.g:1115:2: (protocol= protocolRule )?
            {
                int alt61=2;
                {
                    int LA61_0 = LA(1);
                    if ( (((LA61_0 >= 82) && (LA61_0 <= 86))) ) 
                    {
                        alt61=1;
                    }
                }
                switch (alt61) 
                {
            	case 1:
            	    // AppArmor.g:1115:4: protocol= protocolRule
            	    {
            	        FOLLOWPUSH(FOLLOW_protocolRule_in_networkRule1815);
            	        protocol=protocolRule(ctx);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenetworkRuleEx;
            	        }

            	        {

            	            		if (protocol != NULL)
            	            			networkNode->pProtocol = strdup(protocol);
            	            	
            	        }

            	    }
            	    break;

                }
            }

            // AppArmor.g:1121:2: (action= networkActionRule )?
            {
                int alt62=2;
                {
                    int LA62_0 = LA(1);
                    if ( (((LA62_0 >= 88) && (LA62_0 <= 92))) ) 
                    {
                        alt62=1;
                    }
                }
                switch (alt62) 
                {
            	case 1:
            	    // AppArmor.g:1121:4: action= networkActionRule
            	    {
            	        FOLLOWPUSH(FOLLOW_networkActionRule_in_networkRule1829);
            	        action=networkActionRule(ctx);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenetworkRuleEx;
            	        }

            	        {

            	            		if (action.tcp != NULL)
            	            			networkNode->pAction1 = strdup(action.tcp);
            	            		if (action.udp1 != NULL)
            	            			networkNode->pAction1 = strdup(action.udp1);
            	            		if (action.udp2 != NULL)
            	            			networkNode->pAction2 = strdup(action.udp2);
            	            	
            	        }

            	    }
            	    break;

                }
            }

            // AppArmor.g:1131:2: (network= networkHostRule (network2= networkHostRule )? )?
            {
                int alt64=2;
                {
                    int LA64_0 = LA(1);
                    if ( (((LA64_0 >= 93) && (LA64_0 <= 95))) ) 
                    {
                        alt64=1;
                    }
                }
                switch (alt64) 
                {
            	case 1:
            	    // AppArmor.g:1131:4: network= networkHostRule (network2= networkHostRule )?
            	    {
            	        FOLLOWPUSH(FOLLOW_networkHostRule_in_networkRule1843);
            	        network=networkHostRule(ctx);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenetworkRuleEx;
            	        }

            	        {

            	            		if (network.direction != NULL)
            	            			networkNode->pDirection1 = strdup(network.direction);
            	            		if (network.iprule != NULL)
            	            			networkNode->pIPExpr1 = strdup(network.iprule);
            	            	
            	        }

            	        // AppArmor.g:1138:3: (network2= networkHostRule )?
            	        {
            	            int alt63=2;
            	            {
            	                int LA63_0 = LA(1);
            	                if ( (((LA63_0 >= 93) && (LA63_0 <= 95))) ) 
            	                {
            	                    alt63=1;
            	                }
            	            }
            	            switch (alt63) 
            	            {
            	        	case 1:
            	        	    // AppArmor.g:1138:5: network2= networkHostRule
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_networkHostRule_in_networkRule1855);
            	        	        network2=networkHostRule(ctx);
            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulenetworkRuleEx;
            	        	        }

            	        	        {

            	        	            	 	if (network2.direction != NULL)
            	        	            			networkNode->pDirection2 = strdup(network2.direction);
            	        	            		if (network2.iprule != NULL)
            	        	            			networkNode->pIPExpr2 = strdup(network2.iprule);
            	        	            	 
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            // AppArmor.g:1147:2: (iface= ifaceRule )?
            {
                int alt65=2;
                {
                    int LA65_0 = LA(1);
                    if ( (LA65_0 == 96) ) 
                    {
                        alt65=1;
                    }
                }
                switch (alt65) 
                {
            	case 1:
            	    // AppArmor.g:1147:4: iface= ifaceRule
            	    {
            	        FOLLOWPUSH(FOLLOW_ifaceRule_in_networkRule1876);
            	        iface=ifaceRule(ctx);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenetworkRuleEx;
            	        }

            	        {

            	            		if (iface != NULL)
            	            			networkNode->pIface = strdup(iface);
            	            	
            	        }

            	    }
            	    break;

                }
            }

            // AppArmor.g:1153:2: (limit= limitRule )?
            {
                int alt66=2;
                {
                    int LA66_0 = LA(1);
                    if ( (LA66_0 == 97) ) 
                    {
                        alt66=1;
                    }
                }
                switch (alt66) 
                {
            	case 1:
            	    // AppArmor.g:1153:4: limit= limitRule
            	    {
            	        FOLLOWPUSH(FOLLOW_limitRule_in_networkRule1891);
            	        limit=limitRule(ctx);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenetworkRuleEx;
            	        }

            	        {

            	            		if (limit != NULL)
            	            			networkNode->pLimit = strdup(limit);
            	            	
            	        }

            	    }
            	    break;

                }
            }

            // AppArmor.g:1159:2: ( 'conntrack' )?
            {
                int alt67=2;
                {
                    int LA67_0 = LA(1);
                    if ( (LA67_0 == 56) ) 
                    {
                        alt67=1;
                    }
                }
                switch (alt67) 
                {
            	case 1:
            	    // AppArmor.g:1159:4: 'conntrack'
            	    {
            	        MATCHT(56, &FOLLOW_56_in_networkRule1903); 

            	        {
            	             networkNode->mConntrack = 1; 
            	        }

            	    }
            	    break;

                }
            }
            MATCHT(42, &FOLLOW_42_in_networkRule1910); 


            // AppArmor.g:1160:2: ( endOfLineComment[newComment] )?
            {
                int alt68=2;
                {
                    int LA68_0 = LA(1);
                    if ( (LA68_0 == EOL_COMMENT) ) 
                    {
                        alt68=1;
                    }
                }
                switch (alt68) 
                {
            	case 1:
            	    // AppArmor.g:1160:4: endOfLineComment[newComment]
            	    {
            	        FOLLOWPUSH(FOLLOW_endOfLineComment_in_networkRule1915);
            	        endOfLineComment(ctx, newComment);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenetworkRuleEx;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulenetworkRuleEx; /* Prevent compiler warnings */
    rulenetworkRuleEx: ;



    	if (HASEXCEPTION())
    	{
    		if (mpTree != NULL)
    		{
    			ParseError *error = new_parse_error();
    			if (mpTree->pError != NULL)
    				free_parse_error(mpTree->pError);
    			mpTree->mError = 1;
    			mpTree->pError = error;
    			error->mLine = EXCEPTION->line;
    			error->mPos = EXCEPTION->charPositionInLine;
    			
    			if (EXCEPTION->name != NULL)
    			error->pName = strdup(EXCEPTION->name);
    			
    			if (EXCEPTION->message != NULL)
    			error->pMessage = strdup((char *) EXCEPTION->message);
    		}
    	}

    return tree;
}
/* $ANTLR end networkRule */

/** 
 * $ANTLR start domainRule
 * AppArmor.g:1166:1: domainRule returns [char *domain] : (d= 'inet' | d= 'ax25' | d= 'netrom' | d= 'bridge' | d= 'atmpvc' | d= 'x25' | d= 'inet6' | d= 'rose' | d= 'netbeui' | d= 'security' | d= 'key' | d= 'packet' | d= 'ash' | d= 'econet' | d= 'atmsvc' | d= 'sna' | d= 'irda' | d= 'pppox' | d= 'wanpipe' | d= 'bluetooth' ) ;
 */
static char *
domainRule(pAppArmorParser ctx)
{   
    char * domain = NULL;

    pANTLR3_COMMON_TOKEN    d;

    /* Initialize rule variables
     */


     domain= NULL; 
    d       = NULL;

    {
        // AppArmor.g:1168:2: ( (d= 'inet' | d= 'ax25' | d= 'netrom' | d= 'bridge' | d= 'atmpvc' | d= 'x25' | d= 'inet6' | d= 'rose' | d= 'netbeui' | d= 'security' | d= 'key' | d= 'packet' | d= 'ash' | d= 'econet' | d= 'atmsvc' | d= 'sna' | d= 'irda' | d= 'pppox' | d= 'wanpipe' | d= 'bluetooth' ) )
        // AppArmor.g:1169:2: (d= 'inet' | d= 'ax25' | d= 'netrom' | d= 'bridge' | d= 'atmpvc' | d= 'x25' | d= 'inet6' | d= 'rose' | d= 'netbeui' | d= 'security' | d= 'key' | d= 'packet' | d= 'ash' | d= 'econet' | d= 'atmsvc' | d= 'sna' | d= 'irda' | d= 'pppox' | d= 'wanpipe' | d= 'bluetooth' )
        {

            // AppArmor.g:1169:2: (d= 'inet' | d= 'ax25' | d= 'netrom' | d= 'bridge' | d= 'atmpvc' | d= 'x25' | d= 'inet6' | d= 'rose' | d= 'netbeui' | d= 'security' | d= 'key' | d= 'packet' | d= 'ash' | d= 'econet' | d= 'atmsvc' | d= 'sna' | d= 'irda' | d= 'pppox' | d= 'wanpipe' | d= 'bluetooth' )
            {
                int alt69=20;
                switch ( LA(1) ) 
                {
                case 57:
                	{
                		alt69=1;
                	}
                    break;
                case 58:
                	{
                		alt69=2;
                	}
                    break;
                case 59:
                	{
                		alt69=3;
                	}
                    break;
                case 60:
                	{
                		alt69=4;
                	}
                    break;
                case 61:
                	{
                		alt69=5;
                	}
                    break;
                case 62:
                	{
                		alt69=6;
                	}
                    break;
                case 63:
                	{
                		alt69=7;
                	}
                    break;
                case 64:
                	{
                		alt69=8;
                	}
                    break;
                case 65:
                	{
                		alt69=9;
                	}
                    break;
                case 66:
                	{
                		alt69=10;
                	}
                    break;
                case 67:
                	{
                		alt69=11;
                	}
                    break;
                case 68:
                	{
                		alt69=12;
                	}
                    break;
                case 69:
                	{
                		alt69=13;
                	}
                    break;
                case 70:
                	{
                		alt69=14;
                	}
                    break;
                case 71:
                	{
                		alt69=15;
                	}
                    break;
                case 72:
                	{
                		alt69=16;
                	}
                    break;
                case 73:
                	{
                		alt69=17;
                	}
                    break;
                case 74:
                	{
                		alt69=18;
                	}
                    break;
                case 75:
                	{
                		alt69=19;
                	}
                    break;
                case 76:
                	{
                		alt69=20;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = "1169:2: (d= 'inet' | d= 'ax25' | d= 'netrom' | d= 'bridge' | d= 'atmpvc' | d= 'x25' | d= 'inet6' | d= 'rose' | d= 'netbeui' | d= 'security' | d= 'key' | d= 'packet' | d= 'ash' | d= 'econet' | d= 'atmsvc' | d= 'sna' | d= 'irda' | d= 'pppox' | d= 'wanpipe' | d= 'bluetooth' )";
                    EXCEPTION->decisionNum  = 69;
                    EXCEPTION->state        = 0;


                    goto ruledomainRuleEx;
                }

                switch (alt69) 
                {
            	case 1:
            	    // AppArmor.g:1169:4: d= 'inet'
            	    {
            	        d = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(57, &FOLLOW_57_in_domainRule1949); 


            	    }
            	    break;
            	case 2:
            	    // AppArmor.g:1170:4: d= 'ax25'
            	    {
            	        d = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(58, &FOLLOW_58_in_domainRule1956); 


            	    }
            	    break;
            	case 3:
            	    // AppArmor.g:1173:4: d= 'netrom'
            	    {
            	        d = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(59, &FOLLOW_59_in_domainRule1967); 


            	    }
            	    break;
            	case 4:
            	    // AppArmor.g:1174:4: d= 'bridge'
            	    {
            	        d = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(60, &FOLLOW_60_in_domainRule1974); 


            	    }
            	    break;
            	case 5:
            	    // AppArmor.g:1175:4: d= 'atmpvc'
            	    {
            	        d = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(61, &FOLLOW_61_in_domainRule1981); 


            	    }
            	    break;
            	case 6:
            	    // AppArmor.g:1176:4: d= 'x25'
            	    {
            	        d = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(62, &FOLLOW_62_in_domainRule1988); 


            	    }
            	    break;
            	case 7:
            	    // AppArmor.g:1177:4: d= 'inet6'
            	    {
            	        d = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(63, &FOLLOW_63_in_domainRule1995); 


            	    }
            	    break;
            	case 8:
            	    // AppArmor.g:1178:4: d= 'rose'
            	    {
            	        d = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(64, &FOLLOW_64_in_domainRule2002); 


            	    }
            	    break;
            	case 9:
            	    // AppArmor.g:1179:4: d= 'netbeui'
            	    {
            	        d = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(65, &FOLLOW_65_in_domainRule2009); 


            	    }
            	    break;
            	case 10:
            	    // AppArmor.g:1180:4: d= 'security'
            	    {
            	        d = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(66, &FOLLOW_66_in_domainRule2016); 


            	    }
            	    break;
            	case 11:
            	    // AppArmor.g:1181:4: d= 'key'
            	    {
            	        d = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(67, &FOLLOW_67_in_domainRule2023); 


            	    }
            	    break;
            	case 12:
            	    // AppArmor.g:1182:4: d= 'packet'
            	    {
            	        d = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(68, &FOLLOW_68_in_domainRule2030); 


            	    }
            	    break;
            	case 13:
            	    // AppArmor.g:1183:11: d= 'ash'
            	    {
            	        d = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(69, &FOLLOW_69_in_domainRule2044); 


            	    }
            	    break;
            	case 14:
            	    // AppArmor.g:1184:4: d= 'econet'
            	    {
            	        d = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(70, &FOLLOW_70_in_domainRule2051); 


            	    }
            	    break;
            	case 15:
            	    // AppArmor.g:1185:4: d= 'atmsvc'
            	    {
            	        d = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(71, &FOLLOW_71_in_domainRule2058); 


            	    }
            	    break;
            	case 16:
            	    // AppArmor.g:1186:4: d= 'sna'
            	    {
            	        d = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(72, &FOLLOW_72_in_domainRule2065); 


            	    }
            	    break;
            	case 17:
            	    // AppArmor.g:1187:4: d= 'irda'
            	    {
            	        d = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(73, &FOLLOW_73_in_domainRule2072); 


            	    }
            	    break;
            	case 18:
            	    // AppArmor.g:1188:4: d= 'pppox'
            	    {
            	        d = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(74, &FOLLOW_74_in_domainRule2079); 


            	    }
            	    break;
            	case 19:
            	    // AppArmor.g:1189:4: d= 'wanpipe'
            	    {
            	        d = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(75, &FOLLOW_75_in_domainRule2086); 


            	    }
            	    break;
            	case 20:
            	    // AppArmor.g:1190:11: d= 'bluetooth'
            	    {
            	        d = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(76, &FOLLOW_76_in_domainRule2100); 


            	    }
            	    break;

                }
            }
            {
                 domain= (char *) d->getText(d)->chars; 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruledomainRuleEx; /* Prevent compiler warnings */
    ruledomainRuleEx: ;



    	if (HASEXCEPTION())
    	{
    		if (mpTree != NULL)
    		{
    			ParseError *error = new_parse_error();
    			if (mpTree->pError != NULL)
    				free_parse_error(mpTree->pError);
    			mpTree->mError = 1;
    			mpTree->pError = error;
    			error->mLine = EXCEPTION->line;
    			error->mPos = EXCEPTION->charPositionInLine;
    			
    			if (EXCEPTION->name != NULL)
    			error->pName = strdup(EXCEPTION->name);
    			
    			if (EXCEPTION->message != NULL)
    			error->pMessage = strdup((char *) EXCEPTION->message);
    		}
    	}

    return domain;
}
/* $ANTLR end domainRule */

/** 
 * $ANTLR start typeRule
 * AppArmor.g:1194:1: typeRule returns [char *type] : (t= 'stream' | t= 'dgram' | t= 'seqpacket' | t= 'rdm' | t= 'raw' ) ;
 */
static char *
typeRule(pAppArmorParser ctx)
{   
    char * type = NULL;

    pANTLR3_COMMON_TOKEN    t;

    /* Initialize rule variables
     */


     type= NULL; 
    t       = NULL;

    {
        // AppArmor.g:1196:2: ( (t= 'stream' | t= 'dgram' | t= 'seqpacket' | t= 'rdm' | t= 'raw' ) )
        // AppArmor.g:1197:2: (t= 'stream' | t= 'dgram' | t= 'seqpacket' | t= 'rdm' | t= 'raw' )
        {

            // AppArmor.g:1197:2: (t= 'stream' | t= 'dgram' | t= 'seqpacket' | t= 'rdm' | t= 'raw' )
            {
                int alt70=5;
                switch ( LA(1) ) 
                {
                case 77:
                	{
                		alt70=1;
                	}
                    break;
                case 78:
                	{
                		alt70=2;
                	}
                    break;
                case 79:
                	{
                		alt70=3;
                	}
                    break;
                case 80:
                	{
                		alt70=4;
                	}
                    break;
                case 81:
                	{
                		alt70=5;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = "1197:2: (t= 'stream' | t= 'dgram' | t= 'seqpacket' | t= 'rdm' | t= 'raw' )";
                    EXCEPTION->decisionNum  = 70;
                    EXCEPTION->state        = 0;


                    goto ruletypeRuleEx;
                }

                switch (alt70) 
                {
            	case 1:
            	    // AppArmor.g:1197:4: t= 'stream'
            	    {
            	        t = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(77, &FOLLOW_77_in_typeRule2130); 


            	    }
            	    break;
            	case 2:
            	    // AppArmor.g:1198:4: t= 'dgram'
            	    {
            	        t = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(78, &FOLLOW_78_in_typeRule2137); 


            	    }
            	    break;
            	case 3:
            	    // AppArmor.g:1199:4: t= 'seqpacket'
            	    {
            	        t = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(79, &FOLLOW_79_in_typeRule2144); 


            	    }
            	    break;
            	case 4:
            	    // AppArmor.g:1200:4: t= 'rdm'
            	    {
            	        t = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(80, &FOLLOW_80_in_typeRule2151); 


            	    }
            	    break;
            	case 5:
            	    // AppArmor.g:1201:4: t= 'raw'
            	    {
            	        t = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(81, &FOLLOW_81_in_typeRule2158); 


            	    }
            	    break;

                }
            }
            {
                 type= (char *) t->getText(t)->chars; 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletypeRuleEx; /* Prevent compiler warnings */
    ruletypeRuleEx: ;



    	if (HASEXCEPTION())
    	{
    		if (mpTree != NULL)
    		{
    			ParseError *error = new_parse_error();
    			if (mpTree->pError != NULL)
    				free_parse_error(mpTree->pError);
    			mpTree->mError = 1;
    			mpTree->pError = error;
    			error->mLine = EXCEPTION->line;
    			error->mPos = EXCEPTION->charPositionInLine;
    			
    			if (EXCEPTION->name != NULL)
    			error->pName = strdup(EXCEPTION->name);
    			
    			if (EXCEPTION->message != NULL)
    			error->pMessage = strdup((char *) EXCEPTION->message);
    		}
    	}

    return type;
}
/* $ANTLR end typeRule */

/** 
 * $ANTLR start protocolRule
 * AppArmor.g:1207:1: protocolRule returns [char *protocol] : (p= 'tcp' | p= 'udp' | p= 'ipx' | p= 'appletalk' | p= 'sctp' ) ;
 */
static char *
protocolRule(pAppArmorParser ctx)
{   
    char * protocol = NULL;

    pANTLR3_COMMON_TOKEN    p;

    /* Initialize rule variables
     */


     protocol= NULL; 
    p       = NULL;

    {
        // AppArmor.g:1209:2: ( (p= 'tcp' | p= 'udp' | p= 'ipx' | p= 'appletalk' | p= 'sctp' ) )
        // AppArmor.g:1210:2: (p= 'tcp' | p= 'udp' | p= 'ipx' | p= 'appletalk' | p= 'sctp' )
        {

            // AppArmor.g:1210:2: (p= 'tcp' | p= 'udp' | p= 'ipx' | p= 'appletalk' | p= 'sctp' )
            {
                int alt71=5;
                switch ( LA(1) ) 
                {
                case 82:
                	{
                		alt71=1;
                	}
                    break;
                case 83:
                	{
                		alt71=2;
                	}
                    break;
                case 84:
                	{
                		alt71=3;
                	}
                    break;
                case 85:
                	{
                		alt71=4;
                	}
                    break;
                case 86:
                	{
                		alt71=5;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = "1210:2: (p= 'tcp' | p= 'udp' | p= 'ipx' | p= 'appletalk' | p= 'sctp' )";
                    EXCEPTION->decisionNum  = 71;
                    EXCEPTION->state        = 0;


                    goto ruleprotocolRuleEx;
                }

                switch (alt71) 
                {
            	case 1:
            	    // AppArmor.g:1210:4: p= 'tcp'
            	    {
            	        p = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(82, &FOLLOW_82_in_protocolRule2193); 


            	    }
            	    break;
            	case 2:
            	    // AppArmor.g:1211:4: p= 'udp'
            	    {
            	        p = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(83, &FOLLOW_83_in_protocolRule2200); 


            	    }
            	    break;
            	case 3:
            	    // AppArmor.g:1212:4: p= 'ipx'
            	    {
            	        p = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(84, &FOLLOW_84_in_protocolRule2207); 


            	    }
            	    break;
            	case 4:
            	    // AppArmor.g:1213:4: p= 'appletalk'
            	    {
            	        p = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(85, &FOLLOW_85_in_protocolRule2214); 


            	    }
            	    break;
            	case 5:
            	    // AppArmor.g:1214:4: p= 'sctp'
            	    {
            	        p = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(86, &FOLLOW_86_in_protocolRule2221); 


            	    }
            	    break;

                }
            }
            {
                 protocol= (char *) p->getText(p)->chars; 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleprotocolRuleEx; /* Prevent compiler warnings */
    ruleprotocolRuleEx: ;



    	if (HASEXCEPTION())
    	{
    		if (mpTree != NULL)
    		{
    			ParseError *error = new_parse_error();
    			if (mpTree->pError != NULL)
    				free_parse_error(mpTree->pError);
    			mpTree->mError = 1;
    			mpTree->pError = error;
    			error->mLine = EXCEPTION->line;
    			error->mPos = EXCEPTION->charPositionInLine;
    			
    			if (EXCEPTION->name != NULL)
    			error->pName = strdup(EXCEPTION->name);
    			
    			if (EXCEPTION->message != NULL)
    			error->pMessage = strdup((char *) EXCEPTION->message);
    		}
    	}

    return protocol;
}
/* $ANTLR end protocolRule */

/** 
 * $ANTLR start networkActionRule
 * AppArmor.g:1219:1: networkActionRule returns [char *tcp, char *udp1, char *udp2] : (t= tcpRule | u= udpRule ( '&' u= udpRule )? ) ;
 */
static AppArmorParser_networkActionRule_return
networkActionRule(pAppArmorParser ctx)
{   
    AppArmorParser_networkActionRule_return retval;

    char * t;
    #undef	RETURN_TYPE_t
    #define	RETURN_TYPE_t char *

    char * u;
    #undef	RETURN_TYPE_u
    #define	RETURN_TYPE_u char *

    /* Initialize rule variables
     */


     retval.tcp= NULL; retval.udp1= NULL; retval.udp2= NULL; 
    t = NULL;
    u = NULL;
    retval.start = LT(1);

    {
        // AppArmor.g:1221:2: ( (t= tcpRule | u= udpRule ( '&' u= udpRule )? ) )
        // AppArmor.g:1221:4: (t= tcpRule | u= udpRule ( '&' u= udpRule )? )
        {

            // AppArmor.g:1221:4: (t= tcpRule | u= udpRule ( '&' u= udpRule )? )
            {
                int alt73=2;

                {
                    int LA73_0 = LA(1);
                    if ( (((LA73_0 >= 88) && (LA73_0 <= 90))) ) 
                    {
                        alt73=1;
                    }
                    else if ( (((LA73_0 >= 91) && (LA73_0 <= 92))) ) 
                    {
                        alt73=2;
                    }
                    else 
                    {
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = "1221:4: (t= tcpRule | u= udpRule ( '&' u= udpRule )? )";
                        EXCEPTION->decisionNum  = 73;
                        EXCEPTION->state        = 0;

                    
                        goto rulenetworkActionRuleEx;
                    }
                }
                switch (alt73) 
                {
            	case 1:
            	    // AppArmor.g:1221:6: t= tcpRule
            	    {
            	        FOLLOWPUSH(FOLLOW_tcpRule_in_networkActionRule2252);
            	        t=tcpRule(ctx);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenetworkActionRuleEx;
            	        }

            	        {
            	             retval.tcp= t; 
            	        }

            	    }
            	    break;
            	case 2:
            	    // AppArmor.g:1222:6: u= udpRule ( '&' u= udpRule )?
            	    {
            	        FOLLOWPUSH(FOLLOW_udpRule_in_networkActionRule2263);
            	        u=udpRule(ctx);
            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenetworkActionRuleEx;
            	        }

            	        {
            	             retval.udp1= u; 
            	        }

            	        // AppArmor.g:1223:6: ( '&' u= udpRule )?
            	        {
            	            int alt72=2;
            	            {
            	                int LA72_0 = LA(1);
            	                if ( (LA72_0 == 87) ) 
            	                {
            	                    alt72=1;
            	                }
            	            }
            	            switch (alt72) 
            	            {
            	        	case 1:
            	        	    // AppArmor.g:1223:7: '&' u= udpRule
            	        	    {
            	        	        MATCHT(87, &FOLLOW_87_in_networkActionRule2274); 

            	        	        FOLLOWPUSH(FOLLOW_udpRule_in_networkActionRule2278);
            	        	        u=udpRule(ctx);
            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulenetworkActionRuleEx;
            	        	        }

            	        	        {
            	        	             retval.udp2= u; 
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulenetworkActionRuleEx; /* Prevent compiler warnings */
    rulenetworkActionRuleEx: ;
    retval.stop = LT(-1);



    	if (HASEXCEPTION())
    	{
    		if (mpTree != NULL)
    		{
    			ParseError *error = new_parse_error();
    			if (mpTree->pError != NULL)
    				free_parse_error(mpTree->pError);
    			mpTree->mError = 1;
    			mpTree->pError = error;
    			error->mLine = EXCEPTION->line;
    			error->mPos = EXCEPTION->charPositionInLine;
    			
    			if (EXCEPTION->name != NULL)
    			error->pName = strdup(EXCEPTION->name);
    			
    			if (EXCEPTION->message != NULL)
    			error->pMessage = strdup((char *) EXCEPTION->message);
    		}
    	}

    return retval;
}
/* $ANTLR end networkActionRule */

/** 
 * $ANTLR start tcpRule
 * AppArmor.g:1227:1: tcpRule returns [char *tcp] : (t= 'connect' | t= 'accept' | t= 'connected' ) ;
 */
static char *
tcpRule(pAppArmorParser ctx)
{   
    char * tcp = NULL;

    pANTLR3_COMMON_TOKEN    t;

    /* Initialize rule variables
     */


     tcp= NULL; 
    t       = NULL;

    {
        // AppArmor.g:1229:2: ( (t= 'connect' | t= 'accept' | t= 'connected' ) )
        // AppArmor.g:1230:2: (t= 'connect' | t= 'accept' | t= 'connected' )
        {

            // AppArmor.g:1230:2: (t= 'connect' | t= 'accept' | t= 'connected' )
            {
                int alt74=3;
                switch ( LA(1) ) 
                {
                case 88:
                	{
                		alt74=1;
                	}
                    break;
                case 89:
                	{
                		alt74=2;
                	}
                    break;
                case 90:
                	{
                		alt74=3;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = "1230:2: (t= 'connect' | t= 'accept' | t= 'connected' )";
                    EXCEPTION->decisionNum  = 74;
                    EXCEPTION->state        = 0;


                    goto ruletcpRuleEx;
                }

                switch (alt74) 
                {
            	case 1:
            	    // AppArmor.g:1230:4: t= 'connect'
            	    {
            	        t = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(88, &FOLLOW_88_in_tcpRule2316); 


            	    }
            	    break;
            	case 2:
            	    // AppArmor.g:1231:4: t= 'accept'
            	    {
            	        t = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(89, &FOLLOW_89_in_tcpRule2323); 


            	    }
            	    break;
            	case 3:
            	    // AppArmor.g:1232:4: t= 'connected'
            	    {
            	        t = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(90, &FOLLOW_90_in_tcpRule2330); 


            	    }
            	    break;

                }
            }
            {
                 tcp= (char *) t->getText(t)->chars; 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletcpRuleEx; /* Prevent compiler warnings */
    ruletcpRuleEx: ;



    	if (HASEXCEPTION())
    	{
    		if (mpTree != NULL)
    		{
    			ParseError *error = new_parse_error();
    			if (mpTree->pError != NULL)
    				free_parse_error(mpTree->pError);
    			mpTree->mError = 1;
    			mpTree->pError = error;
    			error->mLine = EXCEPTION->line;
    			error->mPos = EXCEPTION->charPositionInLine;
    			
    			if (EXCEPTION->name != NULL)
    			error->pName = strdup(EXCEPTION->name);
    			
    			if (EXCEPTION->message != NULL)
    			error->pMessage = strdup((char *) EXCEPTION->message);
    		}
    	}

    return tcp;
}
/* $ANTLR end tcpRule */

/** 
 * $ANTLR start udpRule
 * AppArmor.g:1236:1: udpRule returns [char *udp] : (u= 'send' | u= 'recv' ) ;
 */
static char *
udpRule(pAppArmorParser ctx)
{   
    char * udp = NULL;

    pANTLR3_COMMON_TOKEN    u;

    /* Initialize rule variables
     */


     udp= NULL; 
    u       = NULL;

    {
        // AppArmor.g:1238:2: ( (u= 'send' | u= 'recv' ) )
        // AppArmor.g:1239:2: (u= 'send' | u= 'recv' )
        {

            // AppArmor.g:1239:2: (u= 'send' | u= 'recv' )
            {
                int alt75=2;

                {
                    int LA75_0 = LA(1);
                    if ( (LA75_0 == 91) ) 
                    {
                        alt75=1;
                    }
                    else if ( (LA75_0 == 92) ) 
                    {
                        alt75=2;
                    }
                    else 
                    {
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = "1239:2: (u= 'send' | u= 'recv' )";
                        EXCEPTION->decisionNum  = 75;
                        EXCEPTION->state        = 0;

                    
                        goto ruleudpRuleEx;
                    }
                }
                switch (alt75) 
                {
            	case 1:
            	    // AppArmor.g:1239:4: u= 'send'
            	    {
            	        u = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(91, &FOLLOW_91_in_udpRule2361); 


            	    }
            	    break;
            	case 2:
            	    // AppArmor.g:1240:4: u= 'recv'
            	    {
            	        u = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(92, &FOLLOW_92_in_udpRule2368); 


            	    }
            	    break;

                }
            }
            {
                 udp= (char *) u->getText(u)->chars; 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleudpRuleEx; /* Prevent compiler warnings */
    ruleudpRuleEx: ;



    	if (HASEXCEPTION())
    	{
    		if (mpTree != NULL)
    		{
    			ParseError *error = new_parse_error();
    			if (mpTree->pError != NULL)
    				free_parse_error(mpTree->pError);
    			mpTree->mError = 1;
    			mpTree->pError = error;
    			error->mLine = EXCEPTION->line;
    			error->mPos = EXCEPTION->charPositionInLine;
    			
    			if (EXCEPTION->name != NULL)
    			error->pName = strdup(EXCEPTION->name);
    			
    			if (EXCEPTION->message != NULL)
    			error->pMessage = strdup((char *) EXCEPTION->message);
    		}
    	}

    return udp;
}
/* $ANTLR end udpRule */

/** 
 * $ANTLR start networkHostRule
 * AppArmor.g:1244:1: networkHostRule returns [char *direction, char *iprule] : (d= 'to' | d= 'from' | d= 'endpoint' ) i= ipRule ;
 */
static AppArmorParser_networkHostRule_return
networkHostRule(pAppArmorParser ctx)
{   
    AppArmorParser_networkHostRule_return retval;

    pANTLR3_COMMON_TOKEN    d;
    char * i;
    #undef	RETURN_TYPE_i
    #define	RETURN_TYPE_i char *

    /* Initialize rule variables
     */


     retval.direction= NULL; retval.iprule= NULL; 
    d       = NULL;
    i = NULL;
    retval.start = LT(1);

    {
        // AppArmor.g:1246:2: ( (d= 'to' | d= 'from' | d= 'endpoint' ) i= ipRule )
        // AppArmor.g:1247:2: (d= 'to' | d= 'from' | d= 'endpoint' ) i= ipRule
        {

            // AppArmor.g:1247:2: (d= 'to' | d= 'from' | d= 'endpoint' )
            {
                int alt76=3;
                switch ( LA(1) ) 
                {
                case 93:
                	{
                		alt76=1;
                	}
                    break;
                case 94:
                	{
                		alt76=2;
                	}
                    break;
                case 95:
                	{
                		alt76=3;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = "1247:2: (d= 'to' | d= 'from' | d= 'endpoint' )";
                    EXCEPTION->decisionNum  = 76;
                    EXCEPTION->state        = 0;


                    goto rulenetworkHostRuleEx;
                }

                switch (alt76) 
                {
            	case 1:
            	    // AppArmor.g:1247:4: d= 'to'
            	    {
            	        d = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(93, &FOLLOW_93_in_networkHostRule2399); 


            	    }
            	    break;
            	case 2:
            	    // AppArmor.g:1248:4: d= 'from'
            	    {
            	        d = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(94, &FOLLOW_94_in_networkHostRule2406); 


            	    }
            	    break;
            	case 3:
            	    // AppArmor.g:1249:4: d= 'endpoint'
            	    {
            	        d = (pANTLR3_COMMON_TOKEN)LT(1);
            	        MATCHT(95, &FOLLOW_95_in_networkHostRule2413); 


            	    }
            	    break;

                }
            }
            FOLLOWPUSH(FOLLOW_ipRule_in_networkHostRule2420);
            i=ipRule(ctx);
            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenetworkHostRuleEx;
            }

            {
                 retval.direction= (char *) d->getText(d)->chars; retval.iprule= i; 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulenetworkHostRuleEx; /* Prevent compiler warnings */
    rulenetworkHostRuleEx: ;
    retval.stop = LT(-1);



    	if (HASEXCEPTION())
    	{
    		if (mpTree != NULL)
    		{
    			ParseError *error = new_parse_error();
    			if (mpTree->pError != NULL)
    				free_parse_error(mpTree->pError);
    			mpTree->mError = 1;
    			mpTree->pError = error;
    			error->mLine = EXCEPTION->line;
    			error->mPos = EXCEPTION->charPositionInLine;
    			
    			if (EXCEPTION->name != NULL)
    			error->pName = strdup(EXCEPTION->name);
    			
    			if (EXCEPTION->message != NULL)
    			error->pMessage = strdup((char *) EXCEPTION->message);
    		}
    	}

    return retval;
}
/* $ANTLR end networkHostRule */

/** 
 * $ANTLR start ipRule
 * AppArmor.g:1258:1: ipRule returns [char *iprule] : i= IDENT ;
 */
static char *
ipRule(pAppArmorParser ctx)
{   
    char * iprule = NULL;

    pANTLR3_COMMON_TOKEN    i;

    /* Initialize rule variables
     */


     iprule= NULL; 
    i       = NULL;

    {
        // AppArmor.g:1260:2: (i= IDENT )
        // AppArmor.g:1260:4: i= IDENT
        {
            i = (pANTLR3_COMMON_TOKEN)LT(1);
            MATCHT(IDENT, &FOLLOW_IDENT_in_ipRule2449); 

            {
                 iprule= (char *) i->getText(i)->chars; 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleipRuleEx; /* Prevent compiler warnings */
    ruleipRuleEx: ;



    	if (HASEXCEPTION())
    	{
    		if (mpTree != NULL)
    		{
    			ParseError *error = new_parse_error();
    			if (mpTree->pError != NULL)
    				free_parse_error(mpTree->pError);
    			mpTree->mError = 1;
    			mpTree->pError = error;
    			error->mLine = EXCEPTION->line;
    			error->mPos = EXCEPTION->charPositionInLine;
    			
    			if (EXCEPTION->name != NULL)
    			error->pName = strdup(EXCEPTION->name);
    			
    			if (EXCEPTION->message != NULL)
    			error->pMessage = strdup((char *) EXCEPTION->message);
    		}
    	}

    return iprule;
}
/* $ANTLR end ipRule */

/** 
 * $ANTLR start ifaceRule
 * AppArmor.g:1264:1: ifaceRule returns [char *iface] : 'via' i= IDENT ;
 */
static char *
ifaceRule(pAppArmorParser ctx)
{   
    char * iface = NULL;

    pANTLR3_COMMON_TOKEN    i;

    /* Initialize rule variables
     */


     iface= NULL; 
    i       = NULL;

    {
        // AppArmor.g:1266:2: ( 'via' i= IDENT )
        // AppArmor.g:1266:4: 'via' i= IDENT
        {
            MATCHT(96, &FOLLOW_96_in_ifaceRule2473); 

            i = (pANTLR3_COMMON_TOKEN)LT(1);
            MATCHT(IDENT, &FOLLOW_IDENT_in_ifaceRule2477); 

            {
                 iface= (char *) i->getText(i)->chars; 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleifaceRuleEx; /* Prevent compiler warnings */
    ruleifaceRuleEx: ;



    	if (HASEXCEPTION())
    	{
    		if (mpTree != NULL)
    		{
    			ParseError *error = new_parse_error();
    			if (mpTree->pError != NULL)
    				free_parse_error(mpTree->pError);
    			mpTree->mError = 1;
    			mpTree->pError = error;
    			error->mLine = EXCEPTION->line;
    			error->mPos = EXCEPTION->charPositionInLine;
    			
    			if (EXCEPTION->name != NULL)
    			error->pName = strdup(EXCEPTION->name);
    			
    			if (EXCEPTION->message != NULL)
    			error->pMessage = strdup((char *) EXCEPTION->message);
    		}
    	}

    return iface;
}
/* $ANTLR end ifaceRule */

/** 
 * $ANTLR start limitRule
 * AppArmor.g:1269:1: limitRule returns [char *limit] : 'limit' i= IDENT ;
 */
static char *
limitRule(pAppArmorParser ctx)
{   
    char * limit = NULL;

    pANTLR3_COMMON_TOKEN    i;

    /* Initialize rule variables
     */


     limit= NULL; 
    i       = NULL;

    {
        // AppArmor.g:1271:2: ( 'limit' i= IDENT )
        // AppArmor.g:1271:4: 'limit' i= IDENT
        {
            MATCHT(97, &FOLLOW_97_in_limitRule2500); 

            i = (pANTLR3_COMMON_TOKEN)LT(1);
            MATCHT(IDENT, &FOLLOW_IDENT_in_limitRule2504); 

            {
                 limit= (char *) i->getText(i)->chars; 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulelimitRuleEx; /* Prevent compiler warnings */
    rulelimitRuleEx: ;



    	if (HASEXCEPTION())
    	{
    		if (mpTree != NULL)
    		{
    			ParseError *error = new_parse_error();
    			if (mpTree->pError != NULL)
    				free_parse_error(mpTree->pError);
    			mpTree->mError = 1;
    			mpTree->pError = error;
    			error->mLine = EXCEPTION->line;
    			error->mPos = EXCEPTION->charPositionInLine;
    			
    			if (EXCEPTION->name != NULL)
    			error->pName = strdup(EXCEPTION->name);
    			
    			if (EXCEPTION->message != NULL)
    			error->pMessage = strdup((char *) EXCEPTION->message);
    		}
    	}

    return limit;
}
/* $ANTLR end limitRule */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */

 
 



/* End of code
 * =============================================================================
 */
